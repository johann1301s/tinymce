/*!
 * Source version: 1.9.10 
 * Copyright (C) 2024 LoopIndex - All Rights Reserved
 * You should have received a copy of the LoopIndex Comments plugin license with
 * this file. If not, please write to: loopindex@gmail.com, or visit http://www.loopindex.com
 *
 * Third party licenses:
 *
 * jQuery Library
 * Copyright OpenJS Foundation and other contributors, https://openjsf.org/
 * license: MIT (See Below)
 *
 * MIT License
 * ===========
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.====
 *
 * written by (David *)Frenkiel (https://github.com/imdfl) 
 */
!function(t) {
    var e = {};
    function n(i) {
        if (e[i])
            return e[i].exports;
        var o = e[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return t[i].call(o.exports, o, o.exports, n), o.l = !0, o.exports
    }
    n.m = t,
    n.c = e,
    n.d = function(t, e, i) {
        n.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: i
        })
    },
    n.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(t, "__esModule", {
            value: !0
        })
    },
    n.t = function(t, e) {
        if (1 & e && (t = n(t)), 8 & e)
            return t;
        if (4 & e && "object" == typeof t && t && t.__esModule)
            return t;
        var i = Object.create(null);
        if (n.r(i), Object.defineProperty(i, "default", {
            enumerable: !0,
            value: t
        }), 2 & e && "string" != typeof t)
            for (var o in t)
                n.d(i, o, function(e) {
                    return t[e]
                }.bind(null, o));
        return i
    },
    n.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return n.d(e, "a", e), e
    },
    n.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    },
    n.p = "",
    n(n.s = 0)
}([function(t, e, n) {
    var i;
    !function() {
        "use strict";
        var e = {};
        /*!
         * jQuery JavaScript Library v3.5.0 -ajax,-ajax/jsonp,-ajax/load,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-deprecated/ajax-event-alias,-effects,-effects/Tween,-effects/animatedSelector
         * https://jquery.com/
         *
         * Includes Sizzle.js
         * https://sizzlejs.com/
         *
         * Copyright JS Foundation and other contributors
         * Released under the MIT license
         * https://jquery.org/license
         *
         * Date: 2020-04-10T15:07Z
         */
        !function(t) {
            var e = window.LOOPINDEX;
            e && "object" == typeof e && e.$ && e.VERSION || (e = {}, Object.defineProperties(e, {
                VERSION: {
                    value: "1.9.12",
                    enumerable: !0,
                    writable: !1,
                    configurable: !1
                }
            }));
            var n = window.LOOPINDEX = e;
            n.$ && n.$.fn && n.$.fn.jquery || Object.defineProperty(e, "$", {
                value: t,
                enumerable: !0,
                writable: !1,
                configurable: !1
            })
        }(function(n) {
            var o = "3.5.0 -ajax,-ajax/jsonp,-ajax/load,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-deprecated/ajax-event-alias,-effects,-effects/Tween,-effects/animatedSelector",
                r = [],
                s = Object.getPrototypeOf,
                a = r.slice,
                l = r.flat ? function(t) {
                    return r.flat.call(t)
                } : function(t) {
                    return r.concat.apply([], t)
                },
                c = r.push,
                u = r.indexOf,
                d = {},
                h = d.toString,
                g = d.hasOwnProperty,
                m = g.toString,
                f = m.call(Object),
                p = {},
                v = function(t) {
                    return "function" == typeof t && "number" != typeof t.nodeType
                },
                _ = function(t) {
                    return null != t && t === t.window
                },
                y = n.document,
                b = {
                    type: !0,
                    src: !0,
                    nonce: !0,
                    noModule: !0
                };
            function E(t, e, n) {
                var i,
                    o,
                    r = (n = n || y).createElement("script");
                if (r.text = t, e)
                    for (i in b)
                        (o = e[i] || e.getAttribute && e.getAttribute(i)) && r.setAttribute(i, o);
                n.head.appendChild(r).parentNode.removeChild(r)
            }
            function w(t) {
                return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? d[h.call(t)] || "object" : typeof t
            }
            var A = function(t, e) {
                return new A.fn.init(t, e)
            };
            function C(t) {
                var e = !!t && "length" in t && t.length,
                    n = w(t);
                return !v(t) && !_(t) && ("array" === n || 0 === e || "number" == typeof e && e > 0 && e - 1 in t)
            }
            A.fn = A.prototype = {
                jquery: o,
                constructor: A,
                length: 0,
                toArray: function() {
                    return a.call(this)
                },
                get: function(t) {
                    return null == t ? a.call(this) : t < 0 ? this[t + this.length] : this[t]
                },
                pushStack: function(t) {
                    var e = A.merge(this.constructor(), t);
                    return e.prevObject = this, e
                },
                each: function(t) {
                    return A.each(this, t)
                },
                map: function(t) {
                    return this.pushStack(A.map(this, (function(e, n) {
                        return t.call(e, n, e)
                    })))
                },
                slice: function() {
                    return this.pushStack(a.apply(this, arguments))
                },
                first: function() {
                    return this.eq(0)
                },
                last: function() {
                    return this.eq(-1)
                },
                even: function() {
                    return this.pushStack(A.grep(this, (function(t, e) {
                        return (e + 1) % 2
                    })))
                },
                odd: function() {
                    return this.pushStack(A.grep(this, (function(t, e) {
                        return e % 2
                    })))
                },
                eq: function(t) {
                    var e = this.length,
                        n = +t + (t < 0 ? e : 0);
                    return this.pushStack(n >= 0 && n < e ? [this[n]] : [])
                },
                end: function() {
                    return this.prevObject || this.constructor()
                },
                push: c,
                sort: r.sort,
                splice: r.splice
            },
            A.extend = A.fn.extend = function() {
                var t,
                    e,
                    n,
                    i,
                    o,
                    r,
                    s = arguments[0] || {},
                    a = 1,
                    l = arguments.length,
                    c = !1;
                for ("boolean" == typeof s && (c = s, s = arguments[a] || {}, a++), "object" == typeof s || v(s) || (s = {}), a === l && (s = this, a--); a < l; a++)
                    if (null != (t = arguments[a]))
                        for (e in t)
                            i = t[e],
                            "__proto__" !== e && s !== i && (c && i && (A.isPlainObject(i) || (o = Array.isArray(i))) ? (n = s[e], r = o && !Array.isArray(n) ? [] : o || A.isPlainObject(n) ? n : {}, o = !1, s[e] = A.extend(c, r, i)) : void 0 !== i && (s[e] = i));
                return s
            },
            A.extend({
                expando: "jQuery" + (o + Math.random()).replace(/\D/g, ""),
                isReady: !0,
                error: function(t) {
                    throw new Error(t)
                },
                noop: function() {},
                isPlainObject: function(t) {
                    var e,
                        n;
                    return !(!t || "[object Object]" !== h.call(t)) && (!(e = s(t)) || "function" == typeof (n = g.call(e, "constructor") && e.constructor) && m.call(n) === f)
                },
                isEmptyObject: function(t) {
                    var e;
                    for (e in t)
                        return !1;
                    return !0
                },
                globalEval: function(t, e, n) {
                    E(t, {
                        nonce: e && e.nonce
                    }, n)
                },
                each: function(t, e) {
                    var n,
                        i = 0;
                    if (C(t))
                        for (n = t.length; i < n && !1 !== e.call(t[i], i, t[i]); i++)
                            ;
                    else
                        for (i in t)
                            if (!1 === e.call(t[i], i, t[i]))
                                break;
                    return t
                },
                makeArray: function(t, e) {
                    var n = e || [];
                    return null != t && (C(Object(t)) ? A.merge(n, "string" == typeof t ? [t] : t) : c.call(n, t)), n
                },
                inArray: function(t, e, n) {
                    return null == e ? -1 : u.call(e, t, n)
                },
                merge: function(t, e) {
                    for (var n = +e.length, i = 0, o = t.length; i < n; i++)
                        t[o++] = e[i];
                    return t.length = o, t
                },
                grep: function(t, e, n) {
                    for (var i = [], o = 0, r = t.length, s = !n; o < r; o++)
                        !e(t[o], o) !== s && i.push(t[o]);
                    return i
                },
                map: function(t, e, n) {
                    var i,
                        o,
                        r = 0,
                        s = [];
                    if (C(t))
                        for (i = t.length; r < i; r++)
                            null != (o = e(t[r], r, n)) && s.push(o);
                    else
                        for (r in t)
                            null != (o = e(t[r], r, n)) && s.push(o);
                    return l(s)
                },
                guid: 1,
                support: p
            }),
            "function" == typeof Symbol && (A.fn[Symbol.iterator] = r[Symbol.iterator]),
            A.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function(t, e) {
                d["[object " + e + "]"] = e.toLowerCase()
            }));
            var T = /*!
            		 * Sizzle CSS Selector Engine v2.3.5
            		 * https://sizzlejs.com/
            		 *
            		 * Copyright JS Foundation and other contributors
            		 * Released under the MIT license
            		 * https://js.foundation/
            		 *
            		 * Date: 2020-03-14
            		 */
            function(t) {
                var e,
                    n,
                    i,
                    o,
                    r,
                    s,
                    a,
                    l,
                    c,
                    u,
                    d,
                    h,
                    g,
                    m,
                    f,
                    p,
                    v,
                    _,
                    y,
                    b = "sizzle" + 1 * new Date,
                    E = t.document,
                    w = 0,
                    A = 0,
                    C = lt(),
                    T = lt(),
                    N = lt(),
                    S = lt(),
                    x = function(t, e) {
                        return t === e && (d = !0), 0
                    },
                    O = {}.hasOwnProperty,
                    I = [],
                    D = I.pop,
                    M = I.push,
                    L = I.push,
                    k = I.slice,
                    R = function(t, e) {
                        for (var n = 0, i = t.length; n < i; n++)
                            if (t[n] === e)
                                return n;
                        return -1
                    },
                    U = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                    P = "[\\x20\\t\\r\\n\\f]",
                    $ = "(?:\\\\[\\da-fA-F]{1,6}" + P + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
                    B = "\\[" + P + "*(" + $ + ")(?:" + P + "*([*^$|!~]?=)" + P + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + $ + "))|)" + P + "*\\]",
                    j = ":(" + $ + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + B + ")*)|.*)\\)|)",
                    V = new RegExp(P + "+", "g"),
                    F = new RegExp("^" + P + "+|((?:^|[^\\\\])(?:\\\\.)*)" + P + "+$", "g"),
                    H = new RegExp("^" + P + "*," + P + "*"),
                    z = new RegExp("^" + P + "*([>+~]|" + P + ")" + P + "*"),
                    q = new RegExp(P + "|>"),
                    W = new RegExp(j),
                    G = new RegExp("^" + $ + "$"),
                    X = {
                        ID: new RegExp("^#(" + $ + ")"),
                        CLASS: new RegExp("^\\.(" + $ + ")"),
                        TAG: new RegExp("^(" + $ + "|[*])"),
                        ATTR: new RegExp("^" + B),
                        PSEUDO: new RegExp("^" + j),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + P + "*(even|odd|(([+-]|)(\\d*)n|)" + P + "*(?:([+-]|)" + P + "*(\\d+)|))" + P + "*\\)|)", "i"),
                        bool: new RegExp("^(?:" + U + ")$", "i"),
                        needsContext: new RegExp("^" + P + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + P + "*((?:-\\d)?\\d*)" + P + "*\\)|)(?=[^-]|$)", "i")
                    },
                    Y = /HTML$/i,
                    K = /^(?:input|select|textarea|button)$/i,
                    Q = /^h\d$/i,
                    J = /^[^{]+\{\s*\[native \w/,
                    Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                    tt = /[+~]/,
                    et = new RegExp("\\\\[\\da-fA-F]{1,6}" + P + "?|\\\\([^\\r\\n\\f])", "g"),
                    nt = function(t, e) {
                        var n = "0x" + t.slice(1) - 65536;
                        return e || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
                    },
                    it = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                    ot = function(t, e) {
                        return e ? "\0" === t ? "�" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
                    },
                    rt = function() {
                        h()
                    },
                    st = bt((function(t) {
                        return !0 === t.disabled && "fieldset" === t.nodeName.toLowerCase()
                    }), {
                        dir: "parentNode",
                        next: "legend"
                    });
                try {
                    L.apply(I = k.call(E.childNodes), E.childNodes),
                    I[E.childNodes.length].nodeType
                } catch (t) {
                    L = {
                        apply: I.length ? function(t, e) {
                            M.apply(t, k.call(e))
                        } : function(t, e) {
                            for (var n = t.length, i = 0; t[n++] = e[i++];)
                                ;
                            t.length = n - 1
                        }
                    }
                }
                function at(t, e, i, o) {
                    var r,
                        a,
                        c,
                        u,
                        d,
                        m,
                        v,
                        _ = e && e.ownerDocument,
                        E = e ? e.nodeType : 9;
                    if (i = i || [], "string" != typeof t || !t || 1 !== E && 9 !== E && 11 !== E)
                        return i;
                    if (!o && (h(e), e = e || g, f)) {
                        if (11 !== E && (d = Z.exec(t)))
                            if (r = d[1]) {
                                if (9 === E) {
                                    if (!(c = e.getElementById(r)))
                                        return i;
                                    if (c.id === r)
                                        return i.push(c), i
                                } else if (_ && (c = _.getElementById(r)) && y(e, c) && c.id === r)
                                    return i.push(c), i
                            } else {
                                if (d[2])
                                    return L.apply(i, e.getElementsByTagName(t)), i;
                                if ((r = d[3]) && n.getElementsByClassName && e.getElementsByClassName)
                                    return L.apply(i, e.getElementsByClassName(r)), i
                            }
                        if (n.qsa && !S[t + " "] && (!p || !p.test(t)) && (1 !== E || "object" !== e.nodeName.toLowerCase())) {
                            if (v = t, _ = e, 1 === E && (q.test(t) || z.test(t))) {
                                for ((_ = tt.test(t) && vt(e.parentNode) || e) === e && n.scope || ((u = e.getAttribute("id")) ? u = u.replace(it, ot) : e.setAttribute("id", u = b)), a = (m = s(t)).length; a--;)
                                    m[a] = (u ? "#" + u : ":scope") + " " + yt(m[a]);
                                v = m.join(",")
                            }
                            try {
                                return L.apply(i, _.querySelectorAll(v)), i
                            } catch (e) {
                                S(t, !0)
                            } finally {
                                u === b && e.removeAttribute("id")
                            }
                        }
                    }
                    return l(t.replace(F, "$1"), e, i, o)
                }
                function lt() {
                    var t = [];
                    return function e(n, o) {
                        return t.push(n + " ") > i.cacheLength && delete e[t.shift()], e[n + " "] = o
                    }
                }
                function ct(t) {
                    return t[b] = !0, t
                }
                function ut(t) {
                    var e = g.createElement("fieldset");
                    try {
                        return !!t(e)
                    } catch (t) {
                        return !1
                    } finally {
                        e.parentNode && e.parentNode.removeChild(e),
                        e = null
                    }
                }
                function dt(t, e) {
                    for (var n = t.split("|"), o = n.length; o--;)
                        i.attrHandle[n[o]] = e
                }
                function ht(t, e) {
                    var n = e && t,
                        i = n && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
                    if (i)
                        return i;
                    if (n)
                        for (; n = n.nextSibling;)
                            if (n === e)
                                return -1;
                    return t ? 1 : -1
                }
                function gt(t) {
                    return function(e) {
                        return "input" === e.nodeName.toLowerCase() && e.type === t
                    }
                }
                function mt(t) {
                    return function(e) {
                        var n = e.nodeName.toLowerCase();
                        return ("input" === n || "button" === n) && e.type === t
                    }
                }
                function ft(t) {
                    return function(e) {
                        return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && st(e) === t : e.disabled === t : "label" in e && e.disabled === t
                    }
                }
                function pt(t) {
                    return ct((function(e) {
                        return e = +e, ct((function(n, i) {
                            for (var o, r = t([], n.length, e), s = r.length; s--;)
                                n[o = r[s]] && (n[o] = !(i[o] = n[o]))
                        }))
                    }))
                }
                function vt(t) {
                    return t && void 0 !== t.getElementsByTagName && t
                }
                for (e in n = at.support = {}, r = at.isXML = function(t) {
                    var e = t.namespaceURI,
                        n = (t.ownerDocument || t).documentElement;
                    return !Y.test(e || n && n.nodeName || "HTML")
                }, h = at.setDocument = function(t) {
                    var e,
                        o,
                        s = t ? t.ownerDocument || t : E;
                    return s != g && 9 === s.nodeType && s.documentElement ? (m = (g = s).documentElement, f = !r(g), E != g && (o = g.defaultView) && o.top !== o && (o.addEventListener ? o.addEventListener("unload", rt, !1) : o.attachEvent && o.attachEvent("onunload", rt)), n.scope = ut((function(t) {
                        return m.appendChild(t).appendChild(g.createElement("div")), void 0 !== t.querySelectorAll && !t.querySelectorAll(":scope fieldset div").length
                    })), n.attributes = ut((function(t) {
                        return t.className = "i", !t.getAttribute("className")
                    })), n.getElementsByTagName = ut((function(t) {
                        return t.appendChild(g.createComment("")), !t.getElementsByTagName("*").length
                    })), n.getElementsByClassName = J.test(g.getElementsByClassName), n.getById = ut((function(t) {
                        return m.appendChild(t).id = b, !g.getElementsByName || !g.getElementsByName(b).length
                    })), n.getById ? (i.filter.ID = function(t) {
                        var e = t.replace(et, nt);
                        return function(t) {
                            return t.getAttribute("id") === e
                        }
                    }, i.find.ID = function(t, e) {
                        if (void 0 !== e.getElementById && f) {
                            var n = e.getElementById(t);
                            return n ? [n] : []
                        }
                    }) : (i.filter.ID = function(t) {
                        var e = t.replace(et, nt);
                        return function(t) {
                            var n = void 0 !== t.getAttributeNode && t.getAttributeNode("id");
                            return n && n.value === e
                        }
                    }, i.find.ID = function(t, e) {
                        if (void 0 !== e.getElementById && f) {
                            var n,
                                i,
                                o,
                                r = e.getElementById(t);
                            if (r) {
                                if ((n = r.getAttributeNode("id")) && n.value === t)
                                    return [r];
                                for (o = e.getElementsByName(t), i = 0; r = o[i++];)
                                    if ((n = r.getAttributeNode("id")) && n.value === t)
                                        return [r]
                            }
                            return []
                        }
                    }), i.find.TAG = n.getElementsByTagName ? function(t, e) {
                        return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : n.qsa ? e.querySelectorAll(t) : void 0
                    } : function(t, e) {
                        var n,
                            i = [],
                            o = 0,
                            r = e.getElementsByTagName(t);
                        if ("*" === t) {
                            for (; n = r[o++];)
                                1 === n.nodeType && i.push(n);
                            return i
                        }
                        return r
                    }, i.find.CLASS = n.getElementsByClassName && function(t, e) {
                        if (void 0 !== e.getElementsByClassName && f)
                            return e.getElementsByClassName(t)
                    }, v = [], p = [], (n.qsa = J.test(g.querySelectorAll)) && (ut((function(t) {
                        var e;
                        m.appendChild(t).innerHTML = "<a id='" + b + "'></a><select id='" + b + "-\r\\' msallowcapture=''><option selected=''></option></select>",
                        t.querySelectorAll("[msallowcapture^='']").length && p.push("[*^$]=" + P + "*(?:''|\"\")"),
                        t.querySelectorAll("[selected]").length || p.push("\\[" + P + "*(?:value|" + U + ")"),
                        t.querySelectorAll("[id~=" + b + "-]").length || p.push("~="),
                        (e = g.createElement("input")).setAttribute("name", ""),
                        t.appendChild(e),
                        t.querySelectorAll("[name='']").length || p.push("\\[" + P + "*name" + P + "*=" + P + "*(?:''|\"\")"),
                        t.querySelectorAll(":checked").length || p.push(":checked"),
                        t.querySelectorAll("a#" + b + "+*").length || p.push(".#.+[+~]"),
                        t.querySelectorAll("\\\f"),
                        p.push("[\\r\\n\\f]")
                    })), ut((function(t) {
                        t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                        var e = g.createElement("input");
                        e.setAttribute("type", "hidden"),
                        t.appendChild(e).setAttribute("name", "D"),
                        t.querySelectorAll("[name=d]").length && p.push("name" + P + "*[*^$|!~]?="),
                        2 !== t.querySelectorAll(":enabled").length && p.push(":enabled", ":disabled"),
                        m.appendChild(t).disabled = !0,
                        2 !== t.querySelectorAll(":disabled").length && p.push(":enabled", ":disabled"),
                        t.querySelectorAll("*,:x"),
                        p.push(",.*:")
                    }))), (n.matchesSelector = J.test(_ = m.matches || m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) && ut((function(t) {
                        n.disconnectedMatch = _.call(t, "*"),
                        _.call(t, "[s!='']:x"),
                        v.push("!=", j)
                    })), p = p.length && new RegExp(p.join("|")), v = v.length && new RegExp(v.join("|")), e = J.test(m.compareDocumentPosition), y = e || J.test(m.contains) ? function(t, e) {
                        var n = 9 === t.nodeType ? t.documentElement : t,
                            i = e && e.parentNode;
                        return t === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(i)))
                    } : function(t, e) {
                        if (e)
                            for (; e = e.parentNode;)
                                if (e === t)
                                    return !0;
                        return !1
                    }, x = e ? function(t, e) {
                        if (t === e)
                            return d = !0, 0;
                        var i = !t.compareDocumentPosition - !e.compareDocumentPosition;
                        return i || (1 & (i = (t.ownerDocument || t) == (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1) || !n.sortDetached && e.compareDocumentPosition(t) === i ? t == g || t.ownerDocument == E && y(E, t) ? -1 : e == g || e.ownerDocument == E && y(E, e) ? 1 : u ? R(u, t) - R(u, e) : 0 : 4 & i ? -1 : 1)
                    } : function(t, e) {
                        if (t === e)
                            return d = !0, 0;
                        var n,
                            i = 0,
                            o = t.parentNode,
                            r = e.parentNode,
                            s = [t],
                            a = [e];
                        if (!o || !r)
                            return t == g ? -1 : e == g ? 1 : o ? -1 : r ? 1 : u ? R(u, t) - R(u, e) : 0;
                        if (o === r)
                            return ht(t, e);
                        for (n = t; n = n.parentNode;)
                            s.unshift(n);
                        for (n = e; n = n.parentNode;)
                            a.unshift(n);
                        for (; s[i] === a[i];)
                            i++;
                        return i ? ht(s[i], a[i]) : s[i] == E ? -1 : a[i] == E ? 1 : 0
                    }, g) : g
                }, at.matches = function(t, e) {
                    return at(t, null, null, e)
                }, at.matchesSelector = function(t, e) {
                    if (h(t), n.matchesSelector && f && !S[e + " "] && (!v || !v.test(e)) && (!p || !p.test(e)))
                        try {
                            var i = _.call(t, e);
                            if (i || n.disconnectedMatch || t.document && 11 !== t.document.nodeType)
                                return i
                        } catch (t) {
                            S(e, !0)
                        }
                    return at(e, g, null, [t]).length > 0
                }, at.contains = function(t, e) {
                    return (t.ownerDocument || t) != g && h(t), y(t, e)
                }, at.attr = function(t, e) {
                    (t.ownerDocument || t) != g && h(t);
                    var o = i.attrHandle[e.toLowerCase()],
                        r = o && O.call(i.attrHandle, e.toLowerCase()) ? o(t, e, !f) : void 0;
                    return void 0 !== r ? r : n.attributes || !f ? t.getAttribute(e) : (r = t.getAttributeNode(e)) && r.specified ? r.value : null
                }, at.escape = function(t) {
                    return (t + "").replace(it, ot)
                }, at.error = function(t) {
                    throw new Error("Syntax error, unrecognized expression: " + t)
                }, at.uniqueSort = function(t) {
                    var e,
                        i = [],
                        o = 0,
                        r = 0;
                    if (d = !n.detectDuplicates, u = !n.sortStable && t.slice(0), t.sort(x), d) {
                        for (; e = t[r++];)
                            e === t[r] && (o = i.push(r));
                        for (; o--;)
                            t.splice(i[o], 1)
                    }
                    return u = null, t
                }, o = at.getText = function(t) {
                    var e,
                        n = "",
                        i = 0,
                        r = t.nodeType;
                    if (r) {
                        if (1 === r || 9 === r || 11 === r) {
                            if ("string" == typeof t.textContent)
                                return t.textContent;
                            for (t = t.firstChild; t; t = t.nextSibling)
                                n += o(t)
                        } else if (3 === r || 4 === r)
                            return t.nodeValue
                    } else
                        for (; e = t[i++];)
                            n += o(e);
                    return n
                }, (i = at.selectors = {
                    cacheLength: 50,
                    createPseudo: ct,
                    match: X,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function(t) {
                            return t[1] = t[1].replace(et, nt), t[3] = (t[3] || t[4] || t[5] || "").replace(et, nt), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
                        },
                        CHILD: function(t) {
                            return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || at.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && at.error(t[0]), t
                        },
                        PSEUDO: function(t) {
                            var e,
                                n = !t[6] && t[2];
                            return X.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : n && W.test(n) && (e = s(n, !0)) && (e = n.indexOf(")", n.length - e) - n.length) && (t[0] = t[0].slice(0, e), t[2] = n.slice(0, e)), t.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function(t) {
                            var e = t.replace(et, nt).toLowerCase();
                            return "*" === t ? function() {
                                return !0
                            } : function(t) {
                                return t.nodeName && t.nodeName.toLowerCase() === e
                            }
                        },
                        CLASS: function(t) {
                            var e = C[t + " "];
                            return e || (e = new RegExp("(^|" + P + ")" + t + "(" + P + "|$)")) && C(t, (function(t) {
                                    return e.test("string" == typeof t.className && t.className || void 0 !== t.getAttribute && t.getAttribute("class") || "")
                                }))
                        },
                        ATTR: function(t, e, n) {
                            return function(i) {
                                var o = at.attr(i, t);
                                return null == o ? "!=" === e : !e || (o += "", "=" === e ? o === n : "!=" === e ? o !== n : "^=" === e ? n && 0 === o.indexOf(n) : "*=" === e ? n && o.indexOf(n) > -1 : "$=" === e ? n && o.slice(-n.length) === n : "~=" === e ? (" " + o.replace(V, " ") + " ").indexOf(n) > -1 : "|=" === e && (o === n || o.slice(0, n.length + 1) === n + "-"))
                            }
                        },
                        CHILD: function(t, e, n, i, o) {
                            var r = "nth" !== t.slice(0, 3),
                                s = "last" !== t.slice(-4),
                                a = "of-type" === e;
                            return 1 === i && 0 === o ? function(t) {
                                return !!t.parentNode
                            } : function(e, n, l) {
                                var c,
                                    u,
                                    d,
                                    h,
                                    g,
                                    m,
                                    f = r !== s ? "nextSibling" : "previousSibling",
                                    p = e.parentNode,
                                    v = a && e.nodeName.toLowerCase(),
                                    _ = !l && !a,
                                    y = !1;
                                if (p) {
                                    if (r) {
                                        for (; f;) {
                                            for (h = e; h = h[f];)
                                                if (a ? h.nodeName.toLowerCase() === v : 1 === h.nodeType)
                                                    return !1;
                                            m = f = "only" === t && !m && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (m = [s ? p.firstChild : p.lastChild], s && _) {
                                        for (y = (g = (c = (u = (d = (h = p)[b] || (h[b] = {}))[h.uniqueID] || (d[h.uniqueID] = {}))[t] || [])[0] === w && c[1]) && c[2], h = g && p.childNodes[g]; h = ++g && h && h[f] || (y = g = 0) || m.pop();)
                                            if (1 === h.nodeType && ++y && h === e) {
                                                u[t] = [w, g, y];
                                                break
                                            }
                                    } else if (_ && (y = g = (c = (u = (d = (h = e)[b] || (h[b] = {}))[h.uniqueID] || (d[h.uniqueID] = {}))[t] || [])[0] === w && c[1]), !1 === y)
                                        for (; (h = ++g && h && h[f] || (y = g = 0) || m.pop()) && ((a ? h.nodeName.toLowerCase() !== v : 1 !== h.nodeType) || !++y || (_ && ((u = (d = h[b] || (h[b] = {}))[h.uniqueID] || (d[h.uniqueID] = {}))[t] = [w, y]), h !== e));)
                                            ;
                                    return (y -= o) === i || y % i == 0 && y / i >= 0
                                }
                            }
                        },
                        PSEUDO: function(t, e) {
                            var n,
                                o = i.pseudos[t] || i.setFilters[t.toLowerCase()] || at.error("unsupported pseudo: " + t);
                            return o[b] ? o(e) : o.length > 1 ? (n = [t, t, "", e], i.setFilters.hasOwnProperty(t.toLowerCase()) ? ct((function(t, n) {
                                for (var i, r = o(t, e), s = r.length; s--;)
                                    t[i = R(t, r[s])] = !(n[i] = r[s])
                            })) : function(t) {
                                return o(t, 0, n)
                            }) : o
                        }
                    },
                    pseudos: {
                        not: ct((function(t) {
                            var e = [],
                                n = [],
                                i = a(t.replace(F, "$1"));
                            return i[b] ? ct((function(t, e, n, o) {
                                for (var r, s = i(t, null, o, []), a = t.length; a--;)
                                    (r = s[a]) && (t[a] = !(e[a] = r))
                            })) : function(t, o, r) {
                                return e[0] = t, i(e, null, r, n), e[0] = null, !n.pop()
                            }
                        })),
                        has: ct((function(t) {
                            return function(e) {
                                return at(t, e).length > 0
                            }
                        })),
                        contains: ct((function(t) {
                            return t = t.replace(et, nt), function(e) {
                                return (e.textContent || o(e)).indexOf(t) > -1
                            }
                        })),
                        lang: ct((function(t) {
                            return G.test(t || "") || at.error("unsupported lang: " + t), t = t.replace(et, nt).toLowerCase(), function(e) {
                                var n;
                                do {
                                    if (n = f ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang"))
                                        return (n = n.toLowerCase()) === t || 0 === n.indexOf(t + "-")
                                } while ((e = e.parentNode) && 1 === e.nodeType);
                                return !1
                            }
                        })),
                        target: function(e) {
                            var n = t.location && t.location.hash;
                            return n && n.slice(1) === e.id
                        },
                        root: function(t) {
                            return t === m
                        },
                        focus: function(t) {
                            return t === g.activeElement && (!g.hasFocus || g.hasFocus()) && !!(t.type || t.href || ~t.tabIndex)
                        },
                        enabled: ft(!1),
                        disabled: ft(!0),
                        checked: function(t) {
                            var e = t.nodeName.toLowerCase();
                            return "input" === e && !!t.checked || "option" === e && !!t.selected
                        },
                        selected: function(t) {
                            return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected
                        },
                        empty: function(t) {
                            for (t = t.firstChild; t; t = t.nextSibling)
                                if (t.nodeType < 6)
                                    return !1;
                            return !0
                        },
                        parent: function(t) {
                            return !i.pseudos.empty(t)
                        },
                        header: function(t) {
                            return Q.test(t.nodeName)
                        },
                        input: function(t) {
                            return K.test(t.nodeName)
                        },
                        button: function(t) {
                            var e = t.nodeName.toLowerCase();
                            return "input" === e && "button" === t.type || "button" === e
                        },
                        text: function(t) {
                            var e;
                            return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase())
                        },
                        first: pt((function() {
                            return [0]
                        })),
                        last: pt((function(t, e) {
                            return [e - 1]
                        })),
                        eq: pt((function(t, e, n) {
                            return [n < 0 ? n + e : n]
                        })),
                        even: pt((function(t, e) {
                            for (var n = 0; n < e; n += 2)
                                t.push(n);
                            return t
                        })),
                        odd: pt((function(t, e) {
                            for (var n = 1; n < e; n += 2)
                                t.push(n);
                            return t
                        })),
                        lt: pt((function(t, e, n) {
                            for (var i = n < 0 ? n + e : n > e ? e : n; --i >= 0;)
                                t.push(i);
                            return t
                        })),
                        gt: pt((function(t, e, n) {
                            for (var i = n < 0 ? n + e : n; ++i < e;)
                                t.push(i);
                            return t
                        }))
                    }
                }).pseudos.nth = i.pseudos.eq, {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                })
                    i.pseudos[e] = gt(e);
                for (e in {
                    submit: !0,
                    reset: !0
                })
                    i.pseudos[e] = mt(e);
                function _t() {}
                function yt(t) {
                    for (var e = 0, n = t.length, i = ""; e < n; e++)
                        i += t[e].value;
                    return i
                }
                function bt(t, e, n) {
                    var i = e.dir,
                        o = e.next,
                        r = o || i,
                        s = n && "parentNode" === r,
                        a = A++;
                    return e.first ? function(e, n, o) {
                        for (; e = e[i];)
                            if (1 === e.nodeType || s)
                                return t(e, n, o);
                        return !1
                    } : function(e, n, l) {
                        var c,
                            u,
                            d,
                            h = [w, a];
                        if (l) {
                            for (; e = e[i];)
                                if ((1 === e.nodeType || s) && t(e, n, l))
                                    return !0
                        } else
                            for (; e = e[i];)
                                if (1 === e.nodeType || s)
                                    if (u = (d = e[b] || (e[b] = {}))[e.uniqueID] || (d[e.uniqueID] = {}), o && o === e.nodeName.toLowerCase())
                                        e = e[i] || e;
                                    else {
                                        if ((c = u[r]) && c[0] === w && c[1] === a)
                                            return h[2] = c[2];
                                        if (u[r] = h, h[2] = t(e, n, l))
                                            return !0
                                    }
                        return !1
                    }
                }
                function Et(t) {
                    return t.length > 1 ? function(e, n, i) {
                        for (var o = t.length; o--;)
                            if (!t[o](e, n, i))
                                return !1;
                        return !0
                    } : t[0]
                }
                function wt(t, e, n, i, o) {
                    for (var r, s = [], a = 0, l = t.length, c = null != e; a < l; a++)
                        (r = t[a]) && (n && !n(r, i, o) || (s.push(r), c && e.push(a)));
                    return s
                }
                function At(t, e, n, i, o, r) {
                    return i && !i[b] && (i = At(i)), o && !o[b] && (o = At(o, r)), ct((function(r, s, a, l) {
                        var c,
                            u,
                            d,
                            h = [],
                            g = [],
                            m = s.length,
                            f = r || function(t, e, n) {
                                for (var i = 0, o = e.length; i < o; i++)
                                    at(t, e[i], n);
                                return n
                            }(e || "*", a.nodeType ? [a] : a, []),
                            p = !t || !r && e ? f : wt(f, h, t, a, l),
                            v = n ? o || (r ? t : m || i) ? [] : s : p;
                        if (n && n(p, v, a, l), i)
                            for (c = wt(v, g), i(c, [], a, l), u = c.length; u--;)
                                (d = c[u]) && (v[g[u]] = !(p[g[u]] = d));
                        if (r) {
                            if (o || t) {
                                if (o) {
                                    for (c = [], u = v.length; u--;)
                                        (d = v[u]) && c.push(p[u] = d);
                                    o(null, v = [], c, l)
                                }
                                for (u = v.length; u--;)
                                    (d = v[u]) && (c = o ? R(r, d) : h[u]) > -1 && (r[c] = !(s[c] = d))
                            }
                        } else
                            v = wt(v === s ? v.splice(m, v.length) : v),
                            o ? o(null, s, v, l) : L.apply(s, v)
                    }))
                }
                function Ct(t) {
                    for (var e, n, o, r = t.length, s = i.relative[t[0].type], a = s || i.relative[" "], l = s ? 1 : 0, u = bt((function(t) {
                            return t === e
                        }), a, !0), d = bt((function(t) {
                            return R(e, t) > -1
                        }), a, !0), h = [function(t, n, i) {
                            var o = !s && (i || n !== c) || ((e = n).nodeType ? u(t, n, i) : d(t, n, i));
                            return e = null, o
                        }]; l < r; l++)
                        if (n = i.relative[t[l].type])
                            h = [bt(Et(h), n)];
                        else {
                            if ((n = i.filter[t[l].type].apply(null, t[l].matches))[b]) {
                                for (o = ++l; o < r && !i.relative[t[o].type]; o++)
                                    ;
                                return At(l > 1 && Et(h), l > 1 && yt(t.slice(0, l - 1).concat({
                                    value: " " === t[l - 2].type ? "*" : ""
                                })).replace(F, "$1"), n, l < o && Ct(t.slice(l, o)), o < r && Ct(t = t.slice(o)), o < r && yt(t))
                            }
                            h.push(n)
                        }
                    return Et(h)
                }
                return _t.prototype = i.filters = i.pseudos, i.setFilters = new _t, s = at.tokenize = function(t, e) {
                    var n,
                        o,
                        r,
                        s,
                        a,
                        l,
                        c,
                        u = T[t + " "];
                    if (u)
                        return e ? 0 : u.slice(0);
                    for (a = t, l = [], c = i.preFilter; a;) {
                        for (s in n && !(o = H.exec(a)) || (o && (a = a.slice(o[0].length) || a), l.push(r = [])), n = !1, (o = z.exec(a)) && (n = o.shift(), r.push({
                            value: n,
                            type: o[0].replace(F, " ")
                        }), a = a.slice(n.length)), i.filter)
                            !(o = X[s].exec(a)) || c[s] && !(o = c[s](o)) || (n = o.shift(), r.push({
                                value: n,
                                type: s,
                                matches: o
                            }), a = a.slice(n.length));
                        if (!n)
                            break
                    }
                    return e ? a.length : a ? at.error(t) : T(t, l).slice(0)
                }, a = at.compile = function(t, e) {
                    var n,
                        o = [],
                        r = [],
                        a = N[t + " "];
                    if (!a) {
                        for (e || (e = s(t)), n = e.length; n--;)
                            (a = Ct(e[n]))[b] ? o.push(a) : r.push(a);
                        (a = N(t, function(t, e) {
                            var n = e.length > 0,
                                o = t.length > 0,
                                r = function(r, s, a, l, u) {
                                    var d,
                                        m,
                                        p,
                                        v = 0,
                                        _ = "0",
                                        y = r && [],
                                        b = [],
                                        E = c,
                                        A = r || o && i.find.TAG("*", u),
                                        C = w += null == E ? 1 : Math.random() || .1,
                                        T = A.length;
                                    for (u && (c = s == g || s || u); _ !== T && null != (d = A[_]); _++) {
                                        if (o && d) {
                                            for (m = 0, s || d.ownerDocument == g || (h(d), a = !f); p = t[m++];)
                                                if (p(d, s || g, a)) {
                                                    l.push(d);
                                                    break
                                                }
                                            u && (w = C)
                                        }
                                        n && ((d = !p && d) && v--, r && y.push(d))
                                    }
                                    if (v += _, n && _ !== v) {
                                        for (m = 0; p = e[m++];)
                                            p(y, b, s, a);
                                        if (r) {
                                            if (v > 0)
                                                for (; _--;)
                                                    y[_] || b[_] || (b[_] = D.call(l));
                                            b = wt(b)
                                        }
                                        L.apply(l, b),
                                        u && !r && b.length > 0 && v + e.length > 1 && at.uniqueSort(l)
                                    }
                                    return u && (w = C, c = E), y
                                };
                            return n ? ct(r) : r
                        }(r, o))).selector = t
                    }
                    return a
                }, l = at.select = function(t, e, n, o) {
                    var r,
                        l,
                        c,
                        u,
                        d,
                        h = "function" == typeof t && t,
                        g = !o && s(t = h.selector || t);
                    if (n = n || [], 1 === g.length) {
                        if ((l = g[0] = g[0].slice(0)).length > 2 && "ID" === (c = l[0]).type && 9 === e.nodeType && f && i.relative[l[1].type]) {
                            if (!(e = (i.find.ID(c.matches[0].replace(et, nt), e) || [])[0]))
                                return n;
                            h && (e = e.parentNode),
                            t = t.slice(l.shift().value.length)
                        }
                        for (r = X.needsContext.test(t) ? 0 : l.length; r-- && (c = l[r], !i.relative[u = c.type]);)
                            if ((d = i.find[u]) && (o = d(c.matches[0].replace(et, nt), tt.test(l[0].type) && vt(e.parentNode) || e))) {
                                if (l.splice(r, 1), !(t = o.length && yt(l)))
                                    return L.apply(n, o), n;
                                break
                            }
                    }
                    return (h || a(t, g))(o, e, !f, n, !e || tt.test(t) && vt(e.parentNode) || e), n
                }, n.sortStable = b.split("").sort(x).join("") === b, n.detectDuplicates = !!d, h(), n.sortDetached = ut((function(t) {
                    return 1 & t.compareDocumentPosition(g.createElement("fieldset"))
                })), ut((function(t) {
                    return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href")
                })) || dt("type|href|height|width", (function(t, e, n) {
                    if (!n)
                        return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
                })), n.attributes && ut((function(t) {
                    return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value")
                })) || dt("value", (function(t, e, n) {
                    if (!n && "input" === t.nodeName.toLowerCase())
                        return t.defaultValue
                })), ut((function(t) {
                    return null == t.getAttribute("disabled")
                })) || dt(U, (function(t, e, n) {
                    var i;
                    if (!n)
                        return !0 === t[e] ? e.toLowerCase() : (i = t.getAttributeNode(e)) && i.specified ? i.value : null
                })), at
            }(n);
            A.find = T,
            A.expr = T.selectors,
            A.expr[":"] = A.expr.pseudos,
            A.uniqueSort = A.unique = T.uniqueSort,
            A.text = T.getText,
            A.isXMLDoc = T.isXML,
            A.contains = T.contains,
            A.escapeSelector = T.escape;
            var N = function(t, e, n) {
                    for (var i = [], o = void 0 !== n; (t = t[e]) && 9 !== t.nodeType;)
                        if (1 === t.nodeType) {
                            if (o && A(t).is(n))
                                break;
                            i.push(t)
                        }
                    return i
                },
                S = function(t, e) {
                    for (var n = []; t; t = t.nextSibling)
                        1 === t.nodeType && t !== e && n.push(t);
                    return n
                },
                x = A.expr.match.needsContext;
            function O(t, e) {
                return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
            }
            var I = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
            function D(t, e, n) {
                return v(e) ? A.grep(t, (function(t, i) {
                    return !!e.call(t, i, t) !== n
                })) : e.nodeType ? A.grep(t, (function(t) {
                    return t === e !== n
                })) : "string" != typeof e ? A.grep(t, (function(t) {
                    return u.call(e, t) > -1 !== n
                })) : A.filter(e, t, n)
            }
            A.filter = function(t, e, n) {
                var i = e[0];
                return n && (t = ":not(" + t + ")"), 1 === e.length && 1 === i.nodeType ? A.find.matchesSelector(i, t) ? [i] : [] : A.find.matches(t, A.grep(e, (function(t) {
                    return 1 === t.nodeType
                })))
            },
            A.fn.extend({
                find: function(t) {
                    var e,
                        n,
                        i = this.length,
                        o = this;
                    if ("string" != typeof t)
                        return this.pushStack(A(t).filter((function() {
                            for (e = 0; e < i; e++)
                                if (A.contains(o[e], this))
                                    return !0
                        })));
                    for (n = this.pushStack([]), e = 0; e < i; e++)
                        A.find(t, o[e], n);
                    return i > 1 ? A.uniqueSort(n) : n
                },
                filter: function(t) {
                    return this.pushStack(D(this, t || [], !1))
                },
                not: function(t) {
                    return this.pushStack(D(this, t || [], !0))
                },
                is: function(t) {
                    return !!D(this, "string" == typeof t && x.test(t) ? A(t) : t || [], !1).length
                }
            });
            var M,
                L = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
            (A.fn.init = function(t, e, n) {
                var i,
                    o;
                if (!t)
                    return this;
                if (n = n || M, "string" == typeof t) {
                    if (!(i = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : L.exec(t)) || !i[1] && e)
                        return !e || e.jquery ? (e || n).find(t) : this.constructor(e).find(t);
                    if (i[1]) {
                        if (e = e instanceof A ? e[0] : e, A.merge(this, A.parseHTML(i[1], e && e.nodeType ? e.ownerDocument || e : y, !0)), I.test(i[1]) && A.isPlainObject(e))
                            for (i in e)
                                v(this[i]) ? this[i](e[i]) : this.attr(i, e[i]);
                        return this
                    }
                    return (o = y.getElementById(i[2])) && (this[0] = o, this.length = 1), this
                }
                return t.nodeType ? (this[0] = t, this.length = 1, this) : v(t) ? void 0 !== n.ready ? n.ready(t) : t(A) : A.makeArray(t, this)
            }).prototype = A.fn,
            M = A(y);
            var k = /^(?:parents|prev(?:Until|All))/,
                R = {
                    children: !0,
                    contents: !0,
                    next: !0,
                    prev: !0
                };
            function U(t, e) {
                for (; (t = t[e]) && 1 !== t.nodeType;)
                    ;
                return t
            }
            A.fn.extend({
                has: function(t) {
                    var e = A(t, this),
                        n = e.length;
                    return this.filter((function() {
                        for (var t = 0; t < n; t++)
                            if (A.contains(this, e[t]))
                                return !0
                    }))
                },
                closest: function(t, e) {
                    var n,
                        i = 0,
                        o = this.length,
                        r = [],
                        s = "string" != typeof t && A(t);
                    if (!x.test(t))
                        for (; i < o; i++)
                            for (n = this[i]; n && n !== e; n = n.parentNode)
                                if (n.nodeType < 11 && (s ? s.index(n) > -1 : 1 === n.nodeType && A.find.matchesSelector(n, t))) {
                                    r.push(n);
                                    break
                                }
                    return this.pushStack(r.length > 1 ? A.uniqueSort(r) : r)
                },
                index: function(t) {
                    return t ? "string" == typeof t ? u.call(A(t), this[0]) : u.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                },
                add: function(t, e) {
                    return this.pushStack(A.uniqueSort(A.merge(this.get(), A(t, e))))
                },
                addBack: function(t) {
                    return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
                }
            }),
            A.each({
                parent: function(t) {
                    var e = t.parentNode;
                    return e && 11 !== e.nodeType ? e : null
                },
                parents: function(t) {
                    return N(t, "parentNode")
                },
                parentsUntil: function(t, e, n) {
                    return N(t, "parentNode", n)
                },
                next: function(t) {
                    return U(t, "nextSibling")
                },
                prev: function(t) {
                    return U(t, "previousSibling")
                },
                nextAll: function(t) {
                    return N(t, "nextSibling")
                },
                prevAll: function(t) {
                    return N(t, "previousSibling")
                },
                nextUntil: function(t, e, n) {
                    return N(t, "nextSibling", n)
                },
                prevUntil: function(t, e, n) {
                    return N(t, "previousSibling", n)
                },
                siblings: function(t) {
                    return S((t.parentNode || {}).firstChild, t)
                },
                children: function(t) {
                    return S(t.firstChild)
                },
                contents: function(t) {
                    return null != t.contentDocument && s(t.contentDocument) ? t.contentDocument : (O(t, "template") && (t = t.content || t), A.merge([], t.childNodes))
                }
            }, (function(t, e) {
                A.fn[t] = function(n, i) {
                    var o = A.map(this, e, n);
                    return "Until" !== t.slice(-5) && (i = n), i && "string" == typeof i && (o = A.filter(i, o)), this.length > 1 && (R[t] || A.uniqueSort(o), k.test(t) && o.reverse()), this.pushStack(o)
                }
            }));
            var P = /[^\x20\t\r\n\f]+/g;
            function $(t) {
                return t
            }
            function B(t) {
                throw t
            }
            function j(t, e, n, i) {
                var o;
                try {
                    t && v(o = t.promise) ? o.call(t).done(e).fail(n) : t && v(o = t.then) ? o.call(t, e, n) : e.apply(void 0, [t].slice(i))
                } catch (t) {
                    n.apply(void 0, [t])
                }
            }
            A.Callbacks = function(t) {
                t = "string" == typeof t ? function(t) {
                    var e = {};
                    return A.each(t.match(P) || [], (function(t, n) {
                        e[n] = !0
                    })), e
                }(t) : A.extend({}, t);
                var e,
                    n,
                    i,
                    o,
                    r = [],
                    s = [],
                    a = -1,
                    l = function() {
                        for (o = o || t.once, i = e = !0; s.length; a = -1)
                            for (n = s.shift(); ++a < r.length;)
                                !1 === r[a].apply(n[0], n[1]) && t.stopOnFalse && (a = r.length, n = !1);
                        t.memory || (n = !1),
                        e = !1,
                        o && (r = n ? [] : "")
                    },
                    c = {
                        add: function() {
                            return r && (n && !e && (a = r.length - 1, s.push(n)), function e(n) {
                                A.each(n, (function(n, i) {
                                    v(i) ? t.unique && c.has(i) || r.push(i) : i && i.length && "string" !== w(i) && e(i)
                                }))
                            }(arguments), n && !e && l()), this
                        },
                        remove: function() {
                            return A.each(arguments, (function(t, e) {
                                for (var n; (n = A.inArray(e, r, n)) > -1;)
                                    r.splice(n, 1),
                                    n <= a && a--
                            })), this
                        },
                        has: function(t) {
                            return t ? A.inArray(t, r) > -1 : r.length > 0
                        },
                        empty: function() {
                            return r && (r = []), this
                        },
                        disable: function() {
                            return o = s = [], r = n = "", this
                        },
                        disabled: function() {
                            return !r
                        },
                        lock: function() {
                            return o = s = [], n || e || (r = n = ""), this
                        },
                        locked: function() {
                            return !!o
                        },
                        fireWith: function(t, n) {
                            return o || (n = [t, (n = n || []).slice ? n.slice() : n], s.push(n), e || l()), this
                        },
                        fire: function() {
                            return c.fireWith(this, arguments), this
                        },
                        fired: function() {
                            return !!i
                        }
                    };
                return c
            },
            A.extend({
                Deferred: function(t) {
                    var e = [["notify", "progress", A.Callbacks("memory"), A.Callbacks("memory"), 2], ["resolve", "done", A.Callbacks("once memory"), A.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", A.Callbacks("once memory"), A.Callbacks("once memory"), 1, "rejected"]],
                        i = "pending",
                        o = {
                            state: function() {
                                return i
                            },
                            always: function() {
                                return r.done(arguments).fail(arguments), this
                            },
                            catch: function(t) {
                                return o.then(null, t)
                            },
                            pipe: function() {
                                var t = arguments;
                                return A.Deferred((function(n) {
                                    A.each(e, (function(e, i) {
                                        var o = v(t[i[4]]) && t[i[4]];
                                        r[i[1]]((function() {
                                            var t = o && o.apply(this, arguments);
                                            t && v(t.promise) ? t.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[i[0] + "With"](this, o ? [t] : arguments)
                                        }))
                                    })),
                                    t = null
                                })).promise()
                            },
                            then: function(t, i, o) {
                                var r = 0;
                                function s(t, e, i, o) {
                                    return function() {
                                        var a = this,
                                            l = arguments,
                                            c = function() {
                                                var n,
                                                    c;
                                                if (!(t < r)) {
                                                    if ((n = i.apply(a, l)) === e.promise())
                                                        throw new TypeError("Thenable self-resolution");
                                                    c = n && ("object" == typeof n || "function" == typeof n) && n.then,
                                                    v(c) ? o ? c.call(n, s(r, e, $, o), s(r, e, B, o)) : (r++, c.call(n, s(r, e, $, o), s(r, e, B, o), s(r, e, $, e.notifyWith))) : (i !== $ && (a = void 0, l = [n]), (o || e.resolveWith)(a, l))
                                                }
                                            },
                                            u = o ? c : function() {
                                                try {
                                                    c()
                                                } catch (n) {
                                                    A.Deferred.exceptionHook && A.Deferred.exceptionHook(n, u.stackTrace),
                                                    t + 1 >= r && (i !== B && (a = void 0, l = [n]), e.rejectWith(a, l))
                                                }
                                            };
                                        t ? u() : (A.Deferred.getStackHook && (u.stackTrace = A.Deferred.getStackHook()), n.setTimeout(u))
                                    }
                                }
                                return A.Deferred((function(n) {
                                    e[0][3].add(s(0, n, v(o) ? o : $, n.notifyWith)),
                                    e[1][3].add(s(0, n, v(t) ? t : $)),
                                    e[2][3].add(s(0, n, v(i) ? i : B))
                                })).promise()
                            },
                            promise: function(t) {
                                return null != t ? A.extend(t, o) : o
                            }
                        },
                        r = {};
                    return A.each(e, (function(t, n) {
                        var s = n[2],
                            a = n[5];
                        o[n[1]] = s.add,
                        a && s.add((function() {
                            i = a
                        }), e[3 - t][2].disable, e[3 - t][3].disable, e[0][2].lock, e[0][3].lock),
                        s.add(n[3].fire),
                        r[n[0]] = function() {
                            return r[n[0] + "With"](this === r ? void 0 : this, arguments), this
                        },
                        r[n[0] + "With"] = s.fireWith
                    })), o.promise(r), t && t.call(r, r), r
                },
                when: function(t) {
                    var e = arguments.length,
                        n = e,
                        i = Array(n),
                        o = a.call(arguments),
                        r = A.Deferred(),
                        s = function(t) {
                            return function(n) {
                                i[t] = this,
                                o[t] = arguments.length > 1 ? a.call(arguments) : n,
                                --e || r.resolveWith(i, o)
                            }
                        };
                    if (e <= 1 && (j(t, r.done(s(n)).resolve, r.reject, !e), "pending" === r.state() || v(o[n] && o[n].then)))
                        return r.then();
                    for (; n--;)
                        j(o[n], s(n), r.reject);
                    return r.promise()
                }
            });
            var V = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
            A.Deferred.exceptionHook = function(t, e) {
                n.console && n.console.warn && t && V.test(t.name) && n.console.warn("jQuery.Deferred exception: " + t.message, t.stack, e)
            },
            A.readyException = function(t) {
                n.setTimeout((function() {
                    throw t
                }))
            };
            var F = A.Deferred();
            function H() {
                y.removeEventListener("DOMContentLoaded", H),
                n.removeEventListener("load", H),
                A.ready()
            }
            A.fn.ready = function(t) {
                return F.then(t).catch((function(t) {
                    A.readyException(t)
                })), this
            },
            A.extend({
                isReady: !1,
                readyWait: 1,
                ready: function(t) {
                    (!0 === t ? --A.readyWait : A.isReady) || (A.isReady = !0, !0 !== t && --A.readyWait > 0 || F.resolveWith(y, [A]))
                }
            }),
            A.ready.then = F.then,
            "complete" === y.readyState || "loading" !== y.readyState && !y.documentElement.doScroll ? n.setTimeout(A.ready) : (y.addEventListener("DOMContentLoaded", H), n.addEventListener("load", H));
            var z = function(t, e, n, i, o, r, s) {
                    var a = 0,
                        l = t.length,
                        c = null == n;
                    if ("object" === w(n))
                        for (a in o = !0, n)
                            z(t, e, a, n[a], !0, r, s);
                    else if (void 0 !== i && (o = !0, v(i) || (s = !0), c && (s ? (e.call(t, i), e = null) : (c = e, e = function(t, e, n) {
                        return c.call(A(t), n)
                    })), e))
                        for (; a < l; a++)
                            e(t[a], n, s ? i : i.call(t[a], a, e(t[a], n)));
                    return o ? t : c ? e.call(t) : l ? e(t[0], n) : r
                },
                q = /^-ms-/,
                W = /-([a-z])/g;
            function G(t, e) {
                return e.toUpperCase()
            }
            function X(t) {
                return t.replace(q, "ms-").replace(W, G)
            }
            var Y = function(t) {
                return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType
            };
            function K() {
                this.expando = A.expando + K.uid++
            }
            K.uid = 1,
            K.prototype = {
                cache: function(t) {
                    var e = t[this.expando];
                    return e || (e = Object.create(null), Y(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
                        value: e,
                        configurable: !0
                    }))), e
                },
                set: function(t, e, n) {
                    var i,
                        o = this.cache(t);
                    if ("string" == typeof e)
                        o[X(e)] = n;
                    else
                        for (i in e)
                            o[X(i)] = e[i];
                    return o
                },
                get: function(t, e) {
                    return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][X(e)]
                },
                access: function(t, e, n) {
                    return void 0 === e || e && "string" == typeof e && void 0 === n ? this.get(t, e) : (this.set(t, e, n), void 0 !== n ? n : e)
                },
                remove: function(t, e) {
                    var n,
                        i = t[this.expando];
                    if (void 0 !== i) {
                        if (void 0 !== e) {
                            n = (e = Array.isArray(e) ? e.map(X) : (e = X(e)) in i ? [e] : e.match(P) || []).length;
                            for (; n--;)
                                delete i[e[n]]
                        }
                        (void 0 === e || A.isEmptyObject(i)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando])
                    }
                },
                hasData: function(t) {
                    var e = t[this.expando];
                    return void 0 !== e && !A.isEmptyObject(e)
                }
            };
            var Q = new K,
                J = new K,
                Z = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                tt = /[A-Z]/g;
            function et(t, e, n) {
                var i;
                if (void 0 === n && 1 === t.nodeType)
                    if (i = "data-" + e.replace(tt, "-$&").toLowerCase(), "string" == typeof (n = t.getAttribute(i))) {
                        try {
                            n = function(t) {
                                return "true" === t || "false" !== t && ("null" === t ? null : t === +t + "" ? +t : Z.test(t) ? JSON.parse(t) : t)
                            }(n)
                        } catch (t) {}
                        J.set(t, e, n)
                    } else
                        n = void 0;
                return n
            }
            A.extend({
                hasData: function(t) {
                    return J.hasData(t) || Q.hasData(t)
                },
                data: function(t, e, n) {
                    return J.access(t, e, n)
                },
                removeData: function(t, e) {
                    J.remove(t, e)
                },
                _data: function(t, e, n) {
                    return Q.access(t, e, n)
                },
                _removeData: function(t, e) {
                    Q.remove(t, e)
                }
            }),
            A.fn.extend({
                data: function(t, e) {
                    var n,
                        i,
                        o,
                        r = this[0],
                        s = r && r.attributes;
                    if (void 0 === t) {
                        if (this.length && (o = J.get(r), 1 === r.nodeType && !Q.get(r, "hasDataAttrs"))) {
                            for (n = s.length; n--;)
                                s[n] && 0 === (i = s[n].name).indexOf("data-") && (i = X(i.slice(5)), et(r, i, o[i]));
                            Q.set(r, "hasDataAttrs", !0)
                        }
                        return o
                    }
                    return "object" == typeof t ? this.each((function() {
                        J.set(this, t)
                    })) : z(this, (function(e) {
                        var n;
                        if (r && void 0 === e)
                            return void 0 !== (n = J.get(r, t)) || void 0 !== (n = et(r, t)) ? n : void 0;
                        this.each((function() {
                            J.set(this, t, e)
                        }))
                    }), null, e, arguments.length > 1, null, !0)
                },
                removeData: function(t) {
                    return this.each((function() {
                        J.remove(this, t)
                    }))
                }
            }),
            A.extend({
                queue: function(t, e, n) {
                    var i;
                    if (t)
                        return e = (e || "fx") + "queue", i = Q.get(t, e), n && (!i || Array.isArray(n) ? i = Q.access(t, e, A.makeArray(n)) : i.push(n)), i || []
                },
                dequeue: function(t, e) {
                    e = e || "fx";
                    var n = A.queue(t, e),
                        i = n.length,
                        o = n.shift(),
                        r = A._queueHooks(t, e);
                    "inprogress" === o && (o = n.shift(), i--),
                    o && ("fx" === e && n.unshift("inprogress"), delete r.stop, o.call(t, (function() {
                        A.dequeue(t, e)
                    }), r)),
                    !i && r && r.empty.fire()
                },
                _queueHooks: function(t, e) {
                    var n = e + "queueHooks";
                    return Q.get(t, n) || Q.access(t, n, {
                            empty: A.Callbacks("once memory").add((function() {
                                Q.remove(t, [e + "queue", n])
                            }))
                        })
                }
            }),
            A.fn.extend({
                queue: function(t, e) {
                    var n = 2;
                    return "string" != typeof t && (e = t, t = "fx", n--), arguments.length < n ? A.queue(this[0], t) : void 0 === e ? this : this.each((function() {
                        var n = A.queue(this, t, e);
                        A._queueHooks(this, t),
                        "fx" === t && "inprogress" !== n[0] && A.dequeue(this, t)
                    }))
                },
                dequeue: function(t) {
                    return this.each((function() {
                        A.dequeue(this, t)
                    }))
                },
                clearQueue: function(t) {
                    return this.queue(t || "fx", [])
                },
                promise: function(t, e) {
                    var n,
                        i = 1,
                        o = A.Deferred(),
                        r = this,
                        s = this.length,
                        a = function() {
                            --i || o.resolveWith(r, [r])
                        };
                    for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; s--;)
                        (n = Q.get(r[s], t + "queueHooks")) && n.empty && (i++, n.empty.add(a));
                    return a(), o.promise(e)
                }
            });
            var nt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
                it = new RegExp("^(?:([+-])=|)(" + nt + ")([a-z%]*)$", "i"),
                ot = ["Top", "Right", "Bottom", "Left"],
                rt = y.documentElement,
                st = function(t) {
                    return A.contains(t.ownerDocument, t)
                },
                at = {
                    composed: !0
                };
            rt.getRootNode && (st = function(t) {
                return A.contains(t.ownerDocument, t) || t.getRootNode(at) === t.ownerDocument
            });
            var lt = function(t, e) {
                return "none" === (t = e || t).style.display || "" === t.style.display && st(t) && "none" === A.css(t, "display")
            };
            function ct(t, e, n, i) {
                var o,
                    r,
                    s = 20,
                    a = i ? function() {
                        return i.cur()
                    } : function() {
                        return A.css(t, e, "")
                    },
                    l = a(),
                    c = n && n[3] || (A.cssNumber[e] ? "" : "px"),
                    u = t.nodeType && (A.cssNumber[e] || "px" !== c && +l) && it.exec(A.css(t, e));
                if (u && u[3] !== c) {
                    for (l /= 2, c = c || u[3], u = +l || 1; s--;)
                        A.style(t, e, u + c),
                        (1 - r) * (1 - (r = a() / l || .5)) <= 0 && (s = 0),
                        u /= r;
                    u *= 2,
                    A.style(t, e, u + c),
                    n = n || []
                }
                return n && (u = +u || +l || 0, o = n[1] ? u + (n[1] + 1) * n[2] : +n[2], i && (i.unit = c, i.start = u, i.end = o)), o
            }
            var ut = {};
            function dt(t) {
                var e,
                    n = t.ownerDocument,
                    i = t.nodeName,
                    o = ut[i];
                return o || (e = n.body.appendChild(n.createElement(i)), o = A.css(e, "display"), e.parentNode.removeChild(e), "none" === o && (o = "block"), ut[i] = o, o)
            }
            function ht(t, e) {
                for (var n, i, o = [], r = 0, s = t.length; r < s; r++)
                    (i = t[r]).style && (n = i.style.display, e ? ("none" === n && (o[r] = Q.get(i, "display") || null, o[r] || (i.style.display = "")), "" === i.style.display && lt(i) && (o[r] = dt(i))) : "none" !== n && (o[r] = "none", Q.set(i, "display", n)));
                for (r = 0; r < s; r++)
                    null != o[r] && (t[r].style.display = o[r]);
                return t
            }
            A.fn.extend({
                show: function() {
                    return ht(this, !0)
                },
                hide: function() {
                    return ht(this)
                },
                toggle: function(t) {
                    return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each((function() {
                        lt(this) ? A(this).show() : A(this).hide()
                    }))
                }
            });
            var gt,
                mt,
                ft = /^(?:checkbox|radio)$/i,
                pt = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
                vt = /^$|^module$|\/(?:java|ecma)script/i;
            gt = y.createDocumentFragment().appendChild(y.createElement("div")),
            (mt = y.createElement("input")).setAttribute("type", "radio"),
            mt.setAttribute("checked", "checked"),
            mt.setAttribute("name", "t"),
            gt.appendChild(mt),
            p.checkClone = gt.cloneNode(!0).cloneNode(!0).lastChild.checked,
            gt.innerHTML = "<textarea>x</textarea>",
            p.noCloneChecked = !!gt.cloneNode(!0).lastChild.defaultValue,
            gt.innerHTML = "<option></option>",
            p.option = !!gt.lastChild;
            var _t = {
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: [0, "", ""]
            };
            function yt(t, e) {
                var n;
                return n = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || "*") : void 0 !== t.querySelectorAll ? t.querySelectorAll(e || "*") : [], void 0 === e || e && O(t, e) ? A.merge([t], n) : n
            }
            function bt(t, e) {
                for (var n = 0, i = t.length; n < i; n++)
                    Q.set(t[n], "globalEval", !e || Q.get(e[n], "globalEval"))
            }
            _t.tbody = _t.tfoot = _t.colgroup = _t.caption = _t.thead,
            _t.th = _t.td,
            p.option || (_t.optgroup = _t.option = [1, "<select multiple='multiple'>", "</select>"]);
            var Et = /<|&#?\w+;/;
            function wt(t, e, n, i, o) {
                for (var r, s, a, l, c, u, d = e.createDocumentFragment(), h = [], g = 0, m = t.length; g < m; g++)
                    if ((r = t[g]) || 0 === r)
                        if ("object" === w(r))
                            A.merge(h, r.nodeType ? [r] : r);
                        else if (Et.test(r)) {
                            for (s = s || d.appendChild(e.createElement("div")), a = (pt.exec(r) || ["", ""])[1].toLowerCase(), l = _t[a] || _t._default, s.innerHTML = l[1] + A.htmlPrefilter(r) + l[2], u = l[0]; u--;)
                                s = s.lastChild;
                            A.merge(h, s.childNodes),
                            (s = d.firstChild).textContent = ""
                        } else
                            h.push(e.createTextNode(r));
                for (d.textContent = "", g = 0; r = h[g++];)
                    if (i && A.inArray(r, i) > -1)
                        o && o.push(r);
                    else if (c = st(r), s = yt(d.appendChild(r), "script"), c && bt(s), n)
                        for (u = 0; r = s[u++];)
                            vt.test(r.type || "") && n.push(r);
                return d
            }
            var At = /^key/,
                Ct = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                Tt = /^([^.]*)(?:\.(.+)|)/;
            function Nt() {
                return !0
            }
            function St() {
                return !1
            }
            function xt(t, e) {
                return t === function() {
                    try {
                        return y.activeElement
                    } catch (t) {}
                }() == ("focus" === e)
            }
            function Ot(t, e, n, i, o, r) {
                var s,
                    a;
                if ("object" == typeof e) {
                    for (a in "string" != typeof n && (i = i || n, n = void 0), e)
                        Ot(t, a, n, i, e[a], r);
                    return t
                }
                if (null == i && null == o ? (o = n, i = n = void 0) : null == o && ("string" == typeof n ? (o = i, i = void 0) : (o = i, i = n, n = void 0)), !1 === o)
                    o = St;
                else if (!o)
                    return t;
                return 1 === r && (s = o, (o = function(t) {
                    return A().off(t), s.apply(this, arguments)
                }).guid = s.guid || (s.guid = A.guid++)), t.each((function() {
                    A.event.add(this, e, o, i, n)
                }))
            }
            function It(t, e, n) {
                n ? (Q.set(t, e, !1), A.event.add(t, e, {
                    namespace: !1,
                    handler: function(t) {
                        var i,
                            o,
                            r = Q.get(this, e);
                        if (1 & t.isTrigger && this[e]) {
                            if (r.length)
                                (A.event.special[e] || {}).delegateType && t.stopPropagation();
                            else if (r = a.call(arguments), Q.set(this, e, r), i = n(this, e), this[e](), r !== (o = Q.get(this, e)) || i ? Q.set(this, e, !1) : o = {}, r !== o)
                                return t.stopImmediatePropagation(), t.preventDefault(), o.value
                        } else
                            r.length && (Q.set(this, e, {
                                value: A.event.trigger(A.extend(r[0], A.Event.prototype), r.slice(1), this)
                            }), t.stopImmediatePropagation())
                    }
                })) : void 0 === Q.get(t, e) && A.event.add(t, e, Nt)
            }
            A.event = {
                global: {},
                add: function(t, e, n, i, o) {
                    var r,
                        s,
                        a,
                        l,
                        c,
                        u,
                        d,
                        h,
                        g,
                        m,
                        f,
                        p = Q.get(t);
                    if (Y(t))
                        for (n.handler && (n = (r = n).handler, o = r.selector), o && A.find.matchesSelector(rt, o), n.guid || (n.guid = A.guid++), (l = p.events) || (l = p.events = Object.create(null)), (s = p.handle) || (s = p.handle = function(e) {
                            return void 0 !== A && A.event.triggered !== e.type ? A.event.dispatch.apply(t, arguments) : void 0
                        }), c = (e = (e || "").match(P) || [""]).length; c--;)
                            g = f = (a = Tt.exec(e[c]) || [])[1],
                            m = (a[2] || "").split(".").sort(),
                            g && (d = A.event.special[g] || {}, g = (o ? d.delegateType : d.bindType) || g, d = A.event.special[g] || {}, u = A.extend({
                                type: g,
                                origType: f,
                                data: i,
                                handler: n,
                                guid: n.guid,
                                selector: o,
                                needsContext: o && A.expr.match.needsContext.test(o),
                                namespace: m.join(".")
                            }, r), (h = l[g]) || ((h = l[g] = []).delegateCount = 0, d.setup && !1 !== d.setup.call(t, i, m, s) || t.addEventListener && t.addEventListener(g, s)), d.add && (d.add.call(t, u), u.handler.guid || (u.handler.guid = n.guid)), o ? h.splice(h.delegateCount++, 0, u) : h.push(u), A.event.global[g] = !0)
                },
                remove: function(t, e, n, i, o) {
                    var r,
                        s,
                        a,
                        l,
                        c,
                        u,
                        d,
                        h,
                        g,
                        m,
                        f,
                        p = Q.hasData(t) && Q.get(t);
                    if (p && (l = p.events)) {
                        for (c = (e = (e || "").match(P) || [""]).length; c--;)
                            if (g = f = (a = Tt.exec(e[c]) || [])[1], m = (a[2] || "").split(".").sort(), g) {
                                for (d = A.event.special[g] || {}, h = l[g = (i ? d.delegateType : d.bindType) || g] || [], a = a[2] && new RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)"), s = r = h.length; r--;)
                                    u = h[r],
                                    !o && f !== u.origType || n && n.guid !== u.guid || a && !a.test(u.namespace) || i && i !== u.selector && ("**" !== i || !u.selector) || (h.splice(r, 1), u.selector && h.delegateCount--, d.remove && d.remove.call(t, u));
                                s && !h.length && (d.teardown && !1 !== d.teardown.call(t, m, p.handle) || A.removeEvent(t, g, p.handle), delete l[g])
                            } else
                                for (g in l)
                                    A.event.remove(t, g + e[c], n, i, !0);
                        A.isEmptyObject(l) && Q.remove(t, "handle events")
                    }
                },
                dispatch: function(t) {
                    var e,
                        n,
                        i,
                        o,
                        r,
                        s,
                        a = new Array(arguments.length),
                        l = A.event.fix(t),
                        c = (Q.get(this, "events") || Object.create(null))[l.type] || [],
                        u = A.event.special[l.type] || {};
                    for (a[0] = l, e = 1; e < arguments.length; e++)
                        a[e] = arguments[e];
                    if (l.delegateTarget = this, !u.preDispatch || !1 !== u.preDispatch.call(this, l)) {
                        for (s = A.event.handlers.call(this, l, c), e = 0; (o = s[e++]) && !l.isPropagationStopped();)
                            for (l.currentTarget = o.elem, n = 0; (r = o.handlers[n++]) && !l.isImmediatePropagationStopped();)
                                l.rnamespace && !1 !== r.namespace && !l.rnamespace.test(r.namespace) || (l.handleObj = r, l.data = r.data, void 0 !== (i = ((A.event.special[r.origType] || {}).handle || r.handler).apply(o.elem, a)) && !1 === (l.result = i) && (l.preventDefault(), l.stopPropagation()));
                        return u.postDispatch && u.postDispatch.call(this, l), l.result
                    }
                },
                handlers: function(t, e) {
                    var n,
                        i,
                        o,
                        r,
                        s,
                        a = [],
                        l = e.delegateCount,
                        c = t.target;
                    if (l && c.nodeType && !("click" === t.type && t.button >= 1))
                        for (; c !== this; c = c.parentNode || this)
                            if (1 === c.nodeType && ("click" !== t.type || !0 !== c.disabled)) {
                                for (r = [], s = {}, n = 0; n < l; n++)
                                    void 0 === s[o = (i = e[n]).selector + " "] && (s[o] = i.needsContext ? A(o, this).index(c) > -1 : A.find(o, this, null, [c]).length),
                                    s[o] && r.push(i);
                                r.length && a.push({
                                    elem: c,
                                    handlers: r
                                })
                            }
                    return c = this, l < e.length && a.push({
                        elem: c,
                        handlers: e.slice(l)
                    }), a
                },
                addProp: function(t, e) {
                    Object.defineProperty(A.Event.prototype, t, {
                        enumerable: !0,
                        configurable: !0,
                        get: v(e) ? function() {
                            if (this.originalEvent)
                                return e(this.originalEvent)
                        } : function() {
                            if (this.originalEvent)
                                return this.originalEvent[t]
                        },
                        set: function(e) {
                            Object.defineProperty(this, t, {
                                enumerable: !0,
                                configurable: !0,
                                writable: !0,
                                value: e
                            })
                        }
                    })
                },
                fix: function(t) {
                    return t[A.expando] ? t : new A.Event(t)
                },
                special: {
                    load: {
                        noBubble: !0
                    },
                    click: {
                        setup: function(t) {
                            var e = this || t;
                            return ft.test(e.type) && e.click && O(e, "input") && It(e, "click", Nt), !1
                        },
                        trigger: function(t) {
                            var e = this || t;
                            return ft.test(e.type) && e.click && O(e, "input") && It(e, "click"), !0
                        },
                        _default: function(t) {
                            var e = t.target;
                            return ft.test(e.type) && e.click && O(e, "input") && Q.get(e, "click") || O(e, "a")
                        }
                    },
                    beforeunload: {
                        postDispatch: function(t) {
                            void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
                        }
                    }
                }
            },
            A.removeEvent = function(t, e, n) {
                t.removeEventListener && t.removeEventListener(e, n)
            },
            A.Event = function(t, e) {
                if (!(this instanceof A.Event))
                    return new A.Event(t, e);
                t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && !1 === t.returnValue ? Nt : St, this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t,
                e && A.extend(this, e),
                this.timeStamp = t && t.timeStamp || Date.now(),
                this[A.expando] = !0
            },
            A.Event.prototype = {
                constructor: A.Event,
                isDefaultPrevented: St,
                isPropagationStopped: St,
                isImmediatePropagationStopped: St,
                isSimulated: !1,
                preventDefault: function() {
                    var t = this.originalEvent;
                    this.isDefaultPrevented = Nt,
                    t && !this.isSimulated && t.preventDefault()
                },
                stopPropagation: function() {
                    var t = this.originalEvent;
                    this.isPropagationStopped = Nt,
                    t && !this.isSimulated && t.stopPropagation()
                },
                stopImmediatePropagation: function() {
                    var t = this.originalEvent;
                    this.isImmediatePropagationStopped = Nt,
                    t && !this.isSimulated && t.stopImmediatePropagation(),
                    this.stopPropagation()
                }
            },
            A.each({
                altKey: !0,
                bubbles: !0,
                cancelable: !0,
                changedTouches: !0,
                ctrlKey: !0,
                detail: !0,
                eventPhase: !0,
                metaKey: !0,
                pageX: !0,
                pageY: !0,
                shiftKey: !0,
                view: !0,
                char: !0,
                code: !0,
                charCode: !0,
                key: !0,
                keyCode: !0,
                button: !0,
                buttons: !0,
                clientX: !0,
                clientY: !0,
                offsetX: !0,
                offsetY: !0,
                pointerId: !0,
                pointerType: !0,
                screenX: !0,
                screenY: !0,
                targetTouches: !0,
                toElement: !0,
                touches: !0,
                which: function(t) {
                    var e = t.button;
                    return null == t.which && At.test(t.type) ? null != t.charCode ? t.charCode : t.keyCode : !t.which && void 0 !== e && Ct.test(t.type) ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : t.which
                }
            }, A.event.addProp),
            A.each({
                focus: "focusin",
                blur: "focusout"
            }, (function(t, e) {
                A.event.special[t] = {
                    setup: function() {
                        return It(this, t, xt), !1
                    },
                    trigger: function() {
                        return It(this, t), !0
                    },
                    delegateType: e
                }
            })),
            A.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, (function(t, e) {
                A.event.special[t] = {
                    delegateType: e,
                    bindType: e,
                    handle: function(t) {
                        var n,
                            i = this,
                            o = t.relatedTarget,
                            r = t.handleObj;
                        return o && (o === i || A.contains(i, o)) || (t.type = r.origType, n = r.handler.apply(this, arguments), t.type = e), n
                    }
                }
            })),
            A.fn.extend({
                on: function(t, e, n, i) {
                    return Ot(this, t, e, n, i)
                },
                one: function(t, e, n, i) {
                    return Ot(this, t, e, n, i, 1)
                },
                off: function(t, e, n) {
                    var i,
                        o;
                    if (t && t.preventDefault && t.handleObj)
                        return i = t.handleObj, A(t.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;
                    if ("object" == typeof t) {
                        for (o in t)
                            this.off(o, e, t[o]);
                        return this
                    }
                    return !1 !== e && "function" != typeof e || (n = e, e = void 0), !1 === n && (n = St), this.each((function() {
                        A.event.remove(this, t, n, e)
                    }))
                }
            });
            var Dt = /<script|<style|<link/i,
                Mt = /checked\s*(?:[^=]|=\s*.checked.)/i,
                Lt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
            function kt(t, e) {
                return O(t, "table") && O(11 !== e.nodeType ? e : e.firstChild, "tr") && A(t).children("tbody")[0] || t
            }
            function Rt(t) {
                return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t
            }
            function Ut(t) {
                return "true/" === (t.type || "").slice(0, 5) ? t.type = t.type.slice(5) : t.removeAttribute("type"), t
            }
            function Pt(t, e) {
                var n,
                    i,
                    o,
                    r,
                    s,
                    a;
                if (1 === e.nodeType) {
                    if (Q.hasData(t) && (a = Q.get(t).events))
                        for (o in Q.remove(e, "handle events"), a)
                            for (n = 0, i = a[o].length; n < i; n++)
                                A.event.add(e, o, a[o][n]);
                    J.hasData(t) && (r = J.access(t), s = A.extend({}, r), J.set(e, s))
                }
            }
            function $t(t, e) {
                var n = e.nodeName.toLowerCase();
                "input" === n && ft.test(t.type) ? e.checked = t.checked : "input" !== n && "textarea" !== n || (e.defaultValue = t.defaultValue)
            }
            function Bt(t, e, n, i) {
                e = l(e);
                var o,
                    r,
                    s,
                    a,
                    c,
                    u,
                    d = 0,
                    h = t.length,
                    g = h - 1,
                    m = e[0],
                    f = v(m);
                if (f || h > 1 && "string" == typeof m && !p.checkClone && Mt.test(m))
                    return t.each((function(o) {
                        var r = t.eq(o);
                        f && (e[0] = m.call(this, o, r.html())),
                        Bt(r, e, n, i)
                    }));
                if (h && (r = (o = wt(e, t[0].ownerDocument, !1, t, i)).firstChild, 1 === o.childNodes.length && (o = r), r || i)) {
                    for (a = (s = A.map(yt(o, "script"), Rt)).length; d < h; d++)
                        c = o,
                        d !== g && (c = A.clone(c, !0, !0), a && A.merge(s, yt(c, "script"))),
                        n.call(t[d], c, d);
                    if (a)
                        for (u = s[s.length - 1].ownerDocument, A.map(s, Ut), d = 0; d < a; d++)
                            c = s[d],
                            vt.test(c.type || "") && !Q.access(c, "globalEval") && A.contains(u, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? A._evalUrl && !c.noModule && A._evalUrl(c.src, {
                                nonce: c.nonce || c.getAttribute("nonce")
                            }, u) : E(c.textContent.replace(Lt, ""), c, u))
                }
                return t
            }
            function jt(t, e, n) {
                for (var i, o = e ? A.filter(e, t) : t, r = 0; null != (i = o[r]); r++)
                    n || 1 !== i.nodeType || A.cleanData(yt(i)),
                    i.parentNode && (n && st(i) && bt(yt(i, "script")), i.parentNode.removeChild(i));
                return t
            }
            A.extend({
                htmlPrefilter: function(t) {
                    return t
                },
                clone: function(t, e, n) {
                    var i,
                        o,
                        r,
                        s,
                        a = t.cloneNode(!0),
                        l = st(t);
                    if (!(p.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || A.isXMLDoc(t)))
                        for (s = yt(a), i = 0, o = (r = yt(t)).length; i < o; i++)
                            $t(r[i], s[i]);
                    if (e)
                        if (n)
                            for (r = r || yt(t), s = s || yt(a), i = 0, o = r.length; i < o; i++)
                                Pt(r[i], s[i]);
                        else
                            Pt(t, a);
                    return (s = yt(a, "script")).length > 0 && bt(s, !l && yt(t, "script")), a
                },
                cleanData: function(t) {
                    for (var e, n, i, o = A.event.special, r = 0; void 0 !== (n = t[r]); r++)
                        if (Y(n)) {
                            if (e = n[Q.expando]) {
                                if (e.events)
                                    for (i in e.events)
                                        o[i] ? A.event.remove(n, i) : A.removeEvent(n, i, e.handle);
                                n[Q.expando] = void 0
                            }
                            n[J.expando] && (n[J.expando] = void 0)
                        }
                }
            }),
            A.fn.extend({
                detach: function(t) {
                    return jt(this, t, !0)
                },
                remove: function(t) {
                    return jt(this, t)
                },
                text: function(t) {
                    return z(this, (function(t) {
                        return void 0 === t ? A.text(this) : this.empty().each((function() {
                            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t)
                        }))
                    }), null, t, arguments.length)
                },
                append: function() {
                    return Bt(this, arguments, (function(t) {
                        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || kt(this, t).appendChild(t)
                    }))
                },
                prepend: function() {
                    return Bt(this, arguments, (function(t) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var e = kt(this, t);
                            e.insertBefore(t, e.firstChild)
                        }
                    }))
                },
                before: function() {
                    return Bt(this, arguments, (function(t) {
                        this.parentNode && this.parentNode.insertBefore(t, this)
                    }))
                },
                after: function() {
                    return Bt(this, arguments, (function(t) {
                        this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
                    }))
                },
                empty: function() {
                    for (var t, e = 0; null != (t = this[e]); e++)
                        1 === t.nodeType && (A.cleanData(yt(t, !1)), t.textContent = "");
                    return this
                },
                clone: function(t, e) {
                    return t = null != t && t, e = null == e ? t : e, this.map((function() {
                        return A.clone(this, t, e)
                    }))
                },
                html: function(t) {
                    return z(this, (function(t) {
                        var e = this[0] || {},
                            n = 0,
                            i = this.length;
                        if (void 0 === t && 1 === e.nodeType)
                            return e.innerHTML;
                        if ("string" == typeof t && !Dt.test(t) && !_t[(pt.exec(t) || ["", ""])[1].toLowerCase()]) {
                            t = A.htmlPrefilter(t);
                            try {
                                for (; n < i; n++)
                                    1 === (e = this[n] || {}).nodeType && (A.cleanData(yt(e, !1)), e.innerHTML = t);
                                e = 0
                            } catch (t) {}
                        }
                        e && this.empty().append(t)
                    }), null, t, arguments.length)
                },
                replaceWith: function() {
                    var t = [];
                    return Bt(this, arguments, (function(e) {
                        var n = this.parentNode;
                        A.inArray(this, t) < 0 && (A.cleanData(yt(this)), n && n.replaceChild(e, this))
                    }), t)
                }
            }),
            A.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, (function(t, e) {
                A.fn[t] = function(t) {
                    for (var n, i = [], o = A(t), r = o.length - 1, s = 0; s <= r; s++)
                        n = s === r ? this : this.clone(!0),
                        A(o[s])[e](n),
                        c.apply(i, n.get());
                    return this.pushStack(i)
                }
            }));
            var Vt = new RegExp("^(" + nt + ")(?!px)[a-z%]+$", "i"),
                Ft = function(t) {
                    var e = t.ownerDocument.defaultView;
                    return e && e.opener || (e = n), e.getComputedStyle(t)
                },
                Ht = function(t, e, n) {
                    var i,
                        o,
                        r = {};
                    for (o in e)
                        r[o] = t.style[o],
                        t.style[o] = e[o];
                    for (o in i = n.call(t), e)
                        t.style[o] = r[o];
                    return i
                },
                zt = new RegExp(ot.join("|"), "i");
            function qt(t, e, n) {
                var i,
                    o,
                    r,
                    s,
                    a = t.style;
                return (n = n || Ft(t)) && ("" !== (s = n.getPropertyValue(e) || n[e]) || st(t) || (s = A.style(t, e)), !p.pixelBoxStyles() && Vt.test(s) && zt.test(e) && (i = a.width, o = a.minWidth, r = a.maxWidth, a.minWidth = a.maxWidth = a.width = s, s = n.width, a.width = i, a.minWidth = o, a.maxWidth = r)), void 0 !== s ? s + "" : s
            }
            function Wt(t, e) {
                return {
                    get: function() {
                        if (!t())
                            return (this.get = e).apply(this, arguments);
                        delete this.get
                    }
                }
            }
            !function() {
                function t() {
                    if (u) {
                        c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",
                        u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",
                        rt.appendChild(c).appendChild(u);
                        var t = n.getComputedStyle(u);
                        i = "1%" !== t.top,
                        l = 12 === e(t.marginLeft),
                        u.style.right = "60%",
                        s = 36 === e(t.right),
                        o = 36 === e(t.width),
                        u.style.position = "absolute",
                        r = 12 === e(u.offsetWidth / 3),
                        rt.removeChild(c),
                        u = null
                    }
                }
                function e(t) {
                    return Math.round(parseFloat(t))
                }
                var i,
                    o,
                    r,
                    s,
                    a,
                    l,
                    c = y.createElement("div"),
                    u = y.createElement("div");
                u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", p.clearCloneStyle = "content-box" === u.style.backgroundClip, A.extend(p, {
                    boxSizingReliable: function() {
                        return t(), o
                    },
                    pixelBoxStyles: function() {
                        return t(), s
                    },
                    pixelPosition: function() {
                        return t(), i
                    },
                    reliableMarginLeft: function() {
                        return t(), l
                    },
                    scrollboxSize: function() {
                        return t(), r
                    },
                    reliableTrDimensions: function() {
                        var t,
                            e,
                            i,
                            o;
                        return null == a && (t = y.createElement("table"), e = y.createElement("tr"), i = y.createElement("div"), t.style.cssText = "position:absolute;left:-11111px", e.style.height = "1px", i.style.height = "9px", rt.appendChild(t).appendChild(e).appendChild(i), o = n.getComputedStyle(e), a = parseInt(o.height) > 3, rt.removeChild(t)), a
                    }
                }))
            }();
            var Gt = ["Webkit", "Moz", "ms"],
                Xt = y.createElement("div").style,
                Yt = {};
            function Kt(t) {
                var e = A.cssProps[t] || Yt[t];
                return e || (t in Xt ? t : Yt[t] = function(t) {
                        for (var e = t[0].toUpperCase() + t.slice(1), n = Gt.length; n--;)
                            if ((t = Gt[n] + e) in Xt)
                                return t
                    }(t) || t)
            }
            var Qt = /^(none|table(?!-c[ea]).+)/,
                Jt = /^--/,
                Zt = {
                    position: "absolute",
                    visibility: "hidden",
                    display: "block"
                },
                te = {
                    letterSpacing: "0",
                    fontWeight: "400"
                };
            function ee(t, e, n) {
                var i = it.exec(e);
                return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : e
            }
            function ne(t, e, n, i, o, r) {
                var s = "width" === e ? 1 : 0,
                    a = 0,
                    l = 0;
                if (n === (i ? "border" : "content"))
                    return 0;
                for (; s < 4; s += 2)
                    "margin" === n && (l += A.css(t, n + ot[s], !0, o)),
                    i ? ("content" === n && (l -= A.css(t, "padding" + ot[s], !0, o)), "margin" !== n && (l -= A.css(t, "border" + ot[s] + "Width", !0, o))) : (l += A.css(t, "padding" + ot[s], !0, o), "padding" !== n ? l += A.css(t, "border" + ot[s] + "Width", !0, o) : a += A.css(t, "border" + ot[s] + "Width", !0, o));
                return !i && r >= 0 && (l += Math.max(0, Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - r - l - a - .5)) || 0), l
            }
            function ie(t, e, n) {
                var i = Ft(t),
                    o = (!p.boxSizingReliable() || n) && "border-box" === A.css(t, "boxSizing", !1, i),
                    r = o,
                    s = qt(t, e, i),
                    a = "offset" + e[0].toUpperCase() + e.slice(1);
                if (Vt.test(s)) {
                    if (!n)
                        return s;
                    s = "auto"
                }
                return (!p.boxSizingReliable() && o || !p.reliableTrDimensions() && O(t, "tr") || "auto" === s || !parseFloat(s) && "inline" === A.css(t, "display", !1, i)) && t.getClientRects().length && (o = "border-box" === A.css(t, "boxSizing", !1, i), (r = a in t) && (s = t[a])), (s = parseFloat(s) || 0) + ne(t, e, n || (o ? "border" : "content"), r, i, s) + "px"
            }
            A.extend({
                cssHooks: {
                    opacity: {
                        get: function(t, e) {
                            if (e) {
                                var n = qt(t, "opacity");
                                return "" === n ? "1" : n
                            }
                        }
                    }
                },
                cssNumber: {
                    animationIterationCount: !0,
                    columnCount: !0,
                    fillOpacity: !0,
                    flexGrow: !0,
                    flexShrink: !0,
                    fontWeight: !0,
                    gridArea: !0,
                    gridColumn: !0,
                    gridColumnEnd: !0,
                    gridColumnStart: !0,
                    gridRow: !0,
                    gridRowEnd: !0,
                    gridRowStart: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0
                },
                cssProps: {},
                style: function(t, e, n, i) {
                    if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
                        var o,
                            r,
                            s,
                            a = X(e),
                            l = Jt.test(e),
                            c = t.style;
                        if (l || (e = Kt(a)), s = A.cssHooks[e] || A.cssHooks[a], void 0 === n)
                            return s && "get" in s && void 0 !== (o = s.get(t, !1, i)) ? o : c[e];
                        "string" === (r = typeof n) && (o = it.exec(n)) && o[1] && (n = ct(t, e, o), r = "number"),
                        null != n && n == n && ("number" !== r || l || (n += o && o[3] || (A.cssNumber[a] ? "" : "px")), p.clearCloneStyle || "" !== n || 0 !== e.indexOf("background") || (c[e] = "inherit"), s && "set" in s && void 0 === (n = s.set(t, n, i)) || (l ? c.setProperty(e, n) : c[e] = n))
                    }
                },
                css: function(t, e, n, i) {
                    var o,
                        r,
                        s,
                        a = X(e);
                    return Jt.test(e) || (e = Kt(a)), (s = A.cssHooks[e] || A.cssHooks[a]) && "get" in s && (o = s.get(t, !0, n)), void 0 === o && (o = qt(t, e, i)), "normal" === o && e in te && (o = te[e]), "" === n || n ? (r = parseFloat(o), !0 === n || isFinite(r) ? r || 0 : o) : o
                }
            }),
            A.each(["height", "width"], (function(t, e) {
                A.cssHooks[e] = {
                    get: function(t, n, i) {
                        if (n)
                            return !Qt.test(A.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? ie(t, e, i) : Ht(t, Zt, (function() {
                                return ie(t, e, i)
                            }))
                    },
                    set: function(t, n, i) {
                        var o,
                            r = Ft(t),
                            s = !p.scrollboxSize() && "absolute" === r.position,
                            a = (s || i) && "border-box" === A.css(t, "boxSizing", !1, r),
                            l = i ? ne(t, e, i, a, r) : 0;
                        return a && s && (l -= Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - parseFloat(r[e]) - ne(t, e, "border", !1, r) - .5)), l && (o = it.exec(n)) && "px" !== (o[3] || "px") && (t.style[e] = n, n = A.css(t, e)), ee(0, n, l)
                    }
                }
            })),
            A.cssHooks.marginLeft = Wt(p.reliableMarginLeft, (function(t, e) {
                if (e)
                    return (parseFloat(qt(t, "marginLeft")) || t.getBoundingClientRect().left - Ht(t, {
                        marginLeft: 0
                    }, (function() {
                        return t.getBoundingClientRect().left
                    }))) + "px"
            })),
            A.each({
                margin: "",
                padding: "",
                border: "Width"
            }, (function(t, e) {
                A.cssHooks[t + e] = {
                    expand: function(n) {
                        for (var i = 0, o = {}, r = "string" == typeof n ? n.split(" ") : [n]; i < 4; i++)
                            o[t + ot[i] + e] = r[i] || r[i - 2] || r[0];
                        return o
                    }
                },
                "margin" !== t && (A.cssHooks[t + e].set = ee)
            })),
            A.fn.extend({
                css: function(t, e) {
                    return z(this, (function(t, e, n) {
                        var i,
                            o,
                            r = {},
                            s = 0;
                        if (Array.isArray(e)) {
                            for (i = Ft(t), o = e.length; s < o; s++)
                                r[e[s]] = A.css(t, e[s], !1, i);
                            return r
                        }
                        return void 0 !== n ? A.style(t, e, n) : A.css(t, e)
                    }), t, e, arguments.length > 1)
                }
            }),
            A.fn.delay = function(t, e) {
                return t = A.fx && A.fx.speeds[t] || t, e = e || "fx", this.queue(e, (function(e, i) {
                    var o = n.setTimeout(e, t);
                    i.stop = function() {
                        n.clearTimeout(o)
                    }
                }))
            },
            function() {
                var t = y.createElement("input"),
                    e = y.createElement("select").appendChild(y.createElement("option"));
                t.type = "checkbox",
                p.checkOn = "" !== t.value,
                p.optSelected = e.selected,
                (t = y.createElement("input")).value = "t",
                t.type = "radio",
                p.radioValue = "t" === t.value
            }();
            var oe,
                re = A.expr.attrHandle;
            A.fn.extend({
                attr: function(t, e) {
                    return z(this, A.attr, t, e, arguments.length > 1)
                },
                removeAttr: function(t) {
                    return this.each((function() {
                        A.removeAttr(this, t)
                    }))
                }
            }),
            A.extend({
                attr: function(t, e, n) {
                    var i,
                        o,
                        r = t.nodeType;
                    if (3 !== r && 8 !== r && 2 !== r)
                        return void 0 === t.getAttribute ? A.prop(t, e, n) : (1 === r && A.isXMLDoc(t) || (o = A.attrHooks[e.toLowerCase()] || (A.expr.match.bool.test(e) ? oe : void 0)), void 0 !== n ? null === n ? void A.removeAttr(t, e) : o && "set" in o && void 0 !== (i = o.set(t, n, e)) ? i : (t.setAttribute(e, n + ""), n) : o && "get" in o && null !== (i = o.get(t, e)) ? i : null == (i = A.find.attr(t, e)) ? void 0 : i)
                },
                attrHooks: {
                    type: {
                        set: function(t, e) {
                            if (!p.radioValue && "radio" === e && O(t, "input")) {
                                var n = t.value;
                                return t.setAttribute("type", e), n && (t.value = n), e
                            }
                        }
                    }
                },
                removeAttr: function(t, e) {
                    var n,
                        i = 0,
                        o = e && e.match(P);
                    if (o && 1 === t.nodeType)
                        for (; n = o[i++];)
                            t.removeAttribute(n)
                }
            }),
            oe = {
                set: function(t, e, n) {
                    return !1 === e ? A.removeAttr(t, n) : t.setAttribute(n, n), n
                }
            },
            A.each(A.expr.match.bool.source.match(/\w+/g), (function(t, e) {
                var n = re[e] || A.find.attr;
                re[e] = function(t, e, i) {
                    var o,
                        r,
                        s = e.toLowerCase();
                    return i || (r = re[s], re[s] = o, o = null != n(t, e, i) ? s : null, re[s] = r), o
                }
            }));
            var se = /^(?:input|select|textarea|button)$/i,
                ae = /^(?:a|area)$/i;
            function le(t) {
                return (t.match(P) || []).join(" ")
            }
            function ce(t) {
                return t.getAttribute && t.getAttribute("class") || ""
            }
            function ue(t) {
                return Array.isArray(t) ? t : "string" == typeof t && t.match(P) || []
            }
            A.fn.extend({
                prop: function(t, e) {
                    return z(this, A.prop, t, e, arguments.length > 1)
                },
                removeProp: function(t) {
                    return this.each((function() {
                        delete this[A.propFix[t] || t]
                    }))
                }
            }),
            A.extend({
                prop: function(t, e, n) {
                    var i,
                        o,
                        r = t.nodeType;
                    if (3 !== r && 8 !== r && 2 !== r)
                        return 1 === r && A.isXMLDoc(t) || (e = A.propFix[e] || e, o = A.propHooks[e]), void 0 !== n ? o && "set" in o && void 0 !== (i = o.set(t, n, e)) ? i : t[e] = n : o && "get" in o && null !== (i = o.get(t, e)) ? i : t[e]
                },
                propHooks: {
                    tabIndex: {
                        get: function(t) {
                            var e = A.find.attr(t, "tabindex");
                            return e ? parseInt(e, 10) : se.test(t.nodeName) || ae.test(t.nodeName) && t.href ? 0 : -1
                        }
                    }
                },
                propFix: {
                    for: "htmlFor",
                    class: "className"
                }
            }),
            p.optSelected || (A.propHooks.selected = {
                get: function(t) {
                    var e = t.parentNode;
                    return e && e.parentNode && e.parentNode.selectedIndex, null
                },
                set: function(t) {
                    var e = t.parentNode;
                    e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
                }
            }),
            A.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function() {
                A.propFix[this.toLowerCase()] = this
            })),
            A.fn.extend({
                addClass: function(t) {
                    var e,
                        n,
                        i,
                        o,
                        r,
                        s,
                        a,
                        l = 0;
                    if (v(t))
                        return this.each((function(e) {
                            A(this).addClass(t.call(this, e, ce(this)))
                        }));
                    if ((e = ue(t)).length)
                        for (; n = this[l++];)
                            if (o = ce(n), i = 1 === n.nodeType && " " + le(o) + " ") {
                                for (s = 0; r = e[s++];)
                                    i.indexOf(" " + r + " ") < 0 && (i += r + " ");
                                o !== (a = le(i)) && n.setAttribute("class", a)
                            }
                    return this
                },
                removeClass: function(t) {
                    var e,
                        n,
                        i,
                        o,
                        r,
                        s,
                        a,
                        l = 0;
                    if (v(t))
                        return this.each((function(e) {
                            A(this).removeClass(t.call(this, e, ce(this)))
                        }));
                    if (!arguments.length)
                        return this.attr("class", "");
                    if ((e = ue(t)).length)
                        for (; n = this[l++];)
                            if (o = ce(n), i = 1 === n.nodeType && " " + le(o) + " ") {
                                for (s = 0; r = e[s++];)
                                    for (; i.indexOf(" " + r + " ") > -1;)
                                        i = i.replace(" " + r + " ", " ");
                                o !== (a = le(i)) && n.setAttribute("class", a)
                            }
                    return this
                },
                toggleClass: function(t, e) {
                    var n = typeof t,
                        i = "string" === n || Array.isArray(t);
                    return "boolean" == typeof e && i ? e ? this.addClass(t) : this.removeClass(t) : v(t) ? this.each((function(n) {
                        A(this).toggleClass(t.call(this, n, ce(this), e), e)
                    })) : this.each((function() {
                        var e,
                            o,
                            r,
                            s;
                        if (i)
                            for (o = 0, r = A(this), s = ue(t); e = s[o++];)
                                r.hasClass(e) ? r.removeClass(e) : r.addClass(e);
                        else
                            void 0 !== t && "boolean" !== n || ((e = ce(this)) && Q.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === t ? "" : Q.get(this, "__className__") || ""))
                    }))
                },
                hasClass: function(t) {
                    var e,
                        n,
                        i = 0;
                    for (e = " " + t + " "; n = this[i++];)
                        if (1 === n.nodeType && (" " + le(ce(n)) + " ").indexOf(e) > -1)
                            return !0;
                    return !1
                }
            });
            var de = /\r/g;
            A.fn.extend({
                val: function(t) {
                    var e,
                        n,
                        i,
                        o = this[0];
                    return arguments.length ? (i = v(t), this.each((function(n) {
                        var o;
                        1 === this.nodeType && (null == (o = i ? t.call(this, n, A(this).val()) : t) ? o = "" : "number" == typeof o ? o += "" : Array.isArray(o) && (o = A.map(o, (function(t) {
                            return null == t ? "" : t + ""
                        }))), (e = A.valHooks[this.type] || A.valHooks[this.nodeName.toLowerCase()]) && "set" in e && void 0 !== e.set(this, o, "value") || (this.value = o))
                    }))) : o ? (e = A.valHooks[o.type] || A.valHooks[o.nodeName.toLowerCase()]) && "get" in e && void 0 !== (n = e.get(o, "value")) ? n : "string" == typeof (n = o.value) ? n.replace(de, "") : null == n ? "" : n : void 0
                }
            }),
            A.extend({
                valHooks: {
                    option: {
                        get: function(t) {
                            var e = A.find.attr(t, "value");
                            return null != e ? e : le(A.text(t))
                        }
                    },
                    select: {
                        get: function(t) {
                            var e,
                                n,
                                i,
                                o = t.options,
                                r = t.selectedIndex,
                                s = "select-one" === t.type,
                                a = s ? null : [],
                                l = s ? r + 1 : o.length;
                            for (i = r < 0 ? l : s ? r : 0; i < l; i++)
                                if (((n = o[i]).selected || i === r) && !n.disabled && (!n.parentNode.disabled || !O(n.parentNode, "optgroup"))) {
                                    if (e = A(n).val(), s)
                                        return e;
                                    a.push(e)
                                }
                            return a
                        },
                        set: function(t, e) {
                            for (var n, i, o = t.options, r = A.makeArray(e), s = o.length; s--;)
                                ((i = o[s]).selected = A.inArray(A.valHooks.option.get(i), r) > -1) && (n = !0);
                            return n || (t.selectedIndex = -1), r
                        }
                    }
                }
            }),
            A.each(["radio", "checkbox"], (function() {
                A.valHooks[this] = {
                    set: function(t, e) {
                        if (Array.isArray(e))
                            return t.checked = A.inArray(A(t).val(), e) > -1
                    }
                },
                p.checkOn || (A.valHooks[this].get = function(t) {
                    return null === t.getAttribute("value") ? "on" : t.value
                })
            })),
            p.focusin = "onfocusin" in n;
            var he = /^(?:focusinfocus|focusoutblur)$/,
                ge = function(t) {
                    t.stopPropagation()
                };
            A.extend(A.event, {
                trigger: function(t, e, i, o) {
                    var r,
                        s,
                        a,
                        l,
                        c,
                        u,
                        d,
                        h,
                        m = [i || y],
                        f = g.call(t, "type") ? t.type : t,
                        p = g.call(t, "namespace") ? t.namespace.split(".") : [];
                    if (s = h = a = i = i || y, 3 !== i.nodeType && 8 !== i.nodeType && !he.test(f + A.event.triggered) && (f.indexOf(".") > -1 && (p = f.split("."), f = p.shift(), p.sort()), c = f.indexOf(":") < 0 && "on" + f, (t = t[A.expando] ? t : new A.Event(f, "object" == typeof t && t)).isTrigger = o ? 2 : 3, t.namespace = p.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = i), e = null == e ? [t] : A.makeArray(e, [t]), d = A.event.special[f] || {}, o || !d.trigger || !1 !== d.trigger.apply(i, e))) {
                        if (!o && !d.noBubble && !_(i)) {
                            for (l = d.delegateType || f, he.test(l + f) || (s = s.parentNode); s; s = s.parentNode)
                                m.push(s),
                                a = s;
                            a === (i.ownerDocument || y) && m.push(a.defaultView || a.parentWindow || n)
                        }
                        for (r = 0; (s = m[r++]) && !t.isPropagationStopped();)
                            h = s,
                            t.type = r > 1 ? l : d.bindType || f,
                            (u = (Q.get(s, "events") || Object.create(null))[t.type] && Q.get(s, "handle")) && u.apply(s, e),
                            (u = c && s[c]) && u.apply && Y(s) && (t.result = u.apply(s, e), !1 === t.result && t.preventDefault());
                        return t.type = f, o || t.isDefaultPrevented() || d._default && !1 !== d._default.apply(m.pop(), e) || !Y(i) || c && v(i[f]) && !_(i) && ((a = i[c]) && (i[c] = null), A.event.triggered = f, t.isPropagationStopped() && h.addEventListener(f, ge), i[f](), t.isPropagationStopped() && h.removeEventListener(f, ge), A.event.triggered = void 0, a && (i[c] = a)), t.result
                    }
                },
                simulate: function(t, e, n) {
                    var i = A.extend(new A.Event, n, {
                        type: t,
                        isSimulated: !0
                    });
                    A.event.trigger(i, null, e)
                }
            }),
            A.fn.extend({
                trigger: function(t, e) {
                    return this.each((function() {
                        A.event.trigger(t, e, this)
                    }))
                },
                triggerHandler: function(t, e) {
                    var n = this[0];
                    if (n)
                        return A.event.trigger(t, e, n, !0)
                }
            }),
            p.focusin || A.each({
                focus: "focusin",
                blur: "focusout"
            }, (function(t, e) {
                var n = function(t) {
                    A.event.simulate(e, t.target, A.event.fix(t))
                };
                A.event.special[e] = {
                    setup: function() {
                        var i = this.ownerDocument || this.document || this,
                            o = Q.access(i, e);
                        o || i.addEventListener(t, n, !0),
                        Q.access(i, e, (o || 0) + 1)
                    },
                    teardown: function() {
                        var i = this.ownerDocument || this.document || this,
                            o = Q.access(i, e) - 1;
                        o ? Q.access(i, e, o) : (i.removeEventListener(t, n, !0), Q.remove(i, e))
                    }
                }
            })),
            A.parseXML = function(t) {
                var e;
                if (!t || "string" != typeof t)
                    return null;
                try {
                    e = (new n.DOMParser).parseFromString(t, "text/xml")
                } catch (t) {
                    e = void 0
                }
                return e && !e.getElementsByTagName("parsererror").length || A.error("Invalid XML: " + t), e
            };
            var me,
                fe = /\[\]$/,
                pe = /\r?\n/g,
                ve = /^(?:submit|button|image|reset|file)$/i,
                _e = /^(?:input|select|textarea|keygen)/i;
            function ye(t, e, n, i) {
                var o;
                if (Array.isArray(e))
                    A.each(e, (function(e, o) {
                        n || fe.test(t) ? i(t, o) : ye(t + "[" + ("object" == typeof o && null != o ? e : "") + "]", o, n, i)
                    }));
                else if (n || "object" !== w(e))
                    i(t, e);
                else
                    for (o in e)
                        ye(t + "[" + o + "]", e[o], n, i)
            }
            A.param = function(t, e) {
                var n,
                    i = [],
                    o = function(t, e) {
                        var n = v(e) ? e() : e;
                        i[i.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == n ? "" : n)
                    };
                if (null == t)
                    return "";
                if (Array.isArray(t) || t.jquery && !A.isPlainObject(t))
                    A.each(t, (function() {
                        o(this.name, this.value)
                    }));
                else
                    for (n in t)
                        ye(n, t[n], e, o);
                return i.join("&")
            },
            A.fn.extend({
                serialize: function() {
                    return A.param(this.serializeArray())
                },
                serializeArray: function() {
                    return this.map((function() {
                        var t = A.prop(this, "elements");
                        return t ? A.makeArray(t) : this
                    })).filter((function() {
                        var t = this.type;
                        return this.name && !A(this).is(":disabled") && _e.test(this.nodeName) && !ve.test(t) && (this.checked || !ft.test(t))
                    })).map((function(t, e) {
                        var n = A(this).val();
                        return null == n ? null : Array.isArray(n) ? A.map(n, (function(t) {
                            return {
                                name: e.name,
                                value: t.replace(pe, "\r\n")
                            }
                        })) : {
                            name: e.name,
                            value: n.replace(pe, "\r\n")
                        }
                    })).get()
                }
            }),
            A.fn.extend({
                wrapAll: function(t) {
                    var e;
                    return this[0] && (v(t) && (t = t.call(this[0])), e = A(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map((function() {
                        for (var t = this; t.firstElementChild;)
                            t = t.firstElementChild;
                        return t
                    })).append(this)), this
                },
                wrapInner: function(t) {
                    return v(t) ? this.each((function(e) {
                        A(this).wrapInner(t.call(this, e))
                    })) : this.each((function() {
                        var e = A(this),
                            n = e.contents();
                        n.length ? n.wrapAll(t) : e.append(t)
                    }))
                },
                wrap: function(t) {
                    var e = v(t);
                    return this.each((function(n) {
                        A(this).wrapAll(e ? t.call(this, n) : t)
                    }))
                },
                unwrap: function(t) {
                    return this.parent(t).not("body").each((function() {
                        A(this).replaceWith(this.childNodes)
                    })), this
                }
            }),
            A.expr.pseudos.hidden = function(t) {
                return !A.expr.pseudos.visible(t)
            },
            A.expr.pseudos.visible = function(t) {
                return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
            },
            p.createHTMLDocument = ((me = y.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === me.childNodes.length),
            A.parseHTML = function(t, e, n) {
                return "string" != typeof t ? [] : ("boolean" == typeof e && (n = e, e = !1), e || (p.createHTMLDocument ? ((i = (e = y.implementation.createHTMLDocument("")).createElement("base")).href = y.location.href, e.head.appendChild(i)) : e = y), r = !n && [], (o = I.exec(t)) ? [e.createElement(o[1])] : (o = wt([t], e, r), r && r.length && A(r).remove(), A.merge([], o.childNodes)));
                var i,
                    o,
                    r
            },
            A.offset = {
                setOffset: function(t, e, n) {
                    var i,
                        o,
                        r,
                        s,
                        a,
                        l,
                        c = A.css(t, "position"),
                        u = A(t),
                        d = {};
                    "static" === c && (t.style.position = "relative"),
                    a = u.offset(),
                    r = A.css(t, "top"),
                    l = A.css(t, "left"),
                    ("absolute" === c || "fixed" === c) && (r + l).indexOf("auto") > -1 ? (s = (i = u.position()).top, o = i.left) : (s = parseFloat(r) || 0, o = parseFloat(l) || 0),
                    v(e) && (e = e.call(t, n, A.extend({}, a))),
                    null != e.top && (d.top = e.top - a.top + s),
                    null != e.left && (d.left = e.left - a.left + o),
                    "using" in e ? e.using.call(t, d) : ("number" == typeof d.top && (d.top += "px"), "number" == typeof d.left && (d.left += "px"), u.css(d))
                }
            },
            A.fn.extend({
                offset: function(t) {
                    if (arguments.length)
                        return void 0 === t ? this : this.each((function(e) {
                            A.offset.setOffset(this, t, e)
                        }));
                    var e,
                        n,
                        i = this[0];
                    return i ? i.getClientRects().length ? (e = i.getBoundingClientRect(), n = i.ownerDocument.defaultView, {
                        top: e.top + n.pageYOffset,
                        left: e.left + n.pageXOffset
                    }) : {
                        top: 0,
                        left: 0
                    } : void 0
                },
                position: function() {
                    if (this[0]) {
                        var t,
                            e,
                            n,
                            i = this[0],
                            o = {
                                top: 0,
                                left: 0
                            };
                        if ("fixed" === A.css(i, "position"))
                            e = i.getBoundingClientRect();
                        else {
                            for (e = this.offset(), n = i.ownerDocument, t = i.offsetParent || n.documentElement; t && (t === n.body || t === n.documentElement) && "static" === A.css(t, "position");)
                                t = t.parentNode;
                            t && t !== i && 1 === t.nodeType && ((o = A(t).offset()).top += A.css(t, "borderTopWidth", !0), o.left += A.css(t, "borderLeftWidth", !0))
                        }
                        return {
                            top: e.top - o.top - A.css(i, "marginTop", !0),
                            left: e.left - o.left - A.css(i, "marginLeft", !0)
                        }
                    }
                },
                offsetParent: function() {
                    return this.map((function() {
                        for (var t = this.offsetParent; t && "static" === A.css(t, "position");)
                            t = t.offsetParent;
                        return t || rt
                    }))
                }
            }),
            A.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, (function(t, e) {
                var n = "pageYOffset" === e;
                A.fn[t] = function(i) {
                    return z(this, (function(t, i, o) {
                        var r;
                        if (_(t) ? r = t : 9 === t.nodeType && (r = t.defaultView), void 0 === o)
                            return r ? r[e] : t[i];
                        r ? r.scrollTo(n ? r.pageXOffset : o, n ? o : r.pageYOffset) : t[i] = o
                    }), t, i, arguments.length)
                }
            })),
            A.each(["top", "left"], (function(t, e) {
                A.cssHooks[e] = Wt(p.pixelPosition, (function(t, n) {
                    if (n)
                        return n = qt(t, e), Vt.test(n) ? A(t).position()[e] + "px" : n
                }))
            })),
            A.each({
                Height: "height",
                Width: "width"
            }, (function(t, e) {
                A.each({
                    padding: "inner" + t,
                    content: e,
                    "": "outer" + t
                }, (function(n, i) {
                    A.fn[i] = function(o, r) {
                        var s = arguments.length && (n || "boolean" != typeof o),
                            a = n || (!0 === o || !0 === r ? "margin" : "border");
                        return z(this, (function(e, n, o) {
                            var r;
                            return _(e) ? 0 === i.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + t], r["scroll" + t], e.body["offset" + t], r["offset" + t], r["client" + t])) : void 0 === o ? A.css(e, n, a) : A.style(e, n, o, a)
                        }), e, s ? o : void 0, s)
                    }
                }))
            })),
            A.fn.extend({
                bind: function(t, e, n) {
                    return this.on(t, null, e, n)
                },
                unbind: function(t, e) {
                    return this.off(t, null, e)
                },
                delegate: function(t, e, n, i) {
                    return this.on(e, t, n, i)
                },
                undelegate: function(t, e, n) {
                    return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", n)
                },
                hover: function(t, e) {
                    return this.mouseenter(t).mouseleave(e || t)
                }
            }),
            A.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function(t, e) {
                A.fn[e] = function(t, n) {
                    return arguments.length > 0 ? this.on(e, null, t, n) : this.trigger(e)
                }
            }));
            var be = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
            A.proxy = function(t, e) {
                var n,
                    i,
                    o;
                if ("string" == typeof e && (n = t[e], e = t, t = n), v(t))
                    return i = a.call(arguments, 2), (o = function() {
                        return t.apply(e || this, i.concat(a.call(arguments)))
                    }).guid = t.guid = t.guid || A.guid++, o
            },
            A.holdReady = function(t) {
                t ? A.readyWait++ : A.ready(!0)
            },
            A.isArray = Array.isArray,
            A.parseJSON = JSON.parse,
            A.nodeName = O,
            A.isFunction = v,
            A.isWindow = _,
            A.camelCase = X,
            A.type = w,
            A.now = Date.now,
            A.isNumeric = function(t) {
                var e = A.type(t);
                return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
            },
            A.trim = function(t) {
                return null == t ? "" : (t + "").replace(be, "")
            },
            void 0 === (i = function() {
                return A
            }.apply(e, [])) || (t.exports = i);
            var Ee = n.jQuery,
                we = n.$;
            A.noConflict = function(t) {
                return n.$ === A && (n.$ = we), t && n.jQuery === A && (n.jQuery = Ee), A
            };
            var Ae,
                Ce,
                Te = /^(?:toggle|show|hide)$/,
                Ne = /queueHooks$/;
            function Se() {
                Ce && (!1 === y.hidden && n.requestAnimationFrame ? n.requestAnimationFrame(Se) : n.setTimeout(Se, A.fx.interval), A.fx.tick())
            }
            function xe() {
                return n.setTimeout((function() {
                    Ae = void 0
                })), Ae = Date.now()
            }
            function Oe(t, e) {
                var n,
                    i = 0,
                    o = {
                        height: t
                    };
                for (e = e ? 1 : 0; i < 4; i += 2 - e)
                    o["margin" + (n = ot[i])] = o["padding" + n] = t;
                return e && (o.opacity = o.width = t), o
            }
            function Ie(t, e, n, i, o) {
                return new Ie.prototype.init(t, e, n, i, o)
            }
            function De(t, e, n) {
                for (var i, o = (Me.tweeners[e] || []).concat(Me.tweeners["*"]), r = 0, s = o.length; r < s; r++)
                    if (i = o[r].call(n, e, t))
                        return i
            }
            function Me(t, e, n) {
                var i,
                    o,
                    r = 0,
                    s = Me.prefilters.length,
                    a = A.Deferred().always((function() {
                        delete l.elem
                    })),
                    l = function() {
                        if (o)
                            return !1;
                        for (var e = Ae || xe(), n = Math.max(0, c.startTime + c.duration - e), i = 1 - (n / c.duration || 0), r = 0, s = c.tweens.length; r < s; r++)
                            c.tweens[r].run(i);
                        return a.notifyWith(t, [c, i, n]), i < 1 && s ? n : (s || a.notifyWith(t, [c, 1, 0]), a.resolveWith(t, [c]), !1)
                    },
                    c = a.promise({
                        elem: t,
                        props: A.extend({}, e),
                        opts: A.extend(!0, {
                            specialEasing: {},
                            easing: A.easing._default
                        }, n),
                        originalProperties: e,
                        originalOptions: n,
                        startTime: Ae || xe(),
                        duration: n.duration,
                        tweens: [],
                        createTween: function(e, n) {
                            var i = A.Tween(t, c.opts, e, n, c.opts.specialEasing[e] || c.opts.easing);
                            return c.tweens.push(i), i
                        },
                        stop: function(e) {
                            var n = 0,
                                i = e ? c.tweens.length : 0;
                            if (o)
                                return this;
                            for (o = !0; n < i; n++)
                                c.tweens[n].run(1);
                            return e ? (a.notifyWith(t, [c, 1, 0]), a.resolveWith(t, [c, e])) : a.rejectWith(t, [c, e]), this
                        }
                    }),
                    u = c.props;
                for (!function(t, e) {
                    var n,
                        i,
                        o,
                        r,
                        s;
                    for (n in t)
                        if (o = e[i = X(n)], r = t[n], Array.isArray(r) && (o = r[1], r = t[n] = r[0]), n !== i && (t[i] = r, delete t[n]), (s = A.cssHooks[i]) && "expand" in s)
                            for (n in r = s.expand(r), delete t[i], r)
                                n in t || (t[n] = r[n], e[n] = o);
                        else
                            e[i] = o
                }(u, c.opts.specialEasing); r < s; r++)
                    if (i = Me.prefilters[r].call(c, t, u, c.opts))
                        return v(i.stop) && (A._queueHooks(c.elem, c.opts.queue).stop = i.stop.bind(i)), i;
                return A.map(u, De, c), v(c.opts.start) && c.opts.start.call(t, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), A.fx.timer(A.extend(l, {
                    elem: t,
                    anim: c,
                    queue: c.opts.queue
                })), c
            }
            return A.Tween = Ie, Ie.prototype = {
                constructor: Ie,
                init: function(t, e, n, i, o, r) {
                    this.elem = t,
                    this.prop = n,
                    this.easing = o || A.easing._default,
                    this.options = e,
                    this.start = this.now = this.cur(),
                    this.end = i,
                    this.unit = r || (A.cssNumber[n] ? "" : "px")
                },
                cur: function() {
                    var t = Ie.propHooks[this.prop];
                    return t && t.get ? t.get(this) : Ie.propHooks._default.get(this)
                },
                run: function(t) {
                    var e,
                        n = Ie.propHooks[this.prop];
                    return this.options.duration ? this.pos = e = A.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Ie.propHooks._default.set(this), this
                }
            }, Ie.prototype.init.prototype = Ie.prototype, Ie.propHooks = {
                _default: {
                    get: function(t) {
                        var e;
                        return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = A.css(t.elem, t.prop, "")) && "auto" !== e ? e : 0
                    },
                    set: function(t) {
                        A.fx.step[t.prop] ? A.fx.step[t.prop](t) : 1 !== t.elem.nodeType || !A.cssHooks[t.prop] && null == t.elem.style[Kt(t.prop)] ? t.elem[t.prop] = t.now : A.style(t.elem, t.prop, t.now + t.unit)
                    }
                }
            }, Ie.propHooks.scrollTop = Ie.propHooks.scrollLeft = {
                set: function(t) {
                    t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
                }
            }, A.easing = {
                linear: function(t) {
                    return t
                },
                swing: function(t) {
                    return .5 - Math.cos(t * Math.PI) / 2
                },
                _default: "swing"
            }, A.fx = Ie.prototype.init, A.fx.step = {}, A.Animation = A.extend(Me, {
                tweeners: {
                    "*": [function(t, e) {
                        var n = this.createTween(t, e);
                        return ct(n.elem, t, it.exec(e), n), n
                    }]
                },
                tweener: function(t, e) {
                    v(t) ? (e = t, t = ["*"]) : t = t.match(P);
                    for (var n, i = 0, o = t.length; i < o; i++)
                        n = t[i],
                        Me.tweeners[n] = Me.tweeners[n] || [],
                        Me.tweeners[n].unshift(e)
                },
                prefilters: [function(t, e, n) {
                    var i,
                        o,
                        r,
                        s,
                        a,
                        l,
                        c,
                        u,
                        d = "width" in e || "height" in e,
                        h = this,
                        g = {},
                        m = t.style,
                        f = t.nodeType && lt(t),
                        p = Q.get(t, "fxshow");
                    for (i in n.queue || (null == (s = A._queueHooks(t, "fx")).unqueued && (s.unqueued = 0, a = s.empty.fire, s.empty.fire = function() {
                        s.unqueued || a()
                    }), s.unqueued++, h.always((function() {
                        h.always((function() {
                            s.unqueued--,
                            A.queue(t, "fx").length || s.empty.fire()
                        }))
                    }))), e)
                        if (o = e[i], Te.test(o)) {
                            if (delete e[i], r = r || "toggle" === o, o === (f ? "hide" : "show")) {
                                if ("show" !== o || !p || void 0 === p[i])
                                    continue;
                                f = !0
                            }
                            g[i] = p && p[i] || A.style(t, i)
                        }
                    if ((l = !A.isEmptyObject(e)) || !A.isEmptyObject(g))
                        for (i in d && 1 === t.nodeType && (n.overflow = [m.overflow, m.overflowX, m.overflowY], null == (c = p && p.display) && (c = Q.get(t, "display")), "none" === (u = A.css(t, "display")) && (c ? u = c : (ht([t], !0), c = t.style.display || c, u = A.css(t, "display"), ht([t]))), ("inline" === u || "inline-block" === u && null != c) && "none" === A.css(t, "float") && (l || (h.done((function() {
                            m.display = c
                        })), null == c && (u = m.display, c = "none" === u ? "" : u)), m.display = "inline-block")), n.overflow && (m.overflow = "hidden", h.always((function() {
                            m.overflow = n.overflow[0],
                            m.overflowX = n.overflow[1],
                            m.overflowY = n.overflow[2]
                        }))), l = !1, g)
                            l || (p ? "hidden" in p && (f = p.hidden) : p = Q.access(t, "fxshow", {
                                display: c
                            }), r && (p.hidden = !f), f && ht([t], !0), h.done((function() {
                                for (i in f || ht([t]), Q.remove(t, "fxshow"), g)
                                    A.style(t, i, g[i])
                            }))),
                            l = De(f ? p[i] : 0, i, h),
                            i in p || (p[i] = l.start, f && (l.end = l.start, l.start = 0))
                }],
                prefilter: function(t, e) {
                    e ? Me.prefilters.unshift(t) : Me.prefilters.push(t)
                }
            }), A.speed = function(t, e, n) {
                var i = t && "object" == typeof t ? A.extend({}, t) : {
                    complete: n || !n && e || v(t) && t,
                    duration: t,
                    easing: n && e || e && !v(e) && e
                };
                return A.fx.off ? i.duration = 0 : "number" != typeof i.duration && (i.duration in A.fx.speeds ? i.duration = A.fx.speeds[i.duration] : i.duration = A.fx.speeds._default), null != i.queue && !0 !== i.queue || (i.queue = "fx"), i.old = i.complete, i.complete = function() {
                    v(i.old) && i.old.call(this),
                    i.queue && A.dequeue(this, i.queue)
                }, i
            }, A.fn.extend({
                fadeTo: function(t, e, n, i) {
                    return this.filter(lt).css("opacity", 0).show().end().animate({
                        opacity: e
                    }, t, n, i)
                },
                animate: function(t, e, n, i) {
                    var o = A.isEmptyObject(t),
                        r = A.speed(e, n, i),
                        s = function() {
                            var e = Me(this, A.extend({}, t), r);
                            (o || Q.get(this, "finish")) && e.stop(!0)
                        };
                    return s.finish = s, o || !1 === r.queue ? this.each(s) : this.queue(r.queue, s)
                },
                stop: function(t, e, n) {
                    var i = function(t) {
                        var e = t.stop;
                        delete t.stop,
                        e(n)
                    };
                    return "string" != typeof t && (n = e, e = t, t = void 0), e && this.queue(t || "fx", []), this.each((function() {
                        var e = !0,
                            o = null != t && t + "queueHooks",
                            r = A.timers,
                            s = Q.get(this);
                        if (o)
                            s[o] && s[o].stop && i(s[o]);
                        else
                            for (o in s)
                                s[o] && s[o].stop && Ne.test(o) && i(s[o]);
                        for (o = r.length; o--;)
                            r[o].elem !== this || null != t && r[o].queue !== t || (r[o].anim.stop(n), e = !1, r.splice(o, 1));
                        !e && n || A.dequeue(this, t)
                    }))
                },
                finish: function(t) {
                    return !1 !== t && (t = t || "fx"), this.each((function() {
                        var e,
                            n = Q.get(this),
                            i = n[t + "queue"],
                            o = n[t + "queueHooks"],
                            r = A.timers,
                            s = i ? i.length : 0;
                        for (n.finish = !0, A.queue(this, t, []), o && o.stop && o.stop.call(this, !0), e = r.length; e--;)
                            r[e].elem === this && r[e].queue === t && (r[e].anim.stop(!0), r.splice(e, 1));
                        for (e = 0; e < s; e++)
                            i[e] && i[e].finish && i[e].finish.call(this);
                        delete n.finish
                    }))
                }
            }), A.each(["toggle", "show", "hide"], (function(t, e) {
                var n = A.fn[e];
                A.fn[e] = function(t, i, o) {
                    return null == t || "boolean" == typeof t ? n.apply(this, arguments) : this.animate(Oe(e, !0), t, i, o)
                }
            })), A.each({
                slideDown: Oe("show"),
                slideUp: Oe("hide"),
                slideToggle: Oe("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, (function(t, e) {
                A.fn[t] = function(t, n, i) {
                    return this.animate(e, t, n, i)
                }
            })), A.timers = [], A.fx.tick = function() {
                var t,
                    e = 0,
                    n = A.timers;
                for (Ae = Date.now(); e < n.length; e++)
                    (t = n[e])() || n[e] !== t || n.splice(e--, 1);
                n.length || A.fx.stop(),
                Ae = void 0
            }, A.fx.timer = function(t) {
                A.timers.push(t),
                A.fx.start()
            }, A.fx.interval = 13, A.fx.start = function() {
                Ce || (Ce = !0, Se())
            }, A.fx.stop = function() {
                Ce = null
            }, A.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            }, A
        }(window)),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t, e) {
            if (!e)
                return console.error("Loopindex Utils: window.LOOPINDEX is not defined");
            if (!e.VERSION || !e.$)
                return console.error("Loopindex Utils: window.LOOPINDEX is not properly defined");
            const n = t => {
                    const e = {
                        major: 0,
                        minor: 0,
                        build: 0
                    };
                    if (!t || ["string", "number"].indexOf(typeof t) < 0)
                        return e;
                    if (!(t = String(t || "").trim()))
                        return e;
                    function n(t) {
                        if (!t)
                            return 0;
                        const e = parseInt(t.replace(/[^\d]+/g, ""));
                        return isNaN(e) ? 0 : e
                    }
                    const i = t.match(/(\d+)(\.\d+)?(\.\d+)?/);
                    return i ? {
                        major: n(i[1]),
                        minor: n(i[2]),
                        build: n(i[3])
                    } : e
                },
                i = (t, e) => {
                    const i = n(t),
                        o = n(e);
                    return Math.sign(i.major - o.major) || Math.sign(i.minor - o.minor) || Math.sign(i.build - o.build)
                };
            if (e.utils && i("1.9.12", e.utils.VERSION) < 1)
                return;
            const o = e.$,
                r = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/,
                s = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.\%]+)\s*\)/;
            new Set(["TEXTAREA", "INPUT", "OL", "UL", "TABLE", "TR", "IMG", "SCRIPT", "LINK", "svg", "BR"]);
            class a {
                constructor(t, e)
                {
                    this.prefix = t,
                    this._config = {
                        log: !1,
                        debug: !1,
                        warn: !1,
                        error: !0,
                        trace: !1,
                        throttle: !0
                    },
                    this._logs = [],
                    this.timeout = null,
                    this.config(e)
                }
                config(t)
                {
                    if (t) {
                        const e = {};
                        Object.entries(this._config).forEach(([n, i]) => {
                            const o = t[n];
                            typeof i == typeof o && (e[n] = o)
                        }),
                        o.extend(this._config, e)
                    }
                    return o.extend({}, this._config)
                }
                ignore() {}
                log(...t)
                {
                    this._config.log && this._log("log", Array.from(t))
                }
                error(...t)
                {
                    this._config.error && this._log("error", Array.from(t))
                }
                debug(...t)
                {
                    this._config.debug && this._log("log", Array.from(t))
                }
                trace(...t)
                {
                    if (this._config.trace) {
                        const e = Error().stack,
                            n = e ? [e.replace("Error", "Debug:"), "\n"] : [];
                        this._log("log", n.concat(Array.from(t)))
                    }
                }
                warn(...t)
                {
                    this._config.warn && this._log("warn", Array.from(t))
                }
                _log(t, e)
                {
                    const n = new Date,
                        i = [n.getMinutes(), n.getSeconds(), n.getMilliseconds()].join(":");
                    e.unshift(i + ">"),
                    e.unshift(this.prefix),
                    this._config.throttle && "error" !== t && "warn" !== t ? (this._logs.push({
                        method: t,
                        logs: e
                    }), this.scheduleDump()) : console[t].apply(console, e)
                }
                dump()
                {
                    const t = this._logs.slice();
                    this._logs.length = 0,
                    t.forEach((function(t) {
                        console[t.method].apply(console, t.logs)
                    }))
                }
                scheduleDump()
                {
                    this.timeout || (this.timeout = setTimeout(function() {
                        this.timeout = null,
                        this.dump()
                    }.bind(this), 100))
                }
            }
            class l {
                merge(t, n, i, o=!1)
                {
                    const r = null === i ? (t, e) => t === e : (t, e) => t === e || t && e && t[i] === e[i];
                    t = t || [];
                    const s = [];
                    return (n = n || []).forEach(n => {
                        let i = !1;
                        for (let s = 0, a = t.length; !i && s < a; ++s) {
                            const a = t[s];
                            r(a, n) && (t[s] = o && a && n ? e.$.extend(a, n) : n, i = !0)
                        }
                        i || s.push(n)
                    }), t.push(...s), t
                }
                firstIndex(t, e)
                {
                    const n = null == t ? void 0 : t.length;
                    if (!n || !e)
                        return -1;
                    if (Array.isArray(t))
                        return t.findIndex(e);
                    for (let i = 0; i < n; ++i)
                        if (e(t[i], i, t))
                            return i;
                    return -1
                }
                first(t, e)
                {
                    const n = this.firstIndex(t, e);
                    return n < 0 ? null : t[n]
                }
                remove(t, n)
                {
                    if (!(null == t ? void 0 : t.length))
                        return Array.isArray(t) ? t : [];
                    const i = n.element,
                        o = n.test;
                    if (void 0 !== i === Boolean(o))
                        return e.logger.warn("provide exactly one of element/test in array remove"), t;
                    const r = !1 !== n.inPlace && Array.isArray(t) ? t : Array.from(t);
                    let s = 0;
                    n.from && (n.from >= 0 && n.from < r.length ? s = Math.floor(n.from) : e.logger.warn("Invalid from field in array remove " + n.from));
                    const a = !1 === n.all ? 1 : r.length;
                    if (0 === s && 1 === a) {
                        const t = o ? r.findIndex(o) : r.indexOf(i);
                        return t >= 0 && r.splice(t, 1), r
                    }
                    for (let t = r.length - 1, e = 0; t >= s && e < a; --t) {
                        (o ? o(r[t], t, r) : r[t] === i) && (r.splice(t, 1), ++e)
                    }
                    return r
                }
            }
            class c {
                constructor(t)
                {
                    if (this._doc = t, !t)
                        throw new Error("CSS Loader: null document");
                    this._styleId = e.utils.strings.randomString(8),
                    this._loadedStyleIds = new Set
                }
                get document()
                {
                    return this._doc
                }
                getOwnStyleSheet(t)
                {
                    let e = this._doc.getElementById(this._styleId);
                    return !e && t && (e = this._doc.createElement("style"), e.appendChild(this._doc.createTextNode("")), e.setAttribute("id", this._styleId), this._loadedStyleIds.add(this._styleId), this.$head.append(e)), e && e.sheet
                }
                loadCSSString(t, e)
                {
                    if (!(t = null == t ? void 0 : t.trim()))
                        return;
                    const n = "li-style-" + t.split("").reduce((t, e, n) => t + n * e.charCodeAt(0), 0),
                        i = this.$head;
                    if (i.find(`style[id='${n}']`).length)
                        return;
                    const o = this._doc.createElement("style");
                    o.id = n,
                    this._loadedStyleIds.add(n),
                    o.appendChild(this._doc.createTextNode(t)),
                    i.append(o)
                }
                loadCSS(t, n)
                {
                    const i = this.$head,
                        r = this._doc,
                        s = e.utils.strings.toStringArray(t),
                        a = {
                            ok: !0,
                            loaded: [],
                            failed: []
                        },
                        l = ({url: t, error: n}) => {
                            n ? (a.ok = !1, a.failed.push({
                                url: t,
                                error: n
                            }), e.logger.warn("Error loading css " + t)) : a.loaded.push(t),
                            c()
                        },
                        c = () => {
                            if (!s.length || !a.ok)
                                return void (n && setTimeout(() => n(a), 1));
                            const t = s.shift();
                            if (!t)
                                return c();
                            const u = `_loopindex-${t.replace(/[^0-9a-z]+/gi, "_")}_`;
                            if (0 === o(i).find(`link[data-loopindex-id='${u}']`).length) {
                                const n = r.createElement("link"),
                                    s = o(n);
                                e.utils.dom.attachCBToLink(n, t, l),
                                s.attr({
                                    rel: "stylesheet",
                                    type: "text/css",
                                    "data-loopindex-id": u,
                                    href: t
                                }),
                                this._loadedStyleIds.add(u),
                                i.append(s)
                            } else
                                l({
                                    url: t
                                })
                        };
                    return c(), this
                }
                addRule(t, n)
                {
                    var i;
                    if (!n || "object" != typeof n || Object.keys(n).length < 1)
                        return this;
                    const o = this.getOwnStyleSheet(!0);
                    if (!o)
                        return e.logger.warn("LoopIndex CSSLoader cannot create stylesheet"), this;
                    const r = (null === (i = o.cssRules) || void 0 === i ? void 0 : i.length) || 0,
                        s = this._makeRule(n);
                    return "function" == typeof o.addRule ? o.addRule(t, s, r) : "function" == typeof o.insertRule ? o.insertRule(`${t} { ${this._makeRule(n)} }`, r) : e.logger.error("CSSLoader addRule: no matching function"), this
                }
                reset()
                {
                    const t = this.getOwnStyleSheet(!1);
                    if (null == t ? void 0 : t.deleteRule)
                        for (let e = t.cssRules.length - 1; e >= 0; --e)
                            t.deleteRule(e);
                    return this
                }
                dispose()
                {
                    if (!this._doc)
                        return;
                    const t = this.$head;
                    this._doc = null,
                    Array.from(this._loadedStyleIds.keys()).forEach(e => {
                        try {
                            t.find("#" + e).remove()
                        } catch (t) {}
                    }),
                    this._loadedStyleIds.clear()
                }
                get $head()
                {
                    var t,
                        n,
                        i;
                    return e.$((null === (t = this._doc) || void 0 === t ? void 0 : t.head) || (null !== (i = null === (n = this._doc) || void 0 === n ? void 0 : n.getElementsByTagName("head")) && void 0 !== i ? i : ""))
                }
                _makeRule(t)
                {
                    return Object.keys(t || {}).map(e => `${e}: ${t[e]};`).join("\n")
                }
            }
            class u {
                constructor()
                {
                    this._map = new Map,
                    this._items = []
                }
                get(t)
                {
                    var e,
                        n;
                    return null !== (n = null === (e = this._map.get(t)) || void 0 === e ? void 0 : e.item) && void 0 !== n ? n : null
                }
                contains(t)
                {
                    const e = this._items.find(e => e.item === t);
                    return Boolean(e)
                }
                get length()
                {
                    return this._items.length
                }
                hasId(t)
                {
                    return this._map.has(t)
                }
                clear()
                {
                    return this._items.length = 0, this._map.clear(), this
                }
                reverse()
                {
                    if (this._items.length < 2)
                        return this;
                    for (let t = 0, e = this._items.length - 1; t < e; ++t, --e) {
                        const n = this._items[t],
                            i = this._items[e];
                        this._items[t] = i,
                        this._items[e] = n,
                        this._map.set(n.id, {
                            item: n.item,
                            index: e
                        }).set(i.id, {
                            item: i.item,
                            index: t
                        })
                    }
                    return this
                }
                firstIndex(t)
                {
                    for (let e = 0, n = this.length; e < n; ++e)
                        if (t(this._items[e].item, e))
                            return e;
                    return -1
                }
                first(t)
                {
                    const e = this.firstIndex(t);
                    return e >= 0 ? this._items[e].item : null
                }
                filter(t)
                {
                    return this._items.reduce((e, n, i) => (t(n.item, i) && e.push(n.item), e), [])
                }
                count(t)
                {
                    let e = 0;
                    for (let n = 0, i = this._items.length; n < i; ++n)
                        t(this._items[n].item, n) && e++;
                    return e
                }
                map(t)
                {
                    return this._items.map((e, n) => t(e.item, n))
                }
                get asMap()
                {
                    return this._items.reduce((t, e) => (t.set(e.id, e.item), t), new Map)
                }
                get asObject()
                {
                    const t = {};
                    return this._map.forEach((e, n) => {
                        t[n] = e.item
                    }), t
                }
                get items()
                {
                    return this._items.map(t => t.item)
                }
                getItemIndex(t)
                {
                    var e;
                    const n = this._map.get(t);
                    return null !== (e = null == n ? void 0 : n.index) && void 0 !== e ? e : -1
                }
                getAt(t)
                {
                    const n = this._validateIndex(t, !1);
                    return n.error ? (e.logger.error("getAt: " + n.error), null) : this._items[n.index].item
                }
                move(t, n)
                {
                    const i = t ? this._map.get(t) : null;
                    if (!i)
                        return e.logger.error("maparray move: unkonw id " + t), this;
                    const o = this._validateIndex(n, !1);
                    if (o.error)
                        return e.logger.error("maparray move: invalid index " + n), this;
                    if (i.index !== o.index) {
                        const e = this._items[i.index];
                        this._items.splice(i.index, 1),
                        this._items.splice(o.index, 0, e),
                        this._map.set(t, {
                            item: i.item,
                            index: o.index
                        })
                    }
                    return this
                }
                moveBefore(t, n)
                {
                    if (!t || !n || t === n)
                        return e.logger.error(`moveBefore: invalid input ${t}, ${n}`), !1;
                    const i = this._map.get(t),
                        o = this._map.get(n);
                    if (!i || !o)
                        return e.logger.error(`moveBefore: can't find items ${t} and/or ${n}`), !1;
                    const r = o.index - 1;
                    if (i.index === r)
                        return !1;
                    let s = i.index < r ? 1 : 0;
                    return this._items.splice(i.index, 1), this._items.splice(o.index - s, 0, {
                        item: i.item,
                        id: t
                    }), this._refresh(0), !0
                }
                moveAfter(t, e)
                {
                    return this.moveBefore(e, t)
                }
                push({item: t, id: e})
                {
                    return this.add({
                        item: t,
                        id: e,
                        index: this.length
                    })
                }
                pop(t)
                {
                    const e = this._validateIndex("number" == typeof t ? t : this.length - 1, !1);
                    if (e.error)
                        return;
                    const n = this._items[e.index];
                    return this.removeByIndex(e.index), n.item
                }
                add({item: t, id: e, index: n, replace: i})
                {
                    if (!t || !e)
                        throw new Error("ArrayMap add: null element and/or id");
                    const o = void 0 === n || isNaN(n),
                        r = this.getItemIndex(e);
                    if (r >= 0) {
                        if (void 0 === i)
                            return this;
                        if (!1 === i)
                            throw new Error(`Element with id ${e} already in ArrayMap`);
                        if (o || n === r)
                            return this._map.set(e, {
                                index: r,
                                item: t
                            }), this;
                        this.removeByIndex(r),
                        n > r && (n -= 1)
                    }
                    (void 0 === n || isNaN(n)) && (n = this.length);
                    const s = this._validateIndex(n, !0);
                    if (s.error)
                        throw new Error(`ArrayMap add: illegal index ${n} for id ${e}`);
                    const a = {
                        id: e,
                        item: t
                    };
                    return (n = s.index) === this._items.length ? (this._items.push(a), this._map.set(e, {
                        index: n,
                        item: t
                    })) : (this._items.splice(n, 0, a), this._refresh(n)), this
                }
                removeById(t)
                {
                    const n = this._map.get(t);
                    return n ? (this._items.splice(n.index, 1), this._map.delete(t), this._refresh(n.index), this) : (e.logger.warn("ArrayMap.removeById: no item with id " + t), this)
                }
                forEach(t)
                {
                    const e = this._items.slice();
                    for (let n = 0, i = e.length; n < i; ++n) {
                        const i = e[n];
                        if (this.hasId(i.id)) {
                            if (!1 === t(e[n].item, n))
                                break
                        }
                    }
                }
                removeByIndex(t)
                {
                    const n = this._validateIndex(t, !1);
                    if (n.error)
                        e.logger.error("Arraymap remove by index: " + n.error);
                    else {
                        const t = n.index,
                            e = this._items[t];
                        this._items.splice(t, 1),
                        this._map.delete(e.id),
                        this._refresh(t)
                    }
                    return this
                }
                _refresh(t)
                {
                    for (let e = t, n = this._items.length; e < n; ++e) {
                        const t = this._items[e];
                        this._map.set(t.id, {
                            item: t.item,
                            index: e
                        })
                    }
                }
                _validateIndex(t, e)
                {
                    const n = this._items.length - (e ? 0 : 1);
                    return !isNaN(t) && t >= 0 && t <= n ? {
                        error: "",
                        index: Math.floor(t)
                    } : {
                        error: "invalid index " + t
                    }
                }
            }
            class d extends u {
                constructor(t)
                {
                    super(),
                    this.idGet = t
                }
                pushItem(t)
                {
                    return this.addItem({
                        item: t,
                        index: this.length
                    })
                }
                has(t)
                {
                    return this.hasId(this.idGet(t))
                }
                addItem(t)
                {
                    return this.add(Object.assign(Object.assign({}, t), {
                        id: this.idGet(t.item)
                    }))
                }
                removeItem(t)
                {
                    return this.removeById(this.idGet(t))
                }
            }
            const h = t => "string" == typeof t ? t.toLowerCase() : String(t).toLowerCase();
            class g extends Map {
                set(t, e)
                {
                    return super.set(h(t), e)
                }
                get(t)
                {
                    return super.get(h(t))
                }
                has(t)
                {
                    return super.has(h(t))
                }
                clone()
                {
                    return new g(this.entries())
                }
            }
            class m extends Set {
                add(t)
                {
                    return super.add(h(t))
                }
                delete(t)
                {
                    return super.delete(h(t))
                }
                has(t)
                {
                    return super.has(h(t))
                }
                clone()
                {
                    return new m(this.values())
                }
            }
            class f {
                constructor()
                {
                    this.VERSION = "1.9.12",
                    this.array = new l
                }
                compareVersions(t, e)
                {
                    const n = i(t, e);
                    return n > 0 ? 1 : 0 === n ? 0 : -1
                }
                parseVersion(t)
                {
                    return n(t)
                }
                createCIMap(t, ...n)
                {
                    let i = [],
                        o = !1;
                    return t && (Array.isArray(t) ? t.length && (Array.isArray(t[0]) ? i.push(...t) : (i.push(t), o = !0)) : Object.entries(t).forEach(([t, e]) => {
                        i.push([t, e])
                    })), o ? n.forEach(t => i.push(t)) : n.length && e.logger.error("createCIMap: can't pass more arguments after record/array of tuples"), new g(i)
                }
                createCISet(t, ...e)
                {
                    const n = this.strings.toStringArray(t);
                    return (null == e ? void 0 : e.length) ? new m([...n, ...e]) : new m(n)
                }
                createArrayMap()
                {
                    return new u
                }
                createTypedArrayMap(t)
                {
                    return new d(t)
                }
                clearObject(t)
                {
                    return t ? (Object.keys(t).forEach(e => {
                        try {
                            delete t[e]
                        } catch (t) {}
                    }), t) : {}
                }
                getRelativeTimezoneOffset(t)
                {
                    if (!t)
                        return 0;
                    try {
                        const e = new Date,
                            n = e.toLocaleString("en-us", {
                                timeZone: t
                            });
                        return Date.parse(n) - e.getTime()
                    } catch (n) {
                        return e.logger.error("convertDateToTimezone", t, n), 0
                    }
                }
                convertDateToTimezone(t, n)
                {
                    if (t = t || new Date, !n)
                        return t;
                    try {
                        const i = e.utils.getRelativeTimezoneOffset(n);
                        return new Date(t.getTime() + i)
                    } catch (i) {
                        return e.logger.error("convertDateToTimezone", n, i), t
                    }
                }
                get CSSLoader()
                {
                    return c
                }
                intensifyColor(t, e)
                {
                    const n = t.match(r);
                    let i = n ? null : t.match(s);
                    const o = i || i;
                    let a,
                        l = 10;
                    o ? a = [o[1], o[2], o[3]] : (l = 16, (t = String(t).replace(/[^0-9a-f]/gi, "")).length < 6 && (t = t[0] + t[0] + t[1] + t[1] + t[2] + t[2]), a = [t.substr(0, 2), t.substr(2, 2), t.substr(4, 2)]),
                    e = e || 0;
                    const c = [];
                    let u;
                    for (let t = 0; t < 3; t++)
                        u = parseInt(a[t], l),
                        c.push(Math.round(Math.min(Math.max(0, u + u * e), 255)));
                    return n ? `rgb(${c[0]},${c[1]},${c[2]})` : i ? `rgba(${c[0]},${c[1]},${c[2]}, ${i[4]})` : "#" + c.map(t => t < 16 ? "0" + t.toString(16) : t.toString(16)).join("")
                }
                getUniqueNumber()
                {
                    return f.nextId++
                }
                getUniqueId(t, n)
                {
                    return `${t}${e.utils.getUniqueNumber()}${n || ""}`
                }
                yes(...t)
                {
                    return !0
                }
                no(...t)
                {
                    return !1
                }
                always(t)
                {
                    return function(...e) {
                        return t
                    }
                }
                noop(...t) {}
                getCurrentScriptPath()
                {
                    const t = e.utils.getCurrentScriptURL();
                    if (!t)
                        return null;
                    const n = /^(.+\/)[^\/]+\.js/i.exec(t);
                    return n && n[1]
                }
                getCurrentScriptURL()
                {
                    try {
                        const t = document && document.currentScript;
                        if (t)
                            return t.src;
                        const e = window.import,
                            n = e && e.meta;
                        return void 0 !== n && n.url ? n.url : null
                    } catch (t) {
                        return null
                    }
                }
                isAbsoluteUrl(t)
                {
                    return !!t && ("/" === t[0] || /^[a-z]+\:\/\//i.test(t) || /^data:/.test(t))
                }
            }
            f.nextId = Math.round(Date.now() % 1e5);
            class p {
                constructor()
                {
                    this._listeners = e.utils.createCIMap(),
                    this._muted = !1
                }
                getListeners(t)
                {
                    return this._listeners.has(t) || this._listeners.set(t, []), this._listeners.get(t)
                }
                dispose()
                {
                    this.removeAllListeners()
                }
                notifyListeners(t, ...n)
                {
                    if (!t)
                        return void e.logger.warn("cannot trigger empty event");
                    if (this._muted)
                        return;
                    const i = this.getListeners(t),
                        o = i.length ? i.slice() : i,
                        r = [];
                    o.forEach(t => {
                        t.muted || t.callback.apply(t.scope, n),
                        t.options && t.options.count && (--t.options.count, t.options.count <= 0 && r.push(t))
                    }),
                    r.length && (r.forEach((function(t) {
                        i.splice(i.indexOf(t), 1)
                    })), this._cleanup())
                }
                on(t, n, i, o)
                {
                    if (!t)
                        return e.logger.warn("cannot register to empty event"), this;
                    if (Array.isArray(t))
                        t.forEach(t => {
                            this.on(t, n, i, o)
                        });
                    else if ("function" == typeof n) {
                        this.getListeners(t).push({
                            scope: i,
                            muted: !1,
                            callback: n,
                            options: o
                        })
                    } else
                        e.logger.error("events mixin addListener: bad callback", n);
                    return this
                }
                off(t, e)
                {
                    if (!t && !e)
                        return this.removeAllListeners();
                    if (!e && t && "object" == typeof t && (e = t, t = null), t && t instanceof Array)
                        return t.forEach(t => {
                            this.off(t, e)
                        }), this;
                    function n(t, n) {
                        return t && (!e || t.scope === e || t.callback === e)
                    }
                    return this._listeners.forEach((e, i) => {
                        t && t !== i || e.filter(n).forEach(t => {
                            const n = e.indexOf(t);
                            n >= 0 && e.splice(n, 1)
                        })
                    }), this._cleanup(), this
                }
                removeAllListeners()
                {
                    return this._listeners.clear(), this
                }
                muteListener(t, e)
                {
                    return t ? (e = Boolean(e), this._listeners.forEach(n => {
                        n && n.forEach(n => {
                            n && n.scope === t && (n.muted = e)
                        })
                    }), this) : this
                }
                muteEvents()
                {
                    return this._muted = !0, this
                }
                unmuteEvents()
                {
                    return this._muted = !1, this
                }
                once(t, e, n, i)
                {
                    return (i = i || {}).count = 1, this.on(t, e, n, i)
                }
                trigger(t, ...e)
                {
                    return this.notifyListeners.apply(this, [t].concat(e)), this
                }
                _cleanup()
                {
                    const t = [];
                    this._listeners.forEach((e, n) => {
                        (null == e ? void 0 : e.length) || t.push(n)
                    }),
                    t.forEach(t => this._listeners.delete(t))
                }
            }
            const v = new class {
                    constructor()
                    {
                        var t;
                        this.msie = !1,
                        this.type = "unknown",
                        this.webkit = !1,
                        this.chrome = !1,
                        this.safari = !1,
                        this.firefox = !1,
                        this.webkitType = null;
                        const e = navigator.userAgent.toLowerCase(),
                            n = function(t) {
                                t = t.toLowerCase();
                                const e = /(chrome)[ \/]([\w.]+)/.exec(t) || /(webkit)[ \/]([\w.]+)/.exec(t) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(t) || /(msie) ([\w.]+)/.exec(t) || t.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(t) || [];
                                return {
                                    browser: e[1] || "",
                                    version: e[2] || "0"
                                }
                            }(e);
                        n.browser && (this[n.browser] = !0, this.version = n.version || "0", this.type = n.browser),
                        this.chrome ? this.webkit = !0 : this.webkit && (this.safari = !0),
                        this.webkit && (this.type = "webkit", this.webkitType = "webkit" !== this.type ? null : Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0 ? "safari" : "chrome"),
                        this.firefox = !0 === /firefox/i.test(e),
                        this.msie || (this.msie = Boolean(/trident/i.test(e))) && (this.type = "msie");
                        const i = window.navigator.platform || (null === (t = window.navigator.userAgentData) || void 0 === t ? void 0 : t.platform);
                        this.isMac = i ? /^mac/i.test(i) : /macintosh;/i.test(window.navigator.userAgent)
                    }
                }
                ,
                _ = new a("LoopIndex"),
                y = {
                    createLogger: (t, e) => new a(t, e),
                    logger: _,
                    utils: new f,
                    URLArguments: new class {
                        constructor()
                        {
                            this._args = null,
                            this._url = ""
                        }
                        getArgument(t, e)
                        {
                            return this._parseLocation(), this._args.hasOwnProperty(t) ? decodeURIComponent(this._args[t]) : e
                        }
                        getNumericArgument(t, e)
                        {
                            var n = this.getArgument(t, ""),
                                i = parseInt(n, 10);
                            return isNaN(i) && (i = e), i
                        }
                        getAllArguments()
                        {
                            this._parseLocation();
                            var t,
                                e = {};
                            for (t in this._args)
                                this._args.hasOwnProperty(t) && (e[t] = this._args[t]);
                            return e
                        }
                        createSearchString(t)
                        {
                            if (!t)
                                return "";
                            let e,
                                n,
                                i = "";
                            for (e in t)
                                t.hasOwnProperty(e) && (n = t[e], "function" != typeof n && (i.length && (i += "&"), i += e + "=" + decodeURIComponent(n)));
                            return i
                        }
                        parse(t, e)
                        {
                            if (e = e || {}, "string" != typeof t || t.length < 1)
                                return {};
                            const n = t.charAt(0);
                            "?" !== n && "#" !== n || (t = t.substring(1));
                            var i,
                                o,
                                r,
                                s,
                                a = t.split("&"),
                                l = {
                                    true: !0,
                                    false: !1
                                };
                            for (i = a.length - 1; i >= 0; --i)
                                (o = a[i]) && (r = o.indexOf("=")) > 0 && (s = decodeURIComponent(o.substring(r + 1)), l.hasOwnProperty(s) && (s = l[s]), e[o.substring(0, r)] = s);
                            return e
                        }
                        _parseLocation()
                        {
                            var e = t.location;
                            if (this._url !== e.href || !this._args) {
                                this._url = e.href;
                                var n = {};
                                this.parse(e.search, n),
                                this.parse(e.hash, n),
                                this._args = n
                            }
                            return this._args
                        }
                    }
                    ,
                    createEventsListener: () => new p
                };
            Object.keys(y).forEach(t => {
                try {
                    Object.defineProperty(e, t, {
                        value: y[t],
                        writable: !1,
                        configurable: !0,
                        enumerable: !1
                    })
                } catch (e) {
                    _.error(`Error defining LOOPINDEX property ${t}: ${e}`)
                }
            }),
            Object.defineProperties(e, {
                browser: {
                    get: function() {
                        return e.$.extend(!0, {}, v)
                    },
                    configurable: !0
                }
            })
        }(window, window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            if (!(null == t ? void 0 : t.utils))
                throw new Error("More utils: utils object not found");
            class e {
                constructor(t)
                {
                    this._scopes = [],
                    this._options = Object.assign({}, {
                        timeout: 100
                    }, t)
                }
                add(t, e)
                {
                    let n = this.findScope(t);
                    n ? n.state = this._options.update ? this._options.update(n.state, e) : e : n = this.addScope(t, e),
                    n.timeout && !this._options.continuous && (clearTimeout(n.timeout), n.timeout = 0),
                    n.timeout = n.timeout || setTimeout(this.onTimeout.bind(this, n), this._options.timeout)
                }
                remove(t)
                {
                    const e = this.findScopeIndex(t);
                    this._removeScopeAt(e)
                }
                removeAll()
                {
                    for (let t = this._scopes.length; t >= 0; --t)
                        this._removeScopeAt(t);
                    this._scopes.length = 0
                }
                getStateFor(t)
                {
                    const e = this.findScope(t);
                    return null == e ? void 0 : e.state
                }
                _removeScopeAt(t)
                {
                    if (!(t >= 0 && t < this._scopes.length))
                        return null;
                    const e = this._scopes[t];
                    return this._scopes.splice(t, 1), (null == e ? void 0 : e.timeout) && clearTimeout(e.timeout), e
                }
                onTimeout(e)
                {
                    const n = this.findScopeIndex(null == e ? void 0 : e.scope);
                    if (n < 0)
                        return t.logger.warn("debounce timeout: can't find record");
                    e = this._scopes[n],
                    this._scopes.splice(n, 1),
                    this._options.callback(e.scope, e.state)
                }
                addScope(t, e)
                {
                    const n = {
                        scope: t,
                        state: e,
                        timeout: 0
                    };
                    return this._scopes.push(n), n
                }
                findScope(t)
                {
                    const e = this.findScopeIndex(t);
                    return e >= 0 ? this._scopes[e] : null
                }
                findScopeIndex(t)
                {
                    for (let e = this._scopes.length - 1; e >= 0; --e)
                        if (this._options.compare(this._scopes[e].scope, t))
                            return e;
                    return -1
                }
            }
            class n {
                constructor()
                {
                    this._debouncers = new Map
                }
                createDebouncer(t, n)
                {
                    if (!t || this._debouncers.has(t))
                        throw new Error("Bad or existing debouncer name " + t);
                    let i = new e(n);
                    return this._debouncers.set(t, i), i
                }
                getDebouncer(t)
                {
                    var e;
                    return null !== (e = this._debouncers.get(t)) && void 0 !== e ? e : null
                }
                removeDebouncer(t)
                {
                    const e = this._debouncers.get(t);
                    return !!e && (this._debouncers.delete(t), e.removeAll(), !0)
                }
                dispose()
                {
                    try {
                        this._debouncers.forEach(t => {
                            t.removeAll()
                        })
                    } catch (e) {
                        t.logger.error("While disposing debouncer: " + e)
                    } finally {
                        this._debouncers.clear()
                    }
                }
            }
            class i {
                constructor()
                {
                    this._timeoutMap = new Map
                }
                dispose()
                {
                    this.stopAll(),
                    this.clear()
                }
                clear()
                {
                    this._timeoutMap.clear()
                }
                setTimer(t, e, n)
                {
                    const i = "temp-" + Date.now() * Math.random();
                    return this.createTimer(i, {
                        callback: t,
                        timeoutMSecs: e,
                        repeatCount: n,
                        autoDispose: !0
                    }).start()
                }
                createTimer(t, e)
                {
                    if (!t)
                        throw new Error("setTimer requires a timer id");
                    if (this._timeoutMap.has(t))
                        throw new Error(`A timer with the name ${t} already exists`);
                    if (!e.callback)
                        throw new Error(`setTimer ${t}: callback required`);
                    const n = this.upgradeOptions(e),
                        i = new o(n, () => {
                            this._timeoutMap.delete(t)
                        });
                    return this._timeoutMap.set(t, i), i
                }
                startTimer(t, e)
                {
                    var n;
                    const i = this._getTimer(t);
                    return e > 0 && (null == i || i.update({
                        timeoutMSecs: e
                    })), null !== (n = null == i ? void 0 : i.start()) && void 0 !== n ? n : null
                }
                updateTimer(e, n)
                {
                    const i = this._getTimer(e);
                    return i ? i.update(n) : t.logger.error("updte timer: unknown timer id " + e), i
                }
                getTimerData(t)
                {
                    var e;
                    const n = this._getTimer(t);
                    return null !== (e = null == n ? void 0 : n.data) && void 0 !== e ? e : null
                }
                stopAll()
                {
                    this._timeoutMap.forEach((t, e) => this.stopTimer(e))
                }
                stopTimer(t)
                {
                    const e = this._getTimer(t);
                    return null == e || e.stop(), e
                }
                removeTimer(t)
                {
                    const e = this._getTimer(t);
                    return null == e || e.dispose(), Boolean(e)
                }
                elapsed(t)
                {
                    const e = this._getTimer(t);
                    return (null == e ? void 0 : e.elapsed) || 0
                }
                _getTimer(e)
                {
                    var n;
                    const i = this._timeoutMap.get(e);
                    return i || t.logger.error("Missing timeout with id " + e), null !== (n = i) && void 0 !== n ? n : null
                }
                upgradeOptions(e)
                {
                    return t.$.extend({}, {
                        repeatCount: 1,
                        timeoutMSecs: -1,
                        maxTimeSecs: 0,
                        autoDispose: !0
                    }, e)
                }
            }
            i.FOREVER = 999999999;
            class o {
                constructor(e, n)
                {
                    if (this.done = n, this._elapsed = 0, this._callCount = 0, this._startTime = 0, this._stop = null, !e.callback)
                        throw new Error("Timeout constructor: callback required");
                    this._options = t.$.extend({}, e),
                    this._callback = () => {
                        this._elapsed = Date.now() - this._startTime,
                        this._options.maxTimeSecs > 0 && 1e3 * this._options.maxTimeSecs < this._elapsed && this.stop(),
                        this._options.callback(this);
                        const t = this._options.repeatCount;
                        (t <= 0 || ++this._callCount >= t) && (this.stop(), this._options.autoDispose && this.dispose())
                    }
                }
                get data()
                {
                    return this._options.data
                }
                get isRunning()
                {
                    return Boolean(this._stop)
                }
                dispose()
                {
                    if (this.stop(), Object.keys(this._options).forEach(t => delete this._options[t]), this._callback = null, this.done) {
                        const t = this.done;
                        this.done = null,
                        t()
                    }
                }
                start()
                {
                    if (this.isRunning)
                        return this;
                    let t;
                    this.reset();
                    const e = this._options.repeatCount;
                    return (isNaN(e) || "number" != typeof e || e < 0) && (this._options.repeatCount = 1), this._startTime = Date.now(), t = setInterval(this._callback, this._options.timeoutMSecs), this._stop = () => clearInterval(t), this
                }
                reset()
                {
                    return this._elapsed = 0, this._callCount = 0, this.isRunning && (this.stop(), this.start()), this
                }
                stop()
                {
                    if (this._stop) {
                        const t = this._stop;
                        this._stop = null,
                        t()
                    }
                    return this
                }
                update(t)
                {
                    const e = this._options;
                    return t.repeatCount > 0 && (e.repeatCount = t.repeatCount), t.timeoutMSecs >= 0 && (e.timeoutMSecs = t.timeoutMSecs), t.maxTimeSecs >= 0 && (e.maxTimeSecs = t.maxTimeSecs), void 0 !== t.data && (e.data = t.data), "function" == typeof t.callback && (e.callback = t.callback), this
                }
                get elapsed()
                {
                    return this._elapsed
                }
                get isRepeating()
                {
                    return this._options.repeatCount > 0
                }
            }
            class r {
                constructor(t)
                {
                    this._values = [t]
                }
                get value()
                {
                    return this._values[this._values.length - 1]
                }
                pushValue(t)
                {
                    const e = this._values.length;
                    return this._values.push(t), t => {
                        const n = () => (this._values.splice(e, 1), this._values[this._values.length - 1]);
                        return t >= 0 ? (setTimeout(n, t), this.value) : n()
                    }
                }
            }
            class s {
                constructor()
                {
                    this._methods = {},
                    this.configure({})
                }
                configure(t)
                {
                    Object.entries(s._defaultMethods).forEach(([e, n]) => {
                        "function" == typeof t[e] ? this._methods[e] = t[e] : this._methods[e] = n
                    })
                }
                alert(t)
                {
                    return this._methods.alert(t)
                }
                confirm(t)
                {
                    return this._methods.confirm(t)
                }
                prompt(t)
                {
                    return this._methods.prompt(t)
                }
            }
            s._defaultMethods = {
                alert: t => new Promise(e => (window.alert(t.text), e())),
                confirm: t => new Promise(e => e(window.confirm(t.text))),
                prompt: t => new Promise(e => e(window.prompt(t.text, t.defaultValue)))
            };
            const a = {
                createDebouncerManager: () => new n,
                createTimeoutClient: () => new i,
                createStateStack: t => new r(t),
                alertManager: new s
            };
            Object.entries(a).forEach(([e, n]) => {
                t.utils.hasOwnProperty(e) || Object.defineProperty(t.utils, e, {
                    value: n,
                    writable: !1,
                    enumerable: !1
                })
            })
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            if (t.utils.strings && t.utils.compareVersions("1.9.12", t.utils.strings.VERSION) < 1)
                return;
            class e {
                constructor(t=!1)
                {
                    this.greedyToken = t
                }
                diff(t, e, n={})
                {
                    let i = n.callback;
                    "function" == typeof n && (i = n, n = {});
                    let o = this;
                    function r(t) {
                        return i ? (setTimeout((function() {
                            i(t)
                        }), 0), !0) : t
                    }
                    t = this.removeEmpty(this.tokenize(t));
                    let s = (e = this.removeEmpty(this.tokenize(e))).length,
                        a = t.length,
                        l = 1,
                        c = s + a;
                    null != n.maxEditLength && (c = Math.min(c, n.maxEditLength));
                    const u = n.timeout > 0 ? n.timeout : 1 / 0,
                        d = Date.now() + u;
                    let h = [{
                            oldPos: -1,
                            lastComponent: void 0
                        }],
                        g = this.extractCommon(h[0], e, t, 0, n);
                    if (h[0].oldPos + 1 >= a && g + 1 >= s)
                        return r(o.buildValues(h[0].lastComponent, e, t));
                    let m = -1 / 0,
                        f = 1 / 0;
                    function p() {
                        for (let i = Math.max(m, -l); i <= Math.min(f, l); i += 2) {
                            let l,
                                c = h[i - 1],
                                u = h[i + 1];
                            c && (h[i - 1] = void 0);
                            let d = !1;
                            if (u) {
                                const t = u.oldPos - i;
                                d = 0 <= t && t < s
                            }
                            let p = c && c.oldPos + 1 < a;
                            if (d || p) {
                                if (l = !p || d && c.oldPos < u.oldPos ? o.addToPath(u, !0, !1, 0, n) : o.addToPath(c, !1, !0, 1, n), g = o.extractCommon(l, e, t, i, n), l.oldPos + 1 >= a && g + 1 >= s)
                                    return r(o.buildValues(l.lastComponent, e, t));
                                h[i] = l,
                                l.oldPos + 1 >= a && (f = Math.min(f, i - 1)),
                                g + 1 >= s && (m = Math.max(m, i + 1))
                            } else
                                h[i] = void 0
                        }
                        l++
                    }
                    if (i)
                        !function t() {
                            setTimeout((function() {
                                if (l > c || Date.now() > d)
                                    return i([]);
                                p() || t()
                            }), 0)
                        }();
                    else
                        for (; l <= c && Date.now() <= d;) {
                            let t = p();
                            if (t)
                                return t
                        }
                }
                addToPath(t, e, n, i, o)
                {
                    let r = t.lastComponent;
                    return r && !o.oneChangePerToken && r.added === e && r.removed === n ? {
                        oldPos: t.oldPos + i,
                        lastComponent: {
                            count: r.count + 1,
                            added: e,
                            removed: n,
                            previousComponent: r.previousComponent,
                            value: ""
                        }
                    } : {
                        oldPos: t.oldPos + i,
                        lastComponent: {
                            count: 1,
                            added: e,
                            removed: n,
                            previousComponent: r,
                            value: ""
                        }
                    }
                }
                extractCommon(t, e, n, i, o)
                {
                    let r = e.length,
                        s = n.length,
                        a = t.oldPos,
                        l = a - i,
                        c = 0;
                    for (; l + 1 < r && a + 1 < s && this.equals(n[a + 1], e[l + 1], o);)
                        l++,
                        a++,
                        c++,
                        o.oneChangePerToken && (t.lastComponent = {
                            count: 1,
                            previousComponent: t.lastComponent,
                            added: !1,
                            removed: !1
                        });
                    return c && !o.oneChangePerToken && (t.lastComponent = {
                        count: c,
                        previousComponent: t.lastComponent,
                        added: !1,
                        removed: !1
                    }), t.oldPos = a, l
                }
                equals(t, e, n)
                {
                    return n.comparator ? n.comparator(t, e) : t === e || n.ignoreCase && t.toLowerCase() === e.toLowerCase()
                }
                removeEmpty(t)
                {
                    return t.filter(Boolean).join("")
                }
                join(t)
                {
                    return "string" == typeof t ? t : Array.isArray(t) ? t.join("") : ""
                }
                tokenize(t)
                {
                    return Array.from(t)
                }
                buildValues(t, e, n)
                {
                    if (!t)
                        return [];
                    const i = [];
                    let o;
                    for (; t;)
                        i.push(t),
                        o = t.previousComponent,
                        delete t.previousComponent,
                        t = o;
                    i.reverse();
                    let r = 0,
                        s = i.length,
                        a = 0,
                        l = 0;
                    for (; r < s; r++) {
                        let t = i[r];
                        if (t.removed)
                            t.value = this.join(n.slice(l, l + t.count)),
                            l += t.count;
                        else {
                            if (!t.added && this.greedyToken) {
                                let i = e.slice(a, a + t.count).split("");
                                i = i.map((function(t, e) {
                                    let i = n[l + e];
                                    return i.length > t.length ? i : t
                                })),
                                t.value = this.join(i)
                            } else
                                t.value = this.join(e.slice(a, a + t.count));
                            a += t.count,
                            t.added || (l += t.count)
                        }
                    }
                    return i
                }
            }
            const n = {
                strings: new class {
                    constructor()
                    {
                        this.VERSION = "1.9.12"
                    }
                    diffStrings(t, n)
                    {
                        return new e(!0).diff(t, n, {})
                    }
                    addParamsToUrl(t, e)
                    {
                        if (!t)
                            return "";
                        if (!e)
                            return t;
                        const n = Object.entries(e).map(([t, e]) => `${t}=${encodeURIComponent(e)}`).join("&");
                        return [t, t.includes("?") ? "&" : "?", n].join("")
                    }
                    validateEnum(e, n, i)
                    {
                        if (null == e)
                            return i;
                        const o = `Invalid config value ${e}, allowed values: ${n}`;
                        if ("string" != typeof e)
                            return t.logger.warn(o), i;
                        const r = e.trim().toLowerCase();
                        for (let t of n)
                            if (t.trim().toLowerCase() === r)
                                return t;
                        return t.logger.warn(o), i
                    }
                    getRealTextLength(e)
                    {
                        if (!e)
                            return 0;
                        let n = e.length;
                        for (; n && t.utils.strings.isEmptyString(e[n - 1]);)
                            --n;
                        return n
                    }
                    toMap(t, e, n)
                    {
                        const i = {};
                        let o;
                        const r = Boolean(e),
                            s = Boolean(n);
                        let a;
                        for (let l = 0, c = t && t.length || 0; l < c; ++l)
                            a = t[l],
                            null != a && (o = s ? a[n] : a, r ? i[String(a[e])] = o : i[String(a)] = 1);
                        return i
                    }
                    toStringMap(t, e)
                    {
                        const n = {},
                            i = e ? "upper" === e ? t => t.toUpperCase() : t => t.toLowerCase() : null;
                        for (let e = 0, o = t && t.length || 0; e < o; ++e)
                            n[String(i ? i(t[e]) : t[e])] = 1;
                        return n
                    }
                    toStringArray(e, n)
                    {
                        if (!(null == e ? void 0 : e.length))
                            return [];
                        "string" == typeof n && (n = {
                            transform: n
                        });
                        let i,
                            o = "upper" === (null == n ? void 0 : n.transform) ? String.prototype.toUpperCase : "lower" === (null == n ? void 0 : n.transform) ? String.prototype.toLowerCase : null;
                        const r = !1 !== (null == n ? void 0 : n.trim);
                        if ("string" == typeof e)
                            i = e.split(",");
                        else {
                            if (!Array.isArray(e))
                                return t.logger.warn("illegal format of string array"), [];
                            i = e
                        }
                        if (i.forEach((t, e) => {
                            null == t && (t = ""),
                            t = String(t),
                            r && (t = t.trim()),
                            o && (t = o.apply(t)),
                            i[e] = t
                        }), null == n ? void 0 : n.unique) {
                            const t = new Set(i);
                            return Array.from(t.values())
                        }
                        return i
                    }
                    padString(t, e, n, i)
                    {
                        let o;
                        o = null == t ? "" : String(t);
                        const r = (n = String(n)).length,
                            s = [o];
                        for (let t = o.length; t < e; t += r)
                            i ? s.push(n) : s.unshift(n);
                        return s.join("")
                    }
                    padNumber(e, n)
                    {
                        return t.utils.strings.padString(e, n, "0", !1)
                    }
                    randomString(t)
                    {
                        (!t || isNaN(t) || t < 1) && (t = 6);
                        const e = String((1 + Math.random()) * Date.now());
                        let n = btoa(e).replace(/[^a-z]/gi, "");
                        for (; n.length < t;)
                            n += n;
                        return n.length > t && (n = n.substring(n.length - t)), n
                    }
                    merge(t, ...e)
                    {
                        if (!e || !e.length)
                            return [];
                        const {unique: n=!1, allowEmpty: i=!0, separator: o=""} = t,
                            r = Object.assign(Object.assign({}, t), {
                                unique: !1
                            }),
                            s = [];
                        for (let t = 0, n = e.length; t < n; ++t) {
                            const n = e[t];
                            if ("string" === typeof n)
                                (i || n.length) && (o && n.includes(o) ? s.push(...this.merge(r, n.split(o))) : s.push(n));
                            else if (Array.isArray(n))
                                for (let t = 0; t < n.length; t++) {
                                    const e = n[t];
                                    s.push(...this.merge(r, e))
                                }
                            else
                                null != n && s.push(String(n))
                        }
                        if (n) {
                            const t = new Set(s);
                            return Array.from(t.values())
                        }
                        return s
                    }
                    htmlToText(e)
                    {
                        if (!(null == e ? void 0 : e.length))
                            return "";
                        const n = e.replace(/<[^>]*>/g, " ").replace(/[ \t]{2}/g, " "),
                            i = null === window || void 0 === window ? void 0 : window.document;
                        if (!i)
                            return t.logger.warn("HTML Entity conversion is not implemented outside the browser"), n;
                        this._htmlConvertElement || (this._htmlConvertElement = i.createElement("div"));
                        try {
                            return this._htmlConvertElement.innerHTML = n, this._htmlConvertElement.textContent
                        } catch (i) {
                            return t.logger.warn(`Error converting HTML Entities in ${n} (original: ${e})`), n
                        }
                    }
                    joinPath(...t)
                    {
                        const e = t.length - 1,
                            n = t.map((t, n) => t ? (0 !== n && (t = t.replace(/^[\s\/]+/, "")), n < e && (t = t.replace(/[\s\/]+$/, "")), t) : "").filter(Boolean).join("/").split("/"),
                            i = [];
                        for (let t = 0, e = n.length - 1; t <= e; t++) {
                            const e = n[t];
                            "." !== e && (".." === e && i.length > 0 ? i.length-- : i.push(e))
                        }
                        return i.join("/")
                    }
                    isEmptyString(t)
                    {
                        let e,
                            n = (null == t ? void 0 : t.length) || 0;
                        for (; n > 0;)
                            if (e = t[--n], e && "​" !== e && "\ufeff" !== e)
                                return !1;
                        return !0
                    }
                    getEffectiveStringLength(t)
                    {
                        let e,
                            n = t && t.length || 0,
                            i = 0;
                        for (; n > 0;)
                            e = t.charCodeAt(--n),
                            0 !== e && 8203 !== e && 65279 !== e && ++i;
                        return i
                    }
                    getEffectiveStringIndex(t, e)
                    {
                        if (isNaN(e) || e < 0)
                            return 0;
                        let n,
                            i = t && t.length || 0;
                        if (e >= i)
                            return i;
                        let o = 0;
                        for (let r = 0; r < i; ++r)
                            if (n = t.charCodeAt(r), 0 !== n && 8203 !== n && 65279 !== n && ++o > e)
                                return r;
                        return i
                    }
                }
            };
            Object.assign(t.utils, n)
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            function e(t, e, n) {
                return t < e ? e : t > n ? n : t
            }
            function n(t) {
                return Math.round(e(t, 0, 255))
            }
            function i(t) {
                return e(t, 0, 1)
            }
            function o(t) {
                const e = s(t);
                return isNaN(e) ? n(Number(t)) : Math.round(e)
            }
            function r(t) {
                const e = Math.round(t).toString(16).toUpperCase();
                return e.length < 2 ? "0" + e : e
            }
            function s(t) {
                const e = t.match(/^([^%]+)%$/);
                return e ? Number(e[1]) / 100 : NaN
            }
            function a(t, e=1) {
                const n = s(t);
                return isNaN(n) ? i(Number(t) / e) : i(n)
            }
            function l(t, e, n) {
                return n < 0 ? n += 1 : n > 1 && (n -= 1), 6 * n < 1 ? t + (e - t) * n * 6 : 2 * n < 1 ? e : 3 * n < 2 ? t + (e - t) * (2 / 3 - n) * 6 : t
            }
            function c(t) {
                return t < 48 ? NaN : t <= 57 ? t - 48 : t < 97 ? NaN : t <= 102 ? t - 87 : NaN
            }
            function u(t) {
                const e = t.trim().toLowerCase();
                if ("#" === e[0])
                    return function(t) {
                        const e = 4 === t.length || 5 === t.length,
                            n = 7 === t.length || 9 === t.length;
                        if (!e && !n)
                            return null;
                        const i = e ? 1 : 2,
                            o = [0, 0, 0, 255],
                            r = 5 === t.length || 9 === t.length ? 4 : 3;
                        for (let n = 0; n < r; n++) {
                            const r = c(t.charCodeAt(n * i + 1));
                            if (o[n] = 16 * r + (e ? r : c(t.charCodeAt(n * i + 2))), Number.isNaN(o[n]))
                                return null
                        }
                        return o[3] /= 255, o
                    }(e);
                const i = e.indexOf("("),
                    r = e.indexOf(")"),
                    u = -1 === r ? e.length : r;
                if (-1 !== i && (u + 1 === e.length || u === e.length)) {
                    const t = e.substring(0, i),
                        r = /\s|,|\//,
                        c = e.substring(i + 1, u).split(r).filter(Boolean),
                        d = 4 === c.length ? a(c.pop()) : 1;
                    if (3 !== c.length)
                        return null;
                    let h;
                    switch (t) {
                    case "rgba":
                    case "rgb":
                        return h = [...c.map(o), d], h.some(isNaN) ? null : h;
                    case "hsla":
                    case "hsl":
                        const t = (function(t) {
                            if (t.endsWith("deg"))
                                return Number(t.slice(0, -3));
                            if (t.endsWith("grad"))
                                return 360 * Number(t.slice(0, -4)) / 400;
                            if (t.endsWith("rad"))
                                return 360 * Number(t.slice(0, -3)) / (2 * Math.PI);
                            if (t.endsWith("turn"))
                                return 360 * Number(t.slice(0, -4));
                            {
                                const e = s(t);
                                return isNaN(e) ? Number(t) : 360 * e % 360
                            }
                        }(c[0]) % 360 + 360) % 360 / 360;
                        if (isNaN(t))
                            return null;
                        const e = a(c[1], 100);
                        if (isNaN(e))
                            return null;
                        const i = a(c[2], 100);
                        if (isNaN(i))
                            return null;
                        const r = i <= .5 ? i * (e + 1) : i + e - i * e,
                            u = 2 * i - r;
                        return [n(255 * l(u, r, t + 1 / 3)), n(255 * l(u, r, t)), n(255 * l(u, r, t - 1 / 3)), d];
                    default:
                        return null
                    }
                }
                return null
            }
            class d {
                constructor(t)
                {
                    this._strings = new Map,
                    this.loadCSSString(t)
                }
                get isValid()
                {
                    return Boolean(this._rgb || this._hsl)
                }
                equals(t)
                {
                    if (!this.isValid)
                        return !1;
                    try {
                        const n = "string" == typeof t ? new d(t) : t;
                        if (!n.isValid)
                            return !1;
                        function e(t, e) {
                            return Math.abs(t - e) < 1
                        }
                        const i = n.rgb,
                            o = this.rgb;
                        return e(i.a, o.a) && e(i.b, o.b) && e(i.g, o.b) && e(i.r, o.r)
                    } catch (t) {
                        return !1
                    }
                }
                loadCSSString(t)
                {
                    if (!t)
                        return this;
                    this._strings.clear();
                    const e = u(t);
                    return e ? (this._rgb = {
                        r: e[0],
                        g: e[1],
                        b: e[2],
                        a: e[3]
                    }, this) : (this._rgb = void 0, this._hsl = void 0, this)
                }
                loadRGB(t)
                {
                    return t && (this._strings.clear(), this._rgb = {
                        r: n(t.r) || 0,
                        g: n(t.g) || 0,
                        b: n(t.b) || 0,
                        a: i(t.a) || 0
                    }, this._hsl = void 0), this
                }
                loadHSL(t)
                {
                    return t && (this._strings.clear(), this._hsl = {
                        a: i(t.a),
                        h: i(t.h),
                        s: i(t.s),
                        l: i(t.l)
                    }, this._rgb = void 0), this
                }
                get rgb()
                {
                    if (!this._rgb) {
                        if (!this._hsl)
                            return {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0
                            };
                        this._rgb = function({h: t, s: e, l: n, a: i}) {
                            let o,
                                r,
                                s;
                            if (0 == e)
                                o = r = s = n;
                            else {
                                function a(t, e, n) {
                                    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
                                }
                                const i = n < .5 ? n * (1 + e) : n + e - n * e,
                                    l = 2 * n - i;
                                o = a(l, i, t + 1 / 3),
                                r = a(l, i, t),
                                s = a(l, i, t - 1 / 3)
                            }
                            return {
                                r: 255 * o,
                                g: 255 * r,
                                b: 255 * s,
                                a: i
                            }
                        }(this._hsl)
                    }
                    return Object.assign({}, this._rgb)
                }
                get hsl()
                {
                    if (!this._hsl) {
                        if (!this._rgb)
                            return {
                                h: 0,
                                s: 0,
                                l: 0,
                                a: 0
                            };
                        this._hsl = function({r: t, g: e, b: n, a: i}) {
                            t /= 255,
                            e /= 255,
                            n /= 255;
                            const o = Math.max(t, e, n),
                                r = Math.min(t, e, n);
                            let s,
                                a,
                                l = (o + r) / 2;
                            if (o == r)
                                s = a = 0;
                            else {
                                const i = o - r;
                                a = l > .5 ? i / (2 - o - r) : i / (o + r),
                                s = o === t ? (e - n) / i + (e < n ? 6 : 0) : o === e ? (n - t) / i + 2 : (t - e) / i + 4,
                                s /= 6
                            }
                            return {
                                h: s,
                                s: a,
                                l: l,
                                a: i
                            }
                        }(this._rgb)
                    }
                    return Object.assign({}, this._hsl)
                }
                toCSSString(e)
                {
                    if (this._strings.has(e))
                        return this._strings.get(e);
                    function n(t) {
                        return t.toFixed(2).replace(/0+$/, "").replace(/\.$/, "")
                    }
                    let i;
                    switch (e) {
                    case "hex":
                        i = ["#", r((o = this.rgb).r), r(o.g), r(o.b), o.a < 1 ? r(Math.round(255 * o.a)) : ""].join("");
                        break;
                    case "hsl":
                        const s = this.hsl;
                        i = `hsl(${n(360 * s.h)} ${n(100 * s.s)} ${n(100 * s.l)}${1 === s.a ? "" : " / " + n(s.a)})`;
                        break;
                    case "rgb":
                        const a = this.rgb;
                        i = a.a < 1 ? `rgba(${n(a.r)} ${n(a.g)} ${n(a.b)} / ${n(a.a)})` : `rgb(${n(a.r)} ${n(a.g)} ${n(a.b)})`;
                        break;
                    default:
                        return t.logger.warn("Unknown css string type " + e), ""
                    }
                    var o;
                    return this._strings.set(e, i), i
                }
                adjust(t)
                {
                    return t < 0 ? this.darken(-t) : this.lighten(t)
                }
                darken(t)
                {
                    const e = new d;
                    t = i(t);
                    const n = this.hsl,
                        o = n.l - t,
                        r = i(-o);
                    return e.loadHSL({
                        h: n.h,
                        s: i(n.s + r),
                        l: i(o),
                        a: n.a
                    })
                }
                lighten(t)
                {
                    const e = new d;
                    t = i(t);
                    const n = this.hsl,
                        o = n.l + t,
                        r = i(o - 1);
                    return e.loadHSL({
                        h: n.h,
                        s: i(n.s - r),
                        l: i(o),
                        a: n.a
                    })
                }
            }
            const h = {
                createLIColor: t => new d(t)
            };
            Object.assign(t.utils, h)
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            if (t.utils.dom && t.utils.compareVersions("1.9.12", t.utils.dom.VERSION) < 1)
                return;
            if (!t.utils.strings)
                return t.logger.error("dom utils requires string utils");
            const e = t.$,
                n = function() {
                    const t = function(...t) {
                        return 1
                    };
                    return t.acceptNode = function(...t) {
                        return 1
                    }, t
                }();
            class i {
                constructor()
                {
                    this.VERSION = "1.9.12",
                    this._matchSelector = null
                }
                getNodeWindow(t)
                {
                    var e,
                        n;
                    return null !== (n = null === (e = null == t ? void 0 : t.ownerDocument) || void 0 === e ? void 0 : e.defaultView) && void 0 !== n ? n : null
                }
                findEmptySVG(t, n)
                {
                    var i;
                    return null !== (i = e(n).find(`svg[data-loopindex-id='${t}'][data-li-placeholder='true']`)[0]) && void 0 !== i ? i : null
                }
                getEmptySVG(e, n, i)
                {
                    e >= 0 || (t.logger.warn("getEmptySVG: Invalid width " + e), e = 0),
                    n >= 0 || (t.logger.warn("getEmptySVG: Invalid height " + n), n = 0);
                    const o = e / 2,
                        r = n / 2;
                    return `<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="${e}" height="${n}"\nviewBox="0 0 ${e} ${n}" xml:space="preserve" data-loopindex-id="${i}" data-li-placeholder="true">\n<g transform="matrix(1 0 0 1 ${o} ${r})" id="6ff8975c-0c66-4e85-b9c0-cb50ce01e9fb"  >\n<rect style="stroke: none; stroke-width: 1; fill: rgb(255,255,255); fill-rule: nonzero; opacity: 1; visibility: hidden;" \nx="-${o}" y="-${r}" rx="0" ry="0" width="${e}" height="${n}" />\n</g></svg>`
                }
                getNodeIframe(t)
                {
                    var e;
                    const n = this.getNodeWindow(t);
                    return null !== (e = null == n ? void 0 : n.frameElement) && void 0 !== e ? e : null
                }
                isScrollable(t)
                {
                    if (1 !== (null == t ? void 0 : t.nodeType))
                        return !1;
                    const e = t;
                    return e.scrollHeight > e.clientHeight
                }
                findScrollParent(t)
                {
                    const e = null == t ? void 0 : t.parentNode;
                    return e ? this.isScrollable(e) ? e : this.findScrollParent(e) : null
                }
                getScrollParents(t)
                {
                    const e = this.findScrollParent(t);
                    if (e)
                        return [e, ...this.getScrollParents(e)];
                    const n = this.getNodeIframe(t);
                    return n ? this.getScrollParents(n) : []
                }
                saveScrollPosition(t)
                {
                    const e = (this.isScrollable(t) ? [t] : []).concat(this.getScrollParents(t)).map(t => ({
                        el: t,
                        scrollY: t.scrollTop
                    }));
                    return () => {
                        e.forEach(t => {
                            t.el.scrollTop = t.scrollY
                        })
                    }
                }
                getRangeAnchors(t)
                {
                    var e;
                    const n = t.startContainer;
                    let i = null,
                        o = null,
                        r = null,
                        s = null;
                    3 === n.nodeType ? (i = n, 0 === t.startOffset && (r = i.previousSibling)) : 1 === n.nodeType && (i = n.childNodes[t.startOffset], r = null !== (e = n.childNodes[t.startOffset - 1]) && void 0 !== e ? e : null);
                    const a = t.endContainer;
                    for (3 === a.nodeType ? (o = a, t.endOffset >= a.length && (s = a.nextSibling)) : 1 === a.nodeType && (o = a.childNodes[t.endOffset - 1] || a, s = null == o ? void 0 : o.nextSibling); this.isEmptyTextNode(s);)
                        s = s.nextSibling;
                    for (; this.isEmptyTextNode(r);)
                        r = r.previousSibling;
                    return {
                        first: i,
                        last: o !== i ? o : null,
                        prev: r,
                        next: s
                    }
                }
                getIntersectingNodes(t, ...e)
                {
                    if (!(null == t ? void 0 : t.commonAncestorContainer))
                        return [];
                    const n = [];
                    for (let i = 0; i < e.length; i++) {
                        const o = e[i];
                        (null == o ? void 0 : o.nodeType) && t.intersectsNode(o) && n.push(o)
                    }
                    return n
                }
                elementToHtml({el: t, xml: n, withRoot: i, encode: o})
                {
                    const r = null == t ? void 0 : t.nodeType;
                    if (!r)
                        return "";
                    if (3 === r)
                        return o ? o(t.data) : t.data;
                    if (1 !== r)
                        return String(t.nodeValue);
                    const s = new Map;
                    let a,
                        l = 0;
                    function c(t, e) {
                        if (s.has(t))
                            return s.get(t);
                        {
                            const t = "‼⁌Ω" + String(l++).padStart(5, "0");
                            return s.set(t, e), t
                        }
                    }
                    if (o) {
                        const n = e(t).find("*").toArray();
                        i && n.push(t),
                        n.forEach(t => {
                            var e;
                            for (let n = (null === (e = t.attributes) || void 0 === e ? void 0 : e.length) - 1; n >= 0; --n) {
                                const e = t.attributes.item(n),
                                    i = null == e ? void 0 : e.value;
                                if (i) {
                                    const t = o(i);
                                    t !== i && (e.value = c(i, t))
                                }
                            }
                        }),
                        this.forAllTextChildren(t, t => {
                            const e = t.data,
                                n = o(e);
                            e !== n && (t.data = c(e, n))
                        })
                    }
                    if (n) {
                        const e = new XMLSerializer,
                            n = t => {
                                let n = e.serializeToString(t);
                                return 1 !== t.nodeType || t.getAttribute("xmlns") || (n = n.replace(/\s*xmlns="[^"]+"/, "")), n
                            };
                        i && (a = n(t));
                        const o = [];
                        for (let e = t.firstChild; e; e = e.nextSibling)
                            3 === e.nodeType ? o.push(e.data) : o.push(n(e));
                        a = o.join("")
                    } else
                        a = i ? t.outerHTML : t.innerHTML;
                    return s.forEach((t, e) => {
                        a = a.replace(new RegExp(e, "g"), t)
                    }), a
                }
                attachCBToLink(e, n, i)
                {
                    if (!e || !n || "function" != typeof i)
                        return void t.logger.warn("attachCBToElement: bad input");
                    const o = function() {
                        e.removeEventListener("load", o),
                        e.removeEventListener("error", r),
                        i({
                            url: n
                        })
                    };
                    function r(t) {
                        e.removeEventListener("load", o),
                        e.removeEventListener("error", r),
                        i({
                            url: n,
                            error: String(t) || "error"
                        })
                    }
                    "function" == typeof e.addEventListener ? (e.addEventListener("load", o), e.addEventListener("error", r)) : (e.onload = function() {
                        o()
                    }, e.onerror = function(t) {
                        r(t)
                    })
                }
                getElementOwnStyle(t, e)
                {
                    var n;
                    const i = this.toElement(t),
                        o = null === (n = null == i ? void 0 : i.style) || void 0 === n ? void 0 : n[e];
                    return null == o ? null : o
                }
                getElementOwnIntStyle(t, e)
                {
                    const n = this.getElementOwnStyle(t, e);
                    return null === n ? NaN : parseInt(n)
                }
                getElementOwnFloatStyle(t, e)
                {
                    const n = this.getElementOwnStyle(t, e);
                    return null === n ? NaN : parseFloat(n)
                }
                static myNormalizeNode(t)
                {
                    if (!t || 1 !== t.nodeType)
                        return;
                    let e = t.firstChild;
                    for (; e;) {
                        if (1 === e.nodeType)
                            i.myNormalizeNode(e);
                        else if (3 == e.nodeType) {
                            let n;
                            for (; (n = e.nextSibling) && 3 == n.nodeType;) {
                                const i = n.nodeValue;
                                i && (e.nodeValue = e.nodeValue + i),
                                t.removeChild(n)
                            }
                        }
                        e = e.nextSibling
                    }
                }
                getPositioningParent(t)
                {
                    let e,
                        n = this.toJQuery(t),
                        i = n;
                    for (; (n = n.parent()).length && n[0].ownerDocument && (i = n, e = i.css("position"), "relative" !== e && "absolute" !== e && "fixed" !== e);)
                        ;
                    return i
                }
                addScriptToDocument(e, n)
                {
                    n = n || window.document;
                    const i = t.utils.strings.toStringArray(e),
                        o = {
                            ok: !0,
                            failed: [],
                            loaded: []
                        };
                    return new Promise(r => {
                        const s = i => {
                            if (!(null == i ? void 0 : i.length))
                                return r(o);
                            const a = i[0];
                            try {
                                if (i = i.slice(1), !a)
                                    return t.logger.warn("null script found in addScriptToDocument input"), s(i);
                                const e = n.createElement("script");
                                e.setAttribute("type", "text/javascript"),
                                this.attachCBToLink(e, a, e => {
                                    e.error ? (o.ok = !1, o.failed.push({
                                        url: a,
                                        error: e.error
                                    }), t.logger.error(`Error loading script ${a}: ${e.error}`)) : o.loaded.push(a),
                                    s(i)
                                }),
                                e.setAttribute("src", a),
                                document.head.appendChild(e)
                            } catch (n) {
                                t.logger.error(`Exception While loading script ${e}\n${n}`),
                                o.ok = !1,
                                o.failed.push({
                                    url: a,
                                    error: String(n)
                                }),
                                r(o)
                            }
                        };
                        s(i)
                    }).then(t => t)
                }
                get NodeIteratorUniversalFunction()
                {
                    return n
                }
                isContentEditable(t, e, n)
                {
                    let i;
                    for (let n = t && t.parentNode; n && n !== e; n = n.parentNode)
                        if (1 === n.nodeType && (i = n.getAttribute("contenteditable"), i)) {
                            if (i = i.toLowerCase(), "true" === i)
                                return !0;
                            if ("false" === i)
                                return !1
                        }
                    return n
                }
                createTreeWalker(e, i, o)
                {
                    const r = e && e.ownerDocument;
                    if (!r)
                        return null;
                    let s = o ? function() {
                        const t = t => o(t);
                        return t.acceptNode = () => 1, t
                    }() : t.browser.msie ? n : null;
                    return r.createTreeWalker(e, i, s, !1)
                }
                createNodeIterator(e, i, o)
                {
                    const r = e && e.ownerDocument;
                    if (!r)
                        return null;
                    let s = o ? function() {
                        const t = t => o(t);
                        return t["]acceptNode"] = () => 1, t
                    }() : t.browser.msie ? n : null;
                    return r.createNodeIterator(e, i, s, !1)
                }
                getNodeIndex(t)
                {
                    if (!t)
                        return -1;
                    let e = 0;
                    for (; t = t.previousSibling;)
                        ++e;
                    return e
                }
                insertNodeAt(t, e, n)
                {
                    return !(!t || !e || 1 !== e.nodeType || n < 0) && (e.insertBefore(t, e.childNodes[n]), !0)
                }
                normalizeNode(t)
                {
                    return t ? "function" == typeof t.normalize ? (t.normalize(), t) : (i.myNormalizeNode(t), t) : null
                }
                isEmptyTextNode(e)
                {
                    if (3 !== (null == e ? void 0 : e.nodeType))
                        return !1;
                    const n = e;
                    return 0 === n.length || t.utils.strings.isEmptyString(n.nodeValue)
                }
                getNodeLength(t)
                {
                    const e = t && t.nodeType;
                    return 1 === e ? t.childNodes.length : 3 === e ? t.length : 0
                }
                getNodeTextContent(t)
                {
                    return e(t).text()
                }
                isOnlyChild(t)
                {
                    const e = t && t.parentNode;
                    return Boolean(e && e.firstChild === t && e.lastChild === t)
                }
                insertAfter(t, e, n)
                {
                    return t ? (n = n || e && e.parentNode, e && e.parentNode !== n && (e = null), n ? e ? n.insertBefore(t, e.nextSibling) : n.insertBefore(t, n.firstChild) : void 0) : null
                }
                contents(t)
                {
                    return e.makeArray(e(t).contents())
                }
                extractContent(t)
                {
                    for (var e, n = document.createDocumentFragment(); e = t.firstChild;)
                        n.appendChild(e);
                    return n
                }
                toElement(t)
                {
                    return t && "object" == typeof t ? t[0] && "string" == typeof t.jquery ? t[0] : 1 === t.nodeType ? t : null : null
                }
                toNode(t)
                {
                    return t && "object" == typeof t ? t[0] && "string" == typeof t.jquery ? t[0] : 1 === t.nodeType || 3 === t.nodeType ? t : null : null
                }
                toJQuery(e, n=!1)
                {
                    if (!e)
                        return t.$("");
                    let i = e;
                    if (!(i instanceof t.$))
                        try {
                            i = t.$(e)
                        } catch (e) {
                            return t.$("")
                        }
                    return !n && i.length > 1 && (i = i.eq(0)), i
                }
                getRealTextLength(e)
                {
                    return e && e.data ? t.utils.strings.getRealTextLength(e.data) : 0
                }
                isDescendantOf(e, n)
                {
                    var i;
                    let o = this.toNode(e);
                    if (!n || !o)
                        return !1;
                    const r = "string" == typeof n && n;
                    let s = null;
                    if (!r)
                        if (s = this.toElement(n), 9 === (null == s ? void 0 : s.nodeType))
                            s = s.body;
                        else if (1 !== (null == s ? void 0 : s.nodeType))
                            return !1;
                    try {
                        for (; o && 1 === (null === (i = o.parentNode) || void 0 === i ? void 0 : i.nodeType);) {
                            if (r) {
                                if (t.utils.dom.matchesSelector(o.parentNode, r))
                                    return !0
                            } else if (o.parentNode === s)
                                return !0;
                            o = o.parentNode
                        }
                    } catch (t) {}
                    return !1
                }
                clearNodeBackgroundImage(t)
                {
                    t && t.style && t.style["background-image"] && (t.style["background-image"] = null)
                }
                getElementPageOffset(t, e)
                {
                    if (!t || !t.getBoundingClientRect)
                        return {
                            top: 0,
                            left: 0
                        };
                    const n = t.getBoundingClientRect(),
                        i = t.ownerDocument,
                        o = i.defaultView,
                        r = i.body,
                        s = i.documentElement,
                        a = o.pageYOffset || s.scrollTop || o.scrollY || r.scrollTop || 0,
                        l = o.pageXOffset || s.scrollLeft || o.scrollX || r.scrollLeft || 0,
                        c = s.clientTop || r.clientTop || 0,
                        u = s.clientLeft || r.clientLeft || 0,
                        d = n.top + a - c,
                        h = n.left + l - u,
                        g = {
                            top: Math.round(d),
                            left: Math.round(h)
                        };
                    return e && (g.top += r.scrollTop || 0, g.left += r.scrollLeft || 0), g
                }
                compareNodePosition(t, e)
                {
                    if (t === e)
                        return 0;
                    var n = t.compareDocumentPosition(e);
                    return 4 & n || 8 & n ? -1 : 1
                }
                forAllTextChildren(t, e)
                {
                    if (t && e && 1 === t.nodeType)
                        for (let n = 0, i = t.firstChild, o = i && i.nextSibling; i; ++n, i = o, o = i && i.nextSibling)
                            if (1 === i.nodeType)
                                this.forAllTextChildren(i, e);
                            else if (3 === i.nodeType) {
                                if (!1 === e(i, n))
                                    return
                            }
                }
                getFirstNodeInRange(e)
                {
                    const n = e && e.startContainer;
                    if (!n)
                        return null;
                    if (3 === n.nodeType)
                        return n;
                    var i = this.getNthChild(n, e.startOffset);
                    if (i)
                        return i;
                    const o = t.utils.dom.createNodeIterator(n, NodeFilter.SHOW_TEXT || NodeFilter.SHOW_ELEMENT);
                    return null == o ? void 0 : o.nextNode()
                }
                getLastNodeInRange(e)
                {
                    const n = e && e.endContainer;
                    if (!n)
                        return null;
                    if (3 === n.nodeType)
                        return n;
                    var i = this.getNthChild(n, e.endOffset - 1);
                    if (i)
                        return i;
                    const o = t.utils.dom.createNodeIterator(n, NodeFilter.SHOW_TEXT || NodeFilter.SHOW_ELEMENT);
                    return null == o ? void 0 : o.previousNode()
                }
                hasTextSelection(t)
                {
                    if (!t || t.collapsed)
                        return !1;
                    if (3 === t.startContainer.nodeType && t.startOffset < t.startContainer.length)
                        return !0;
                    if (3 === t.endContainer.nodeType && t.endOffset < t.endContainer.length)
                        return !0;
                    let e = !1;
                    return this.walkRange(t, (t, n) => !(3 === t.nodeType && t.length > 0) || (e = !0, !1)), e
                }
                getNthChild(t, e)
                {
                    if (!t || 1 !== t.nodeType)
                        return null;
                    for (let n = t.firstChild; n && e >= 0; n = n.nextSibling, --e)
                        if (0 === e)
                            return n;
                    return null
                }
                getSelectedTextNodes(t)
                {
                    if (!t || t.collapsed)
                        return [];
                    const e = [];
                    return this.walkRange(t, (t, n) => {
                        if (3 === t.nodeType) {
                            const i = this.processTextNode(t, n);
                            i && e.push(i)
                        }
                        return !0
                    }), e
                }
                extractTextNode(t)
                {
                    if (!t || !t.node)
                        return null;
                    if (!t.partial)
                        return t.node;
                    let e = t.node;
                    return t.end < e.length && e.splitText(t.end), t.start > 0 && (e = e.splitText(t.start)), e
                }
                extractInlineNode(e)
                {
                    let n = null == e ? void 0 : e.node;
                    if (3 !== (null == n ? void 0 : n.nodeType))
                        return t.logger.warn("extractInlinecontent: null or not text node"), null;
                    if (!e.partial)
                        return n;
                    const o = (e => {
                        for (; e.parentNode && i.INLINE_RE.test(t.$(e.parentNode).css("display"));)
                            e = e.parentNode;
                        return e
                    })(n);
                    if (o === n)
                        return this.extractTextNode(e);
                    let r = o;
                    if (e.end < n.length) {
                        r = this.splitNode(r, n, e.end);
                        let t = r.lastChild;
                        for (; t && 1 === t.nodeType;)
                            t = t.lastChild;
                        n = 3 === (null == t ? void 0 : t.nodeType) ? t : null
                    }
                    return e.start > 0 && n && this.splitNode(r, n, e.start), r
                }
                splitNode(e, n, i)
                {
                    if (0 === i && (n === e || n === e.firstChild))
                        return e;
                    if (i >= t.utils.dom.getNodeLength(n) && (n === e || n === e.lastChild))
                        return e;
                    const o = e.parentNode,
                        r = t.utils.dom.getNodeIndex(e),
                        s = n.ownerDocument.createRange();
                    s.setStart(o, r),
                    s.setEnd(n, i);
                    const a = s.extractContents();
                    return o.insertBefore(a, e), e.previousSibling || e
                }
                walkRange(e, n)
                {
                    if (!e || e.collapsed)
                        return;
                    let i;
                    const o = this.getFirstNodeInRange(e),
                        r = this.getLastNodeInRange(e);
                    if (!o || !r)
                        return;
                    let s = !1,
                        a = !1;
                    const l = t.utils.dom.createNodeIterator(e.commonAncestorContainer, NodeFilter.SHOW_ALL);
                    if (l)
                        for (; (i = l.nextNode()) && (!a || t.utils.dom.isDescendantOf(i, r));) {
                            if (!s) {
                                if (i != o)
                                    continue;
                                s = !0
                            }
                            if (!n(i, e))
                                return;
                            i === r && (a = !0)
                        }
                }
                processTextNode(t, e)
                {
                    let n;
                    if (!t || 3 !== t.nodeType || !(n = t.length))
                        return null;
                    const i = {
                        node: t,
                        start: 0,
                        end: n,
                        partial: !1
                    };
                    if (t === e.startContainer && e.startOffset > 0) {
                        if (e.startOffset >= n)
                            return null;
                        i.partial = !0,
                        i.start = e.startOffset
                    }
                    return t === e.endContainer && e.endOffset < n && (i.partial = !0, i.end = e.endOffset), i
                }
                hasClass(t, e)
                {
                    if (!t || 1 !== t.nodeType)
                        return !1;
                    const n = t,
                        i = n.classList || n.className && n.className.split(/\s/);
                    if (i && i.length)
                        for (let t = i.length - 1; t >= 0; --t)
                            if (i[t] === e)
                                return !0;
                    return !1
                }
                wrapElement(n, i)
                {
                    if (!n)
                        return {
                            $element: e()
                        };
                    if ("string" == typeof n)
                        try {
                            return {
                                $element: e(i.createElement("div")).html(n),
                                isString: !0
                            }
                        } catch (i) {
                            return t.logger.error(`wrapElement ${n}: ${i}`), {
                                $element: e()
                            }
                        }
                    return {
                        $element: t.utils.dom.toJQuery(n)
                    }
                }
                getScrollParent(t)
                {
                    const n = e(t.node),
                        i = n.css("position"),
                        o = "absolute" === i,
                        r = t.hidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                        s = n.parents().filter((function() {
                            const t = e(this);
                            return (!o || "static" !== t.css("position")) && r.test(t.css("overflow") + t.css("overflow-y") + t.css("overflow-x"))
                        })).eq(0);
                    return "fixed" !== i && s.length ? s[0] : n[0].ownerDocument || document
                }
                matchesSelector(t, n)
                {
                    if (!t || 1 !== t.nodeType || !n)
                        return !1;
                    if (!this._matchSelector) {
                        const n = t;
                        let i;
                        i = "function" == typeof n.matches ? (t, e) => t.matches(e) : "function" == typeof n.msMatchesSelector ? (t, e) => t.msMatchesSelector(e) : "function" == typeof n.webkitMatchesSelector ? (t, e) => t.webkitMatchesSelector(e) : (t, n) => e(t).is(n),
                        this._matchSelector = i
                    }
                    return this._matchSelector(t, n)
                }
            }
            i.INLINE_RE = /inline/i;
            const o = {
                dom: new i
            };
            Object.assign(t.utils, o)
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            const e = t.$;
            if (t.utils.pluginUtils && t.utils.compareVersions("1.9.12", t.utils.pluginUtils.VERSION) < 1)
                return;
            class n {
                constructor(t, n)
                {
                    try {
                        const i = e(t),
                            o = i.filter("svg");
                        let r;
                        if (r = o.length ? o.first() : i.find("svg").first(), !(null == r ? void 0 : r.length))
                            throw new Error("Failed to find svg element");
                        ["fill"].forEach(t => {
                            r.find("path").each((e, n) => {
                                const i = n.getAttribute(t);
                                i && (n.style.fill = i)
                            })
                        }),
                        n && r.attr(n),
                        this._html = r[0].outerHTML
                    } catch (e) {
                        throw new Error(`Error creating svg from ${t}: ${e}`)
                    }
                }
                get html()
                {
                    return this._html
                }
                get svg()
                {
                    return e(this._html)[0]
                }
                setAttributes({selector: t, attrs: n, className: i})
                {
                    if (!this._html)
                        return this;
                    const o = e(this._html),
                        r = t ? o.find(t) : o;
                    return n && r.attr(n), i && r.addClass(i), this._html = o[0].outerHTML, this
                }
            }
            class i {
                constructor()
                {
                    this._cache = new Map
                }
                async loadIcon(t, e)
                {
                    const i = this._cache.get(t);
                    let o = null;
                    return o = i ? new n(i) : await this._loadIcon(t), o ? e ? o.setAttributes({
                        attrs: {
                            "data-loopindex-id": e
                        }
                    }) : o : null
                }
                getByPath(t, e)
                {
                    var i;
                    const o = t && null !== (i = this._cache.get(t)) && void 0 !== i ? i : null;
                    if (o) {
                        const t = new n(o);
                        return e ? t.setAttributes({
                            attrs: {
                                "data-loopindex-id": e
                            }
                        }) : t
                    }
                    return null
                }
                async _loadIcon(e)
                {
                    try {
                        const t = await fetch(e);
                        if (t.ok) {
                            const i = await t.text(),
                                o = new n(i, {
                                    "data-li-path": e.replace(/.+icons\//, "")
                                });
                            return this._cache.set(e, o.html), o
                        }
                    } catch (n) {
                        t.logger.error(`Error loading icon from ${e}: ${n}`)
                    }
                    return null
                }
            }
            class o {
                constructor()
                {
                    this._nativeHandlers = new Map,
                    this._pluginHandlers = new Map
                }
                dispose()
                {
                    this.removeAll(),
                    this._pluginHandlers.clear(),
                    this._nativeHandlers.clear()
                }
                removeAll()
                {
                    return [this._nativeHandlers, this._pluginHandlers].forEach((t, e) => {
                        Array.from(t.keys()).forEach(e => {
                            this._removeBinding(e, t)
                        })
                    }), this
                }
                addNativeBinding(e)
                {
                    const {el: n, event: i, callback: o, capture: r=!1} = e,
                        s = this._nativeHandlers;
                    s.has(i) || s.set(i, []);
                    return s.get(i).push({
                        isSet: !1,
                        _set: () => {
                            n.addEventListener(i, o, r)
                        },
                        _unset: () => n.removeEventListener(i, o, r),
                        binding: Object.assign({}, e),
                        active: t.utils.createStateStack(!1)
                    }), this.activateNativeBinding(i, e.scope), this
                }
                addPluginBinding(e)
                {
                    const {event: n, set: i} = e;
                    if (!n || !i || !e.unset)
                        throw new Error("addBinding requires event, set, unset");
                    const o = this._pluginHandlers;
                    o.has(n) || o.set(n, []);
                    return o.get(n).push({
                        isSet: !1,
                        _set: i,
                        binding: Object.assign({}, e),
                        active: t.utils.createStateStack(!1)
                    }), this.activatePluginBinding(n, e.scope), this
                }
                activateNativeBinding(t, e)
                {
                    return this._activateBinding(t, this._nativeHandlers, !0, e)
                }
                activatePluginBinding(t, e)
                {
                    return this._activateBinding(t, this._pluginHandlers, !0, e)
                }
                deactivatePluginBinding(t, e)
                {
                    return this._deactivateBinding(t, this._pluginHandlers, !0, e)
                }
                deactivateNativeBinding(t, e)
                {
                    return this._deactivateBinding(t, this._nativeHandlers, !0, e)
                }
                removePluginBinding(t, e)
                {
                    return this._removeBinding(t, this._pluginHandlers, e), this
                }
                removeNativeBinding(t, e)
                {
                    return this._removeBinding(t, this._nativeHandlers, e), this
                }
                _removeBinding(e, n, i)
                {
                    if (!(null == n ? void 0 : n.has(e)))
                        return void t.logger.warn(`EventManager remove binding: no binding found for ${e}}`);
                    const o = n.get(e);
                    this._deactivateBinding(e, n, !1, i),
                    i ? t.utils.array.remove(o, {
                        test: t => t.binding.scope === i
                    }) : o.length = 0,
                    0 === o.length && n.delete(e)
                }
                _deactivateBinding(e, n, i, o)
                {
                    if (!(null == n ? void 0 : n.has(e)))
                        return t.utils.yes;
                    const r = n.get(e),
                        s = o ? r.filter(t => t.binding.scope === o) : r,
                        a = [];
                    return s.forEach(r => {
                        var s;
                        if (i) {
                            const t = r.active.pushValue(!1);
                            a.push(() => {
                                t(),
                                r.active.value && this._activateBinding(e, n, !1, o)
                            })
                        }
                        try {
                            r.isSet && (null === (s = r._unset) || void 0 === s || s.call(r), r.isSet = !1)
                        } catch (n) {
                            t.logger.error(`Error activating event binding for ${e}}`)
                        }
                    }), this._makeRestoreFunction(a)
                }
                _activateBinding(e, n, i, o)
                {
                    if (!(null == n ? void 0 : n.has(e)))
                        throw new Error("activate non existent binding for event " + e);
                    const r = n.get(e),
                        s = o ? r.filter(t => t.binding.scope === o) : r,
                        a = [];
                    return s.forEach(r => {
                        if (i) {
                            const t = r.active.pushValue(!0);
                            a.push(() => {
                                t(),
                                r.active.value || this._deactivateBinding(e, n, !1, o)
                            })
                        }
                        if (!r.isSet)
                            try {
                                const t = r._set();
                                r.isSet = !0,
                                "function" == typeof r.binding.unset && (r._unset = () => {
                                    r.binding.unset(t)
                                })
                            } catch (n) {
                                t.logger.error("Error activating event binding for " + e)
                            }
                    }), this._makeRestoreFunction(a)
                }
                _makeRestoreFunction(e)
                {
                    let n = !1;
                    return i => {
                        if (n)
                            throw new Error("Restore function called more than once");
                        n = !0;
                        const o = () => {
                            try {
                                e.forEach(t => t())
                            } catch (e) {
                                t.logger.error("while restoring event state: " + e)
                            }
                        };
                        i >= 0 ? setTimeout(o, i) : o()
                    }
                }
            }
            class r {
                constructor(e)
                {
                    this._currentUserId = "",
                    this._events = t.createEventsListener(),
                    this._users = t.utils.createTypedArrayMap(t => t.id),
                    this._attributes = (e || []).slice()
                }
                get events()
                {
                    return this._events
                }
                count(t)
                {
                    return t ? this._users.count(t) : this._users.length
                }
                getCurrentUser(t)
                {
                    return (this._currentUserId ? this._users.get(this._currentUserId) : null) || (t ? {
                            id: "",
                            name: "default user"
                        } : null)
                }
                dispose()
                {
                    this._users.clear(),
                    this._currentUserId = ""
                }
                updateUser(e)
                {
                    const n = this.getUser(null == e ? void 0 : e.id);
                    if (!n)
                        return t.logger.warn("updateUser: no user with id " + (null == e ? void 0 : e.id)), null;
                    const i = new Map;
                    if (e.name && e.name !== n.name && i.set("name", e.name), this._attributes.forEach(t => {
                        const o = e[t];
                        void 0 !== o && o !== n[t] && i.set(t, o)
                    }), i.size) {
                        const t = Object.assign({}, n);
                        i.forEach((e, n) => {
                            Object.assign(t, {
                                [n]: e
                            })
                        }),
                        this._users.addItem({
                            item: t,
                            replace: !0
                        }),
                        this._events.trigger("update", Object.assign({}, t))
                    }
                    return Object.assign({}, n)
                }
                setCurrentUser(e)
                {
                    e && e !== this._currentUserId && (this.hasUser(e) ? (this._currentUserId = String(e), this.events.trigger("select", Object.assign({}, this.getUser(e)))) : t.logger.error("setCurrentUser: unknown user id", e))
                }
                addUser(e)
                {
                    const n = (null == e ? void 0 : e.id) ? String(e.id) : "";
                    if (!n)
                        return t.logger.error("can't add a user without an id", e), null;
                    if (this._users.hasId(n))
                        return this.updateUser(e);
                    const i = {
                        error: "",
                        userData: e = Object.assign(Object.assign({}, e), {
                            id: n
                        }),
                        user: null
                    };
                    if (this.events.trigger("beforeadd", i), !i.user)
                        return t.logger.error(i.error || "failed to create user"), null;
                    const o = i.user,
                        r = {};
                    this._attributes.forEach(t => {
                        r[t] = e[t]
                    });
                    const s = t.$.extend(!0, {
                        id: o.id,
                        name: o.name || ""
                    }, r);
                    this._users.addItem({
                        item: s,
                        replace: !0
                    });
                    const a = Object.assign({}, s);
                    return this._events.trigger("add", a), a
                }
                removeUser(t)
                {
                    const e = this._users.get(t);
                    e && (this._users.removeById(t), this._events.trigger("remove", e), e.id === this._currentUserId && (this._currentUserId = "", this.events.trigger("select", null)))
                }
                getUser(t)
                {
                    if (!t)
                        return null;
                    const e = (t = String(t)) ? this._users.get(String(t)) : null;
                    return e ? Object.assign({}, e) : null
                }
                getUsersArray()
                {
                    return this._users.items.map(t => Object.assign({}, t))
                }
                getAllUsers()
                {
                    return this._users.items.reduce((t, e) => (t[e.id] = Object.assign({}, e), t), {})
                }
                hasUser(t)
                {
                    return !!t && this._users.hasId(String(t))
                }
                get currentUserId()
                {
                    return this._currentUserId
                }
            }
            const s = {
                pluginUtils: new class {
                    constructor()
                    {
                        this.VERSION = "1.9.12",
                        this._svgCache = new i
                    }
                    isDarkMode(t=window.top)
                    {
                        var e;
                        return Boolean(null === (e = null == t ? void 0 : t.matchMedia) || void 0 === e ? void 0 : e.call(t, "(prefers-color-scheme: dark)").matches)
                    }
                    disableTracking(t)
                    {
                        return t.fireEditorEvent("disable-tracking"), () => {
                            t.fireEditorEvent("enable-tracking")
                        }
                    }
                    get svgCache()
                    {
                        return this._svgCache
                    }
                    getPluginAssetPath(e)
                    {
                        const n = (e.config("assetPath") || "").trim();
                        return n ? t.utils.isAbsoluteUrl(n) ? n : t.utils.strings.joinPath(e.path, n) : e.path
                    }
                    async loadPluginPageStyles(e)
                    {
                        const n = e.config("pageUrls");
                        if (!(null == n ? void 0 : n.length))
                            return Promise.resolve(!0);
                        const i = n.map(t => e.resolvePath(t)).map(n => t.utils.strings.addParamsToUrl(n, {
                            v: `${e.version}/${this.VERSION}`
                        }));
                        return !!e.getEditorUIContainer() && new Promise(e => {
                                new t.utils.CSSLoader(document).loadCSS(i, t => {
                                    e(t.ok)
                                })
                            }).then(t => t).catch(t => !1)
                    }
                    logEditorEvents(e, n, i, o)
                    {
                        let r = n && void 0 !== o ? {
                            log: o,
                            editor: n,
                            exclude: i,
                            plugin: e
                        } : e;
                        const s = r.editor,
                            a = r.method || "fire",
                            l = r.plugin;
                        if (i = t.utils.strings.toStringArray(r.exclude), !s || !l)
                            return t.logger.warn("logEditorEvents: missing params");
                        if (!s[a])
                            return t.logger.warn("logEditorEvents: editor doesn't include method " + a);
                        if (Boolean(r.log) !== Boolean(l.savedEditorFireMethod))
                            if (r.log) {
                                l.savedEditorFireMethod = s[a];
                                const e = i.length ? new RegExp(i.join("|"), "i") : /mouse|key|selection|click|focus|undo|redo|snapshot|resolvename/i,
                                    n = function(t) {
                                        return !t || e.test(t)
                                    };
                                s[a] = (...e) => {
                                    var i;
                                    return n(e[0]) || t.logger.debug("Editor event " + e[0]), null === (i = l.savedEditorFireMethod) || void 0 === i ? void 0 : i.apply(s, e)
                                }
                            } else
                                s[a] = l.savedEditorFireMethod,
                                l.savedEditorFireMethod = null
                    }
                    upgradeConfigCommands(e, n)
                    {
                        let i,
                            o = !1;
                        if (!n)
                            return e.slice();
                        if ("string" == typeof n)
                            i = t.utils.strings.toStringArray(n),
                            o = !0;
                        else {
                            if (!Array.isArray(n))
                                throw new Error("illegal value for commands type " + typeof n);
                            i = n,
                            o = n.every(t => "string" == typeof t)
                        }
                        const r = i.reduce((t, e) => ("string" == typeof e ? t.set(e, {
                            toolbar: !0
                        }) : e.command && t.set(e.command, e), t), new Map);
                        return e.map(t => {
                            const e = r.get(t.command);
                            return e ? Object.assign(Object.assign({}, t), e) : Object.assign(Object.assign({}, t), {
                                toolbar: !o && t.toolbar
                            })
                        })
                    }
                    initLoopindexPlugin(e)
                    {
                        this.addPluginProperty(e, {
                            key: "_debounceManager",
                            value: t.utils.createDebouncerManager()
                        }),
                        this.addPluginProperty(e, {
                            key: "build",
                            value: "Feb 06/02:18"
                        }),
                        this.addPluginProperty(e, {
                            key: "$",
                            value: t.$
                        }),
                        this.addPluginProperty(e, {
                            key: "_timeoutClient",
                            value: t.utils.createTimeoutClient()
                        }),
                        this.addPluginProperty(e, {
                            key: "events",
                            value: t.createEventsListener()
                        }),
                        this.addPluginProperty(e, {
                            key: "eventManager",
                            value: new o
                        });
                        const n = t.utils.createStateStack(!1);
                        this.addPluginProperty(e, {
                            key: "_isSelecting",
                            value: function() {
                                return n.value
                            }
                        }),
                        this.addPluginProperty(e, {
                            key: "_pushSelecting",
                            value: function(t) {
                                return n.pushValue(t)
                            }
                        }),
                        this.addPluginProperty(e, {
                            key: "onSelectionChanged",
                            value: function() {
                                this._isSelecting() || this._timeoutClient.startTimer("selection-changed")
                            }
                        }),
                        this.addPluginProperty(e, {
                            key: "addDictionary",
                            value: function(t, e) {
                                this.localizer.addDictionary(t, e),
                                this.onLocaleChanged()
                            }
                        }),
                        this.addPluginProperty(e, {
                            key: "config",
                            value: function(e, n) {
                                const i = () => t.$.extend(!0, {}, this._config);
                                if (!e)
                                    return i();
                                const o = this._config;
                                if (void 0 === n)
                                    return o[e];
                                o[e] = n;
                                const r = {
                                    key: e,
                                    value: n
                                };
                                return this.events.trigger("config", r), i()
                            }
                        }),
                        e._timeoutClient.createTimer("selection-changed", {
                            autoDispose: !1,
                            callback: () => {
                                e._isSelecting() || e._onSelectionChanged()
                            },
                            timeoutMSecs: 40
                        });
                        const i = this.getPluginAssetPath(e);
                        return this.addPluginProperty(e, {
                            key: "resolvePath",
                            value: function(...e) {
                                return ((e, ...n) => {
                                    const i = t.utils.isAbsoluteUrl(n[0]) ? Array.from(n) : [e].concat(n);
                                    return t.utils.strings.joinPath(...i)
                                })(i, ...e)
                            }
                        }), e
                    }
                    stringToLoopindexSVG(n)
                    {
                        try {
                            const t = e(n).filter("svg").first();
                            if (t.length)
                                return t.addClass("loopindex-button"), t.find("path").addClass("loopindex-svg-icon"), t[0]
                        } catch (e) {
                            t.logger.error("Error parsing svg: " + e)
                        }
                        return null
                    }
                    isSelectionInDocument(t)
                    {
                        const e = t.getBody(),
                            n = e && t.getSelectedRange(!0);
                        if (!n)
                            return !1;
                        const i = n.commonAncestorContainer;
                        return e === i || e.contains(i)
                    }
                    addPluginProperty(t, e)
                    {
                        const n = /^_/.test(String(e.key));
                        return Object.defineProperty(t, e.key, {
                            value: e.value,
                            writable: !0 === e.writable,
                            configurable: !1,
                            enumerable: !n
                        }), t
                    }
                    addPluginProperties(t, e)
                    {
                        for (const n in e)
                            this.addPluginProperty(t, {
                                key: n,
                                value: e[n],
                                writable: !1
                            });
                        return t
                    }
                    createUserManager(t)
                    {
                        return new r(t)
                    }
                }
            };
            Object.assign(t.utils, s)
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            const e = new Set(["TEXTAREA", "INPUT", "OL", "UL", "TABLE", "TR", "IMG", "SCRIPT", "LINK", "svg", "BR"]),
                n = /\[\[([^\]]+)\]\]/g,
                i = t => {
                    if (!t)
                        return [""];
                    if (!n.test(t))
                        return [t];
                    const e = new RegExp(n),
                        i = [];
                    let o = 0;
                    for (;;) {
                        const n = e.exec(t);
                        if (!n) {
                            o < t.length - 1 && i.push(t.substring(o));
                            break
                        }
                        n.index > o && i.push(t.substring(o, n.index)),
                        i.push(n[1]),
                        o = e.lastIndex
                    }
                    return i
                };
            class o {
                constructor(t, e)
                {
                    this.owner = t,
                    this.domain = e.domain,
                    this._locale = e.locale,
                    this._localizer = t.getLocalizer(this.domain, this._locale)
                }
                get locale()
                {
                    return this._locale
                }
                addDictionary(t, e)
                {
                    this.owner.loadLocales(this.domain, {
                        [t]: e
                    })
                }
                loadLocale(t)
                {
                    return this.owner.loadLocale(this.domain, t).then(e => (e || (this._locale = t, this._localizer = this.owner.getLocalizer(this.domain, t)), e))
                }
                localizeString(t, e)
                {
                    return this._localizer(t, e)
                }
                localizeUI(i)
                {
                    const r = t.utils.dom.toJQuery(i);
                    if (!(null == r ? void 0 : r.length))
                        return r;
                    const s = (t, ...e) => this._localizer(e[0]),
                        a = (t, e) => {
                            const i = "data-li-" + e,
                                o = "text" === e,
                                r = t.getAttribute(i),
                                a = r || (o ? t.textContent : t.getAttribute(e));
                            if (!a)
                                return;
                            if (!n.test(a))
                                return void (a || (o ? t.textContent = r : t.setAttribute(e, String(r))));
                            let l = a;
                            do {
                                l = l.replace(n, s)
                            } while (n.test(l));
                            t.setAttribute(i, a),
                            o ? t.textContent = l : t.setAttribute(e, l)
                        };
                    return r.each((t, n) => {
                        a(n, "title"),
                        a(n, "placeholder"),
                        (t => {
                            if (1 !== (null == t ? void 0 : t.nodeType))
                                return !1;
                            if (e.has(t.nodeName))
                                return !1;
                            let n = !1;
                            for (let e = t.firstChild; e; e = e.nextSibling) {
                                if (3 !== e.nodeType)
                                    return !1;
                                n = !0
                            }
                            return n
                        })(n) ? a(n, "text") : r.children().each((t, e) => {
                            1 !== e.nodeType || o.FINAL_TAGS.has(e.nodeName) || this.localizeUI(e)
                        })
                    }), r
                }
            }
            o.FINAL_TAGS = new Set(["svg", "path", "IMG", "BR"]);
            const r = t => t.trim().toLowerCase().replace(/_+/g, "-"),
                s = e => {
                    const n = new Map;
                    return e ? (Object.entries(e).forEach(([e, i]) => {
                        const o = r(e);
                        t.utils.strings.toStringArray(i).forEach(t => n.set(r(t), o))
                    }), n) : n
                };
            class a {
                constructor({assetPath: t, defaultLocale: e, locales: n, localeMapping: i, urlParams: o})
                {
                    const r = this._dictionaries = new Map;
                    n.forEach(t => r.set(t, {
                        status: "none",
                        dictionary: new Map
                    })),
                    this.assetPath = t,
                    this.defaultLocale = e,
                    this.urlParams = Object.assign({}, o),
                    this._localeMapping = s(i)
                }
                setLocaleMapping(t)
                {
                    const e = s(t);
                    this._localeMapping.clear(),
                    e.forEach((t, e) => {
                        this._localeMapping.set(e, t)
                    })
                }
                mapLocale(t)
                {
                    var e;
                    return null !== (e = this._localeMapping.get(t)) && void 0 !== e ? e : t
                }
                isLoading(t)
                {
                    var e;
                    return "loading" === (null === (e = this._dictionaries.get(t)) || void 0 === e ? void 0 : e.status)
                }
                isLoaded(t)
                {
                    var e;
                    return "loaded" === (null === (e = this._dictionaries.get(t)) || void 0 === e ? void 0 : e.status)
                }
                getStatus(t)
                {
                    return this._dictionaries.get(t).status
                }
                setStatus(t, e)
                {
                    const n = this._dictionaries.get(t);
                    this._dictionaries.set(t, {
                        status: e,
                        dictionary: n.dictionary
                    })
                }
                setLoading(t)
                {
                    const e = this._dictionaries.get(t);
                    this._dictionaries.set(t, {
                        dictionary: e.dictionary,
                        status: "loading"
                    })
                }
                hasLocale(t)
                {
                    return this._dictionaries.has(t)
                }
                hasDictionary(t)
                {
                    var e;
                    return "loaded" === (null === (e = this._dictionaries.get(t)) || void 0 === e ? void 0 : e.status)
                }
                getDictionary(t)
                {
                    const e = this._dictionaries.get(t);
                    return (null == e ? void 0 : e.dictionary) || null
                }
                load(t, e, n)
                {
                    if (!e || "object" != typeof e)
                        return;
                    const i = (t, e, n) => {
                            if (!e || "object" != typeof e)
                                return;
                            const o = t ? t + "." : "";
                            Object.keys(e).forEach(t => {
                                const r = e[t],
                                    s = typeof r;
                                "string" === s || "number" === s || "boolean" === s ? n.set(`${o}${t}`, String(r)) : i(`${o}${t}`, r, n)
                            })
                        },
                        o = this._dictionaries.get(t),
                        r = o.dictionary;
                    i("", e, r),
                    this._dictionaries.set(t, {
                        status: n ? "loaded" : o.status,
                        dictionary: r
                    })
                }
            }
            const l = {
                LocaleServer: new class {
                    constructor()
                    {
                        this._domainMap = new Map
                    }
                    hasDomain(t)
                    {
                        return this._domainMap.has(t)
                    }
                    defineDomain({domain: e, locales: n, assetPath: i, defaultLocale: o, localeMapping: s, urlParams: l})
                    {
                        if (this._domainMap.has(e))
                            return t.logger.warn(`Localizer: client ${e} already defined`), this;
                        if (!o || "string" != typeof o)
                            throw new Error("Localizer createClient: illegal default language " + o);
                        let c = r(o);
                        if (0 === (n = t.utils.strings.toStringArray(n, {
                            unique: !0,
                            transform: "lower"
                        })).length)
                            throw new Error("Localizer createClient: no locales provided");
                        if (n.indexOf(c) < 0)
                            if (n.indexOf(c.substring(0, 2)) >= 0)
                                c = c.substring(0, 2);
                            else {
                                if (!(n.indexOf("en") >= 0))
                                    throw new Error(`Localizer createClient: default language ${o} not found in ${n}`);
                                t.logger.warn(`Setting default locale to English, locale ${o} not found`),
                                c = "en"
                            }
                        const u = new a({
                            assetPath: i,
                            locales: n,
                            defaultLocale: c,
                            localeMapping: s,
                            urlParams: l
                        });
                        return this._domainMap.set(e, u), this
                    }
                    setDomainLocaleMapping(t, e)
                    {
                        const n = this._domainMap.get(t);
                        if (!n)
                            throw new Error("setDomainLocaleMapping: unknown domain " + t);
                        n.setLocaleMapping(e)
                    }
                    loadLocales(e, n)
                    {
                        if (!n || "object" != typeof n)
                            return t.logger.error("Load dictionary: null or invalid dictionaries object"), this;
                        if (Array.isArray(n))
                            return t.logger.error("Load dictionary: dictionaries can't be an array"), this;
                        const i = this._domainMap.get(e);
                        return i ? (Object.entries(n).forEach(([e, n]) => {
                            const o = this._validateLocale(i, e, !1);
                            if (!o)
                                return t.logger.warn("load locales: skipping unknown locale " + e);
                            i.load(o, n, !1)
                        }), this) : (t.logger.error("Unknown domain " + e), this)
                    }
                    loadLocale(e, n)
                    {
                        const i = this._domainMap.get(e);
                        return i ? (n = this._validateLocale(i, n), i.isLoaded(n) ? Promise.resolve("") : i.isLoading(n) ? this._waitFor(i, n) : new Promise(o => {
                            var r;
                            i.setLoading(n);
                            const s = new URL(t.utils.strings.joinPath(i.assetPath, n + ".json"), window.location.href);
                            Object.entries(null !== (r = i.urlParams) && void 0 !== r ? r : {}).forEach(([t, e]) => {
                                s.searchParams.set(t, String(e))
                            }),
                            fetch(s.toString(), {
                                method: "GET"
                            }).then(t => t.json()).then(t => t && "object" == typeof t ? (i.load(n, t, !0), o("")) : o(`Invalid data in domain ${e} locale ${n}`)).catch(t => {
                                i.setStatus(n, "error"),
                                o(String(t))
                            })
                        }).then(t => t)) : Promise.resolve(`Cannot load locale ${n} in unknown domain ${e}`)
                    }
                    createClient(t, e)
                    {
                        const n = this._domainMap.get(t);
                        if (!n)
                            throw new Error("Unknown localization client " + t);
                        return new o(this, {
                            domain: t,
                            locale: e || n.defaultLocale
                        })
                    }
                    getLocalizer(t, e)
                    {
                        const n = (t, e) => "string" == typeof e ? e : i(t).join("");
                        if (!t || !e)
                            return n;
                        const o = this._domainMap.get(t);
                        if (!o)
                            return n;
                        e = this._validateLocale(o, e);
                        const r = o.getDictionary(e);
                        return r ? (t, n) => i(t).map(t => {
                            var i;
                            let s = r.get(t);
                            return s || (e !== o.defaultLocale && (s = null === (i = o.getDictionary(o.defaultLocale)) || void 0 === i ? void 0 : i.get(t)), s || ("string" == typeof n ? n : t))
                        }).join("") : n
                    }
                    _waitFor(t, e)
                    {
                        return new Promise(n => {
                            let i,
                                o = 0;
                            const r = t => (clearInterval(i), n(t || ""));
                            i = setInterval(() => {
                                const n = t.getStatus(e);
                                if ("loading" !== n) {
                                    return r("error" === n ? "load error" : "loaded" === n ? "" : "wrong load status")
                                }
                                if (++o > 50)
                                    return r("timed out")
                            }, 100)
                        })
                    }
                    _validateLocale(t, e, n=!0)
                    {
                        return e ? (e = t.mapLocale(r(e)), t.hasLocale(e) || e.length > 2 && (e = e.substring(0, 2), t.hasLocale(e)) ? e : n ? t.defaultLocale : "") : t.defaultLocale
                    }
                }
            };
            Object.entries(l).forEach(([e, n]) => {
                t.utils.hasOwnProperty(e) || Object.defineProperty(t.utils, e, {
                    value: n,
                    writable: !1,
                    enumerable: !1
                })
            })
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            const e = new RegExp("s*quicktip-position-[a-z]+", "g"),
                n = {
                    color: {
                        daffodil: {
                            r: 255,
                            g: 230,
                            b: 23
                        },
                        daisy: {
                            r: 250,
                            g: 211,
                            b: 28
                        },
                        mustard: {
                            r: 253,
                            g: 183,
                            b: 23
                        },
                        "citrus zest": {
                            r: 250,
                            g: 170,
                            b: 33
                        },
                        pumpkin: {
                            r: 241,
                            g: 117,
                            b: 63
                        },
                        tangerine: {
                            r: 237,
                            g: 87,
                            b: 36
                        },
                        salmon: {
                            r: 240,
                            g: 70,
                            b: 57
                        },
                        persimmon: {
                            r: 234,
                            g: 40,
                            b: 48
                        },
                        rouge: {
                            r: 188,
                            g: 35,
                            b: 38
                        },
                        scarlet: {
                            r: 140,
                            g: 12,
                            b: 3
                        },
                        "hot pink": {
                            r: 229,
                            g: 24,
                            b: 93
                        },
                        princess: {
                            r: 243,
                            g: 132,
                            b: 174
                        },
                        petal: {
                            r: 250,
                            g: 198,
                            b: 210
                        },
                        lilac: {
                            r: 178,
                            g: 150,
                            b: 199
                        },
                        lavender: {
                            r: 123,
                            g: 103,
                            b: 174
                        },
                        violet: {
                            r: 95,
                            g: 53,
                            b: 119
                        },
                        cloud: {
                            r: 195,
                            g: 222,
                            b: 241
                        },
                        dream: {
                            r: 85,
                            g: 190,
                            b: 237
                        },
                        gulf: {
                            r: 49,
                            g: 168,
                            b: 224
                        },
                        turquoise: {
                            r: 35,
                            g: 138,
                            b: 204
                        },
                        sky: {
                            r: 13,
                            g: 96,
                            b: 174
                        },
                        indigo: {
                            r: 20,
                            g: 59,
                            b: 134
                        },
                        navy: {
                            r: 0,
                            g: 27,
                            b: 74
                        },
                        "sea foam": {
                            r: 125,
                            g: 205,
                            b: 194
                        },
                        teal: {
                            r: 0,
                            g: 168,
                            b: 168
                        },
                        peacock: {
                            r: 18,
                            g: 149,
                            b: 159
                        },
                        ceadon: {
                            r: 193,
                            g: 209,
                            b: 138
                        },
                        olive: {
                            r: 121,
                            g: 145,
                            b: 85
                        },
                        bamboo: {
                            r: 128,
                            g: 188,
                            b: 66
                        },
                        grass: {
                            r: 74,
                            g: 160,
                            b: 63
                        },
                        kelly: {
                            r: 22,
                            g: 136,
                            b: 74
                        },
                        forrest: {
                            r: 0,
                            g: 63,
                            b: 46
                        },
                        chocolate: {
                            r: 56,
                            g: 30,
                            b: 17
                        },
                        "terra cotta": {
                            r: 192,
                            g: 92,
                            b: 32
                        },
                        camel: {
                            r: 191,
                            g: 155,
                            b: 107
                        },
                        linen: {
                            r: 233,
                            g: 212,
                            b: 167
                        },
                        stone: {
                            r: 231,
                            g: 230,
                            b: 225
                        },
                        smoke: {
                            r: 207,
                            g: 208,
                            b: 210
                        },
                        steel: {
                            r: 138,
                            g: 139,
                            b: 143
                        },
                        slate: {
                            r: 119,
                            g: 133,
                            b: 144
                        },
                        charcoal: {
                            r: 71,
                            g: 77,
                            b: 77
                        },
                        black: {
                            r: 5,
                            g: 6,
                            b: 8
                        },
                        white: {
                            r: 255,
                            g: 255,
                            b: 255
                        },
                        "metalic silver": {
                            r: 152,
                            g: 162,
                            b: 171
                        },
                        "metalic gold": {
                            r: 159,
                            g: 135,
                            b: 89
                        },
                        "metalic copper": {
                            r: 140,
                            g: 102,
                            b: 65
                        }
                    },
                    stickTo: {
                        bottom: "bottom",
                        left: "left",
                        right: "right",
                        top: "top"
                    }
                },
                i = {
                    animateDuration: 600,
                    animateFunction: "fadein",
                    delay: 500,
                    disableAnimation: !1,
                    hideDelay: 300,
                    persistent: !1,
                    stickTo: n.stickTo.bottom,
                    stickDistance: 10,
                    unique: !1,
                    useTitle: !1,
                    canShow: void 0,
                    dismissEvents: ["keydown", "mousedown"]
                };
            class o {
                static setElementPositionClass(t, n)
                {
                    var i;
                    return t.className = (null !== (i = t.className) && void 0 !== i ? i : "").replace(e, ""), t.classList.add("quicktip-position-" + n), t
                }
                static getElementsBySelector(e, n)
                {
                    if (!e)
                        return [];
                    try {
                        return Array.prototype.slice.call((n || document).querySelectorAll(e))
                    } catch (e) {
                        return t.logger.warn("get Elements By Selector error: " + e), []
                    }
                }
                static destroyObject(t)
                {
                    if (t)
                        if (Array.isArray(t))
                            t.length = 0;
                        else {
                            Object.keys(t).forEach(e => {
                                try {
                                    t[e] = void 0
                                } catch (t) {}
                            })
                        }
                }
                static attachAnimationCallback({el: t, callback: e, duration: n})
                {
                    let i = 0;
                    const o = () => {
                        t.removeEventListener("transitionend", o),
                        0 !== i && (clearTimeout(i), i = 0),
                        e(t)
                    };
                    t.addEventListener("transitionend", o),
                    n = Number(n) || 500,
                    i = setTimeout(() => {
                        o()
                    }, n)
                }
                static px(t)
                {
                    return (t || 0).toFixed(0) + "px"
                }
                static px0(t)
                {
                    return o.px(Math.max(0, t || 0))
                }
                static toArray(t, e=0)
                {
                    return Array.from(t).slice(e)
                }
                static isChildOf(t, e)
                {
                    if (!t || !e)
                        return !1;
                    let n;
                    for (; n = null == t ? void 0 : t.parentNode;) {
                        if (n === e)
                            return !0;
                        t = n
                    }
                    return !1
                }
                static findOptionsTargets(t)
                {
                    var e;
                    const n = 1 === (null === (e = t.target) || void 0 === e ? void 0 : e.nodeType) ? [t.target] : [];
                    if (t.targetSelector) {
                        o.getElementsBySelector(t.targetSelector, t.root).forEach(t => {
                            n.includes(t) || n.push(t)
                        })
                    }
                    return n
                }
                static argsToObj(t)
                {
                    var e = o.toArray(t).map(t => typeof t),
                        n = {};
                    if ("object" === e[0])
                        n = t[0];
                    else if ("string" === e[0]) {
                        const e = t[0].split(" ");
                        for (var i in e)
                            n[e[i]] = t[1]
                    } else
                        "function" === e[0] && (n = {
                            "": t[0]
                        });
                    return n
                }
                static gainAnchorElements(t)
                {
                    return {
                        box: t.querySelector(".quicktips-box"),
                        more: t.querySelector(".quicktips-more"),
                        moreText: t.querySelector(".quicktips-more .quicktips-text"),
                        text: t.querySelector(":not(.quicktips-more) .quicktips-text")
                    }
                }
                static extractOptionAttribute(t, e, n)
                {
                    for (var i = t.getAttribute(e), o = t; !i && (o = o.parentNode) && o.getAttribute;)
                        i = o.getAttribute(e);
                    return i || String(n)
                }
                static extractBooleanAttribute(e, n, i)
                {
                    const r = o.extractOptionAttribute(e, n, String(i));
                    return !!/^(true|yes|on|1)$/i.test(r) || !/^(false|no|off|0)$/i.test(r) && (t.logger.error(`Illegal value ${r} for attribute ${n}`), i)
                }
                static extractNumberAttribute(t, e, n)
                {
                    const i = o.extractOptionAttribute(t, e, String(n)),
                        r = parseFloat(i);
                    return isNaN(r) ? n : r
                }
            }
            class r {
                static getNodeWindow(t)
                {
                    var e,
                        n;
                    return null !== (n = null === (e = null == t ? void 0 : t.ownerDocument) || void 0 === e ? void 0 : e.defaultView) && void 0 !== n ? n : null
                }
                static getNodeIframe(t)
                {
                    var e;
                    const n = r.getNodeWindow(t);
                    return null !== (e = null == n ? void 0 : n.frameElement) && void 0 !== e ? e : null
                }
                static getNodeFrames(t, e=!1)
                {
                    const n = [];
                    let i = t;
                    for (; i;) {
                        const t = r.getNodeIframe(i);
                        (t || e) && n.push(r.getNodeWindow(i)),
                        i = t
                    }
                    return n
                }
                static canAttach(t)
                {
                    var e;
                    const n = null !== (e = this.MY_FRAMES) && void 0 !== e ? e : this.MY_FRAMES = r.getNodeFrames(window.document.head);
                    if (!n.length)
                        return !0;
                    return r.getNodeFrames(t).includes(n[n.length - 1])
                }
                static getGlobalRect(t, e)
                {
                    let n = t.getBoundingClientRect();
                    e = null != e ? e : r.getNodeFrames(t);
                    for (const t of e) {
                        const e = t.frameElement.getBoundingClientRect();
                        n = new DOMRect(n.x + e.x, n.y + e.y, n.width, n.height)
                    }
                    return n
                }
                static getRelativeRect(e, n)
                {
                    let i = e.getBoundingClientRect();
                    const o = r.getNodeFrames(e),
                        s = r.getNodeFrames(n);
                    if (!o.length)
                        return s.length && t.logger.error("Can't attach tooltip in super frame"), i;
                    if (!s.length)
                        return this.getGlobalRect(e, o);
                    const a = s[0];
                    for (const t of o) {
                        if (t === a)
                            break;
                        const e = t.frameElement.getBoundingClientRect();
                        i = new DOMRect(i.x + e.x, i.y + e.y, i.width, i.height)
                    }
                    return i
                }
                static attachGlobalObservers(t, e)
                {
                    return (Array.isArray(t) ? t : [t]).reduce((t, e) => (r.getNodeFrames(e, !0).forEach(e => {
                        t.includes(e) || t.push(e)
                    }), t), []).forEach(t => {
                        r.AttachedWindows.has(t) || (r.AttachedWindows.set(t, []), r._attachToWindow(t));
                        const n = r.AttachedWindows.get(t);
                        n.includes(e) || n.push(e)
                    }), () => {
                        r.AttachedWindows.forEach(t => {
                            let n = 0;
                            for (; (n = t.indexOf(e)) >= 0;)
                                t.splice(n, 1)
                        })
                    }
                }
                static _attachToWindow(t)
                {
                    let e = 0;
                    const n = n => {
                        e || (e = setTimeout(() => {
                            e = 0;
                            const i = r.AttachedWindows.get(t);
                            (null == i ? void 0 : i.length) && i.forEach(t => t(n))
                        }, 50))
                    };
                    for (const e of ["resize", "scroll", "keydown"])
                        t.addEventListener(e, () => n(e), !1)
                }
            }
            r.AttachedWindows = new Map;
            class s {
                constructor(t)
                {
                    this.eventCallbacks = {},
                    this.modelObservers = new Map,
                    this._elements = [],
                    this._anchors = null,
                    this.notifyTimeoutID = {},
                    this.model = {},
                    this._instantiate = () => {
                        if (this._elements.length)
                            return !1;
                        const e = document.createElement("div");
                        return e.innerHTML = t, this._elements.push(...o.toArray(e.children)), this._anchors = o.gainAnchorElements(e), !0
                    }
                }
                on(...t)
                {
                    const e = o.argsToObj(t);
                    for (const t in e) {
                        const n = e[t];
                        if ("function" != typeof n)
                            throw new Error(`Tooltip component: On ${t} received invalid callback`);
                        this.eventCallbacks[t] = this.eventCallbacks[t] || [],
                        this.eventCallbacks[t].push(n)
                    }
                }
                get anchors()
                {
                    return this._instantiate(), this._anchors
                }
                get element()
                {
                    return this._instantiate(), this._elements[0]
                }
                unmount()
                {
                    this._elements.forEach(t => {
                        var e;
                        null === (e = t.parentNode) || void 0 === e || e.removeChild(t)
                    })
                }
                destroy()
                {
                    this.unmount(),
                    o.destroyObject(this.eventCallbacks),
                    o.destroyObject(this._anchors),
                    o.destroyObject(this._elements)
                }
                onModelUpdate(t)
                {
                    this.model;
                    Object.entries(t).forEach(([t, e]) => {
                        this.modelObservers.has(t) || this.modelObservers.set(t, []),
                        this.modelObservers.get(t).push(e)
                    }),
                    Object.keys(t).forEach(t => this.notifyObservers(t))
                }
                get isMounted()
                {
                    return Boolean(this._elements.length)
                }
                mount(t)
                {
                    t = t || document.body;
                    const e = this._instantiate();
                    try {
                        this._elements.forEach(e => {
                            e.parentNode !== t && t.appendChild(e)
                        }),
                        e && this._refresh()
                    } catch (t) {
                        throw "Could not mount tooltip component: " + String(t)
                    }
                }
                set(t)
                {
                    const e = this.model;
                    Object.entries(t).forEach(([t, n]) => {
                        ("function" == typeof n || void 0 !== n && e[t] !== n) && (e[t] = n, this.notifyObservers(t))
                    })
                }
                notifyObservers(e)
                {
                    clearTimeout(this.notifyTimeoutID[e]),
                    this.notifyTimeoutID[e] = setTimeout(() => {
                        this.modelObservers.forEach((e, n) => {
                            const i = this.model[n];
                            if (null != i && e.length)
                                try {
                                    e.forEach(t => t(i))
                                } catch (e) {
                                    t.logger.warn("tooltips notification error " + e)
                                }
                        })
                    })
                }
                _refresh()
                {
                    Object.keys(this.modelObservers).forEach(t => this.notifyObservers(t))
                }
            }
            class a {
                constructor()
                {
                    var t;
                    this._isShown = !1,
                    this._eventCallbacks = new Map([["destroy", []], ["hide", []], ["show", []]]);
                    const e = this.component = new s('\n<div class="quicktips-tooltip" style="box-sizing:border-box;position:fixed;z-index:2147483647">\n  <div class="quicktips-box">\n    <div class="quicktips-text"></div>\n    <div class="quicktips-more" style="overflow:hidden;">\n      <div class="quicktips-text"></div>\n    </div>\n  </div>\n</div>');
                    this.resetTooltipPosition(),
                    (this._cachedTitle = null === (t = this.target) || void 0 === t ? void 0 : t.getAttribute("title")) && this.target.removeAttribute("title"),
                    this.addEventCallback({
                        event: "show",
                        cb: () => this.refresh()
                    }),
                    this.useTitle() ? e.onModelUpdate({
                        contentText: t => {
                            this._updateTitleAttr(t)
                        }
                    }) : e.onModelUpdate({
                        color: t => {
                            if (this._isShown) {
                                if (n.color[t]) {
                                    const e = n.color[t];
                                    t = "rgb(" + e.r + ", " + e.g + ", " + e.b + ")"
                                }
                                e.anchors.box.style.backgroundColor = t
                            }
                        },
                        contentText: t => {
                            this._updateTitleContent({
                                component: e,
                                contentText: t
                            })
                        },
                        contentMore: t => {
                            this._updateTitleContent({
                                component: e,
                                contentMore: t
                            })
                        },
                        stickTo: t => {
                            this._isShown && o.setElementPositionClass(e.element, t)
                        }
                    })
                }
                refresh()
                {
                    if (!this.isShown)
                        return;
                    const t = this.model;
                    this.useTitle() ? this._updateTitleAttr(t.contentText) : this._updateTitleContent({
                        component: this.component,
                        contentText: t.contentText,
                        contentMore: t.contentMore
                    })
                }
                get target()
                {
                    var t,
                        e;
                    return null !== (e = null === (t = this.model) || void 0 === t ? void 0 : t.target) && void 0 !== e ? e : null
                }
                addEventCallback(t)
                {
                    const e = t.cb;
                    if (e) {
                        const n = this._eventCallbacks.get(t.event);
                        n.find(t => t.cb === e) || n.push(t)
                    }
                    return this
                }
                set(t)
                {
                    this.component.set(t)
                }
                useTitle()
                {
                    var t;
                    return Boolean(null === (t = this.model) || void 0 === t ? void 0 : t.useTitle)
                }
                get isShown()
                {
                    return this._isShown
                }
                get model()
                {
                    return this.component.model
                }
                get element()
                {
                    return this.component.element
                }
                unmount()
                {
                    this._onHide(),
                    this.resetTooltipPosition(),
                    this._isShown = !1,
                    this.component.unmount()
                }
                destroy()
                {
                    var t;
                    this._cachedTitle && (null === (t = this.target) || void 0 === t || t.setAttribute("title", this._cachedTitle), this._cachedTitle = ""),
                    this._onHide(),
                    this._onDestroy(),
                    this.component.destroy()
                }
                on(...t)
                {
                    return this.component.on(...t)
                }
                showMore()
                {
                    this.show().then(t => {
                        if (!t)
                            return;
                        const e = this.component.element,
                            n = this.component.anchors.more,
                            i = this.model;
                        if (i.contentMore && (n.style.display = "block", n.style.visibility = "visible"), "block" !== n.style.display && i.contentMore) {
                            n.style.display = "block",
                            this.animateElementClass(e),
                            this.moveTooltip();
                            const t = n.getBoundingClientRect().height;
                            n.style.visibility = "visible",
                            n.style.height = "0",
                            this.animateElementClass(n, e => {
                                e.style.height = t > 0 ? o.px(t) : "auto"
                            })
                        }
                    })
                }
                async show()
                {
                    if (this._isShown)
                        return !0;
                    const e = this.model;
                    if (e.canShow && !e.canShow())
                        return !1;
                    const n = this.component.model.target;
                    return !(!(null == n ? void 0 : n.parentNode) || !n.ownerDocument) && (this.useTitle() ? (this._updateTitleAttr(this.toText(e.contentText)), !1) : (this.model.unique && u.hideTooltipsInDocument(n.ownerDocument), this._isShown = !0, new Promise(t => {
                            this.component.mount();
                            const e = this.component.element;
                            "visible" !== e.style.visibility && (e.style.visibility = "visible"),
                            setTimeout(() => {
                                t(this._show())
                            })
                        }).then(t => t).catch(e => (t.logger.error("Show tooltip error " + e), !1))))
                }
                moveTooltip()
                {
                    const e = this.component.element,
                        i = this.component.model;
                    if (!this.component.model.target || "visible" !== e.style.visibility)
                        return;
                    e.style.width = "auto";
                    const s = e.getBoundingClientRect(),
                        a = parseInt(i.maxWidth);
                    a && (e.style.width = s.width > a ? o.px(a) : "auto");
                    const l = r.getRelativeRect(i.target, e),
                        c = e.getBoundingClientRect();
                    switch (i.stickTo) {
                    case n.stickTo.bottom:
                        e.style.left = o.px0(l.left + (l.width - c.width) / 2),
                        e.style.top = o.px0(l.top + l.height + i.stickDistance);
                        break;
                    case n.stickTo.left:
                        e.style.left = o.px0(l.left - c.width - i.stickDistance),
                        e.style.top = o.px0(l.top + (l.height - c.height) / 2);
                        break;
                    case n.stickTo.right:
                        e.style.left = o.px0(l.left + l.width + i.stickDistance),
                        e.style.top = o.px0(l.top + (l.height - c.height) / 2);
                        break;
                    case n.stickTo.top:
                        e.style.left = o.px0(l.left + (l.width - c.width) / 2),
                        e.style.top = o.px0(l.top - c.height - i.stickDistance);
                        break;
                    default:
                        t.logger.error("Unkonwn tooltip position " + i.stickTo)
                    }
                }
                async hide(t=!0)
                {
                    if (!this._isShown)
                        return;
                    this._isShown = !1;
                    const e = this.model,
                        n = this.component.anchors.box;
                    return this._onHide(), new Promise(t => {
                        this.applyAnimationClass(n, e.animateFunction + "-to", e.animateFunction + "-from", () => {
                            this._isShown || this.resetTooltipPosition(),
                            t()
                        })
                    }).then(() => {
                        t && this.unmount()
                    }).catch(t => {})
                }
                _updateTitleAttr(t)
                {
                    const e = this.target,
                        n = this._cachedTitle ? `${this._cachedTitle} (${this.toText(t)})` : this.toText(t);
                    e.setAttribute("title", n)
                }
                _updateTitleContent(t)
                {
                    if (!this._isShown)
                        return;
                    const {text: e, moreText: n} = t.component.anchors;
                    e && t.contentText && (e.innerHTML = this.toText(t.contentText)),
                    t.contentMore && n && (n.innerHTML = this.toText(t.contentMore))
                }
                toText(t, e=!1)
                {
                    return "function" == typeof t ? t(this, e) : String(t)
                }
                _show()
                {
                    if (!this._isShown)
                        return !1;
                    this.addEventCallback({
                        event: "hide",
                        cb: r.attachGlobalObservers([this.element, this.target], t => {
                            "resize" !== t && "scroll" !== t || this.moveTooltip()
                        }),
                        once: !0
                    }),
                    this.moveTooltip();
                    const t = this.model,
                        e = t.dismissEvents || [],
                        n = () => {
                            this.hide()
                        },
                        i = this.target.ownerDocument.body;
                    return e.forEach(t => i.addEventListener(t, n, !0)), this.addEventCallback({
                        event: "hide",
                        cb: () => {
                            var t;
                            const i = null === (t = this.target) || void 0 === t ? void 0 : t.ownerDocument.body;
                            e.forEach(t => null == i ? void 0 : i.removeEventListener(t, n, !0))
                        },
                        once: !0
                    }), this.applyAnimationClass(this.component.anchors.box, t.animateFunction + "-from", t.animateFunction + "-to"), this._runEventCallbacks("show"), !0
                }
                resetTooltipPosition()
                {
                    if (!this._isShown || this.useTitle())
                        return;
                    const t = this.component.element,
                        e = this.component.anchors.more;
                    t && e && ("collapse" !== t.style.visibility && (t.style.visibility = "collapse"), t.style.left = "-9999px", t.style.top = "-9999px", "none" !== e.style.display && (e.style.display = "none", e.style.visibility = "collapse", e.style.height = "auto"))
                }
                _onDestroy()
                {
                    this._runEventCallbacks("destroy"),
                    this._eventCallbacks.clear()
                }
                _runEventCallbacks(t)
                {
                    const e = this._eventCallbacks.get(t);
                    let n = !1;
                    e.forEach(t => {
                        try {
                            t.cb(this)
                        } catch (t) {}
                        n = n || Boolean(t.once)
                    }),
                    n && this._eventCallbacks.set(t, e.filter(t => !t.once))
                }
                _onHide()
                {
                    this._runEventCallbacks("hide")
                }
                applyAnimationClass(t, e, n, i)
                {
                    const r = this.component.model;
                    if (r.disableAnimation)
                        i && i();
                    else {
                        t.classList.add(e),
                        t.getBoundingClientRect(),
                        t.classList.add("animating"),
                        t.classList.remove(e),
                        t.classList.add(n);
                        let s = !1;
                        const a = () => {
                            s || (s = !0, t.classList.remove("animating"), t.classList.remove(n), null == i || i())
                        };
                        o.attachAnimationCallback({
                            el: t,
                            callback: a,
                            duration: r.animateDuration
                        })
                    }
                }
                animateElementClass(t, e)
                {
                    const n = this.component.model;
                    n.disableAnimation ? e && e(t) : (t.getBoundingClientRect(), o.attachAnimationCallback({
                        el: t,
                        callback: () => {
                            t.classList.remove("animating"),
                            null == e || e(t)
                        },
                        duration: n.animateDuration
                    }), t.classList.add("animating"))
                }
            }
            const l = new Map;
            class c {
                constructor()
                {
                    this.allTooltips = []
                }
                findTooltipByTarget(t)
                {
                    var e;
                    return null !== (e = this.allTooltips.find(e => e.model.target === t)) && void 0 !== e ? e : null
                }
                createTooltip(t)
                {
                    const e = t.target;
                    if (1 !== (null == e ? void 0 : e.nodeType))
                        throw new Error("Can't create tooltip for null or non element target");
                    const n = this.findTooltipByTarget(e);
                    if (n)
                        return n.component.set(t), n;
                    const i = new a;
                    let o,
                        r;
                    function s(t) {
                        const e = t.target;
                        e === o && (o = null),
                        e === r && (r = null)
                    }
                    function c() {
                        e !== o && i.element !== o && (i.model.persistent ? i.hide() : i.unmount())
                    }
                    function u() {
                        e !== o && i.element !== o || (o = null),
                        e !== r && (i.model.persistent ? setTimeout(c, i.model.hideDelay) : c())
                    }
                    this.allTooltips.push(i),
                    i.addEventCallback({
                        event: "destroy",
                        cb: t => {
                            s(t);
                            const e = this.allTooltips.indexOf(t);
                            e >= 0 && this.allTooltips.splice(e, 1)
                        }
                    }).addEventCallback({
                        event: "hide",
                        cb: s
                    }),
                    i.component.set(Object.assign(Object.assign({}, t), {
                        target: e
                    }));
                    const d = {
                        mouseenter: function() {
                            this !== o && this !== r && (o = this, i.model.unique && function(t, e) {
                                const n = l.get(t);
                                if (null == n ? void 0 : n.length)
                                    if (e) {
                                        const t = n.indexOf(e);
                                        t >= 0 && (clearTimeout(e), n.splice(t, 1))
                                    } else
                                        n.forEach(t => {
                                            clearTimeout(t)
                                        }),
                                        n.length = 0
                            }("show"), function(t, e, n) {
                                l.has(t) || l.set(t, []);
                                const i = setTimeout(() => {
                                    const n = l.get(t),
                                        o = n.indexOf(i);
                                    o >= 0 && n.splice(o, 1),
                                    e()
                                });
                                l.get(t).push(i)
                            }("show", () => {
                                this === o && i.show()
                            }, i.model.delay))
                        },
                        mouseleave: u,
                        focus: function() {
                            i.useTitle() || !/INPUT|TEXTAREA/.test(this.tagName) && "true" !== this.getAttribute("contenteditable") || (r = this, i.showMore())
                        },
                        blur: function() {
                            r === this && (r = null),
                            o !== i.element && i.unmount()
                        }
                    };
                    Object.entries(d).forEach(([t, n]) => {
                        e.addEventListener(t, n)
                    });
                    const h = {
                            mouseenter: function() {
                                o = this
                            },
                            mouseleave: u
                        },
                        g = i.element;
                    return Object.entries(h).forEach(([t, e]) => {
                        g.addEventListener(t, e)
                    }), i.addEventCallback({
                        event: "destroy",
                        cb: t => {
                            var e;
                            const n = t.element,
                                i = null === (e = t.model) || void 0 === e ? void 0 : e.target;
                            n && Object.entries(h).forEach(([t, e]) => {
                                n.removeEventListener(t, e)
                            }),
                            i && Object.entries(d).forEach(([t, e]) => {
                                i.removeEventListener(t, e)
                            })
                        }
                    }), i
                }
                createUserTooltips(e)
                {
                    e.forEach(e => {
                        const n = e.target ? [e.target] : o.getElementsBySelector(e.targetSelector, e.root);
                        if (0 === n.length)
                            return t.logger.warn("create tooltips: no targets found");
                        const s = Object.assign({}, i, e);
                        n.forEach(e => {
                            if (!r.canAttach(e))
                                return t.logger.error("Can't create tooltip in a sibling/parent iframe");
                            s.target = e,
                            this.createTooltip(s)
                        })
                    })
                }
                forAllTips(t, e)
                {
                    (e ? this.allTooltips.filter(e) : this.allTooltips).forEach(e => t(e))
                }
                forAllVisibleTips(t, e)
                {
                    this.allTooltips.filter(t => Boolean(t.isShown)).filter(null != e ? e : () => !0).forEach(e => t(e))
                }
                init(t)
                {
                    const e = Array.isArray(t) ? t : [t];
                    this.createUserTooltips(e)
                }
                refresh(t)
                {
                    this.forAllTips(t => t.refresh(), e => {
                        var n,
                            i,
                            o;
                        return (null === (o = null === (i = null === (n = e.component) || void 0 === n ? void 0 : n.model) || void 0 === i ? void 0 : i.target) || void 0 === o ? void 0 : o.ownerDocument) === t
                    })
                }
                getTooltipByTarget(t)
                {
                    return t ? this.findTooltipByTarget(t) : null
                }
                destroyTooltipsInDocument(t)
                {
                    this.forAllTips(t => t.destroy(), e => {
                        var n,
                            i,
                            o;
                        return (null === (o = null === (i = null === (n = e.component) || void 0 === n ? void 0 : n.model) || void 0 === i ? void 0 : i.target) || void 0 === o ? void 0 : o.ownerDocument) === t
                    })
                }
                destroyTooltipsInElement(t)
                {
                    this.forAllTips(t => t.destroy(), e => {
                        var n,
                            i;
                        return o.isChildOf(null === (i = null === (n = e.component) || void 0 === n ? void 0 : n.model) || void 0 === i ? void 0 : i.target, t)
                    })
                }
                hideTooltipsInDocument(t)
                {
                    this.forAllVisibleTips(t => t.hide(), e => {
                        var n,
                            i,
                            o;
                        return (null === (o = null === (i = null === (n = e.component) || void 0 === n ? void 0 : n.model) || void 0 === i ? void 0 : i.target) || void 0 === o ? void 0 : o.ownerDocument) === t
                    })
                }
                hideTooltipsInElement(t)
                {
                    this.forAllVisibleTips(t => t.hide(), e => {
                        var n,
                            i;
                        return o.isChildOf(null === (i = null === (n = e.component) || void 0 === n ? void 0 : n.model) || void 0 === i ? void 0 : i.target, t)
                    })
                }
                hideElementTooltip(e)
                {
                    const n = t.Tooltips.getTooltipByTarget(e);
                    null == n || n.hide()
                }
                destroyElementTooltip(e)
                {
                    const n = t.Tooltips.getTooltipByTarget(e);
                    null == n || n.destroy()
                }
            }
            let u = null;
            t.Tooltips || (u = new c, Object.defineProperty(t, "Tooltips", {
                writable: !1,
                configurable: !1,
                enumerable: !1,
                value: u
            }))
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            const e = t.$;
            const n = {
                ckeditor: new class {
                    setButtonTitle({editor: n, titles: i})
                    {
                        const o = null == n ? void 0 : n.container;
                        if (!(null == o ? void 0 : o.$))
                            return t.logger.warn("Missing editor top container");
                        const r = e(o.$);
                        Object.keys(i).forEach(t => {
                            const e = t.replace(".", "_"),
                                o = n.ui.get(t),
                                s = null == o ? void 0 : o._.id,
                                a = [".cke_button__" + e];
                            s && a.push("#" + s);
                            const l = a.join(",");
                            r.find(l).each((e, n) => {
                                n.setAttribute("title", i[t]);
                                const o = n.getAttribute("aria-labelledby");
                                o && r.find("#" + o).text(i[t])
                            })
                        })
                    }
                    saveUndo(t, e)
                    {
                        e ? t.undoManager.update() : t.undoManager.save(!0, null, !1)
                    }
                    getEditorUIContainer(t)
                    {
                        var e,
                            n,
                            i;
                        return null !== (i = null === (n = null === (e = null == t ? void 0 : t.element) || void 0 === e ? void 0 : e.getWindow()) || void 0 === n ? void 0 : n.$) && void 0 !== i ? i : null
                    }
                    setCommandsState({editor: e, commands: n, enabled: i, active: o=!1})
                    {
                        let r;
                        n = t.utils.strings.toStringArray(n);
                        const s = !0 === o ? CKEDITOR.TRISTATE_ON : i ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED;
                        for (let t = n.length - 1; t >= 0; --t)
                            r = e.getCommand(n[t]),
                            r && r.setState(s)
                    }
                    updateToolbarSetting(t, e, n)
                    {
                        const i = null == t ? void 0 : t.config;
                        if (!i || !(null == e ? void 0 : e.length))
                            return;
                        const o = "string" == typeof i.toolbar ? "toolbar_" + i.toolbar : "toolbar",
                            r = i[o];
                        if (!Array.isArray(r))
                            return;
                        const s = new RegExp(`^${n}$`, "i"),
                            a = e.filter(t => !1 !== t.toolbar).map(t => t.command);
                        let l = !1;
                        const c = t => {
                                var e;
                                if (!t)
                                    return t;
                                if ("string" == typeof t)
                                    return s.test(t) ? (l = !0, a) : [t];
                                if (Array.isArray(t)) {
                                    const e = [];
                                    for (let n = 0; n < t.length; n++) {
                                        const i = t[n],
                                            o = Array.isArray(i),
                                            r = c(i);
                                        !o && Array.isArray(r) ? e.push(...r) : e.push(r)
                                    }
                                    return e
                                }
                                const n = t;
                                return "object" == typeof n && s.test(n.name) && !(null === (e = n.items) || void 0 === e ? void 0 : e.length) ? (l = !0, [Object.assign(Object.assign({}, t), {
                                    items: a
                                })]) : [n]
                            },
                            u = c(r);
                        l && (i[o] = u)
                    }
                    getSelectedRange(e, n)
                    {
                        var i,
                            o;
                        const r = null === (i = null == e ? void 0 : e.getSelection()) || void 0 === i ? void 0 : i.getNative();
                        let s = (null == r ? void 0 : r.rangeCount) > 0 && r.getRangeAt(0);
                        if (s || n)
                            return s || null;
                        const a = e.editable(),
                            l = null == e ? void 0 : e.getSelection();
                        if (!a || !l)
                            return null;
                        a.isInline() || n || l.isFake || l.reset();
                        const c = l.getRanges(),
                            u = null == c ? void 0 : c[0];
                        if (!u)
                            return null;
                        try {
                            const t = null === (o = a.$) || void 0 === o ? void 0 : o.ownerDocument,
                                e = c[c.length - 1];
                            return s = t.createRange(), s.setStart(u.startContainer.$, u.startOffset), s.setEnd(e.endContainer.$, e.endOffset), 1 === c.length && u.collapsed && s.collapse(), s
                        } catch (e) {
                            return t.logger.debug("Error getting ckeditor selected range", e), null
                        }
                    }
                    setSelectedRange(e, n)
                    {
                        const i = e.getSelection(),
                            o = t => 1 === t.nodeType ? new CKEDITOR.dom.element(t) : 3 === t.nodeType && new CKEDITOR.dom.text(t);
                        try {
                            const t = new CKEDITOR.dom.range(e.document),
                                r = o(n.startContainer);
                            r && t.setStart(r, n.startOffset);
                            const s = r && o(n.endContainer);
                            if (s && t.setEnd(s, n.endOffset), r && s)
                                return i.selectRanges([t]), !0
                        } catch (e) {
                            t.logger.error("setSelectedRange: " + e)
                        }
                        return !1
                    }
                }
            };
            Object.assign(t, n)
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            const e = t.$;
            class n {
                constructor(e, n)
                {
                    this.editor = e,
                    this._svgUpdates = new Set,
                    this._commands = new Map,
                    this._timeoutClient = t.utils.createTimeoutClient(),
                    this._timeoutClient.createTimer("update-svg", {
                        autoDispose: !1,
                        timeoutMSecs: 100,
                        callback: () => {
                            this._updateAllSVG()
                        }
                    }),
                    n >= 50 ? (this._disableButton = (t, e) => {
                        t.setEnabled ? t.setEnabled(!e) : t.setDisabled(e)
                    }, this._activateButton = (t, e) => {
                        t && t.setActive && t.setActive(e)
                    }) : (this._disableButton = (t, e) => {
                        t.disabled(e)
                    }, this._activateButton = (t, e) => {
                        t && t.active && t.active(e)
                    })
                }
                updateSVG(t)
                {
                    this._svgUpdates.add(t),
                    this._timeoutClient.startTimer("update-svg")
                }
                setCommandSVG(n)
                {
                    var i;
                    this._getUIButtonRecord(n.command, {
                        svgData: {
                            iconName: n.iconName,
                            svg: n.svg
                        }
                    });
                    const o = this.editor.getContainer();
                    e(null === (i = null == o ? void 0 : o.ownerDocument) || void 0 === i ? void 0 : i.body).find(".tox-toolbar__group").each((i, o) => {
                        const r = t.utils.dom.findEmptySVG(n.iconName, o);
                        r && e(r).replaceWith(n.svg.svg)
                    })
                }
                setCommandsState(t, e)
                {
                    "string" == typeof t && (t = [t]);
                    for (let n = t.length - 1; n >= 0; --n) {
                        const i = this._getUIButtonRecord(t[n], e);
                        let o = i.button;
                        o && (this._disableButton(o, !i.enabled), "boolean" == typeof i.active && this._activateButton(o, i.active))
                    }
                }
                getCommandState(t)
                {
                    return this._getUIButtonRecord(t)
                }
                dispose()
                {
                    this._commands.clear(),
                    this._timeoutClient.dispose()
                }
                _updateAllSVG()
                {
                    const t = Array.from(this._svgUpdates.values());
                    this._svgUpdates.clear(),
                    t.forEach(t => {
                        const e = this._getUIButtonRecord(t);
                        (null == e ? void 0 : e.svgData) && this.setCommandSVG(Object.assign({
                            command: e.command
                        }, e.svgData))
                    })
                }
                _getUIButtonRecord(t, e)
                {
                    var n,
                        i;
                    let o = this._commands.get(t);
                    if (o && !e)
                        return o;
                    o = null != o ? o : {
                        active: void 0,
                        button: null,
                        command: t,
                        enabled: !1
                    };
                    const r = {
                        button: null !== (n = null == e ? void 0 : e.button) && void 0 !== n ? n : o.button,
                        enabled: "boolean" == typeof (null == e ? void 0 : e.enabled) ? e.enabled : o.enabled,
                        active: "boolean" == typeof (null == e ? void 0 : e.active) ? e.active : o.active,
                        svgData: null !== (i = null == e ? void 0 : e.svgData) && void 0 !== i ? i : o.svgData
                    };
                    return Object.assign(o, r), this._commands.set(t, o), o
                }
            }
            new RegExp("‼⁌Ω", "g");
            const i = /\.svg(\?|$)/i;
            const o = {
                tinymce: new class {
                    getHTMLStringEncoder(e)
                    {
                        const n = t.tinymce.getEditorSetting(e, "entity_encoding") || "named",
                            i = window.tinymce.html.Entities.getEncodeFunc(n);
                        return null != i ? i : null
                    }
                    dialogFromEvent(t)
                    {
                        if (!t)
                            return null;
                        const e = t.dialog || t.win;
                        return "function" == typeof (null == e ? void 0 : e.getData) ? e : null
                    }
                    setSelectedRange(t, e)
                    {
                        var n;
                        const i = null == t ? void 0 : t.selection,
                            o = null === (n = t.getDoc()) || void 0 === n ? void 0 : n.createRange();
                        return !(!i || !o) && (o.setStart(e.startContainer, e.startOffset), o.setEnd(e.endContainer, e.endOffset), i.setRng(o), !0)
                    }
                    getSelectedRange(t)
                    {
                        var e,
                            n;
                        return (null === (n = null === (e = null == t ? void 0 : t.selection) || void 0 === e ? void 0 : e.getRng) || void 0 === n ? void 0 : n.call(e, !0)) || null
                    }
                    getEditorSetting(t, e)
                    {
                        var n;
                        return "function" == typeof (null === (n = t.options) || void 0 === n ? void 0 : n.get) ? t.options.get(e) : t.settings ? t.settings[e] : "function" == typeof t.getParam ? t.getParam(e) : null
                    }
                    setEditorSetting(e, n, i)
                    {
                        var o;
                        try {
                            if ("function" == typeof (null === (o = e.options) || void 0 === o ? void 0 : o.set))
                                return void e.options.set(n, i);
                            if (e.settings)
                                return void (e.settings[n] = i);
                            t.logger.warn(`can't set editor setting ${n} to ${i}`)
                        } catch (e) {
                            t.logger.error(`set editor setting ${n} to ${i}: ${e}`)
                        }
                    }
                    saveUndo(t, e)
                    {
                        const n = t.undoManager;
                        null == n || n.add()
                    }
                    getEditorUIContainer(t)
                    {
                        var e,
                            n;
                        const i = null == t ? void 0 : t.getContainer();
                        return null !== (n = null === (e = null == i ? void 0 : i.ownerDocument) || void 0 === e ? void 0 : e.defaultView) && void 0 !== n ? n : null
                    }
                    applyToolbarConfiguration(e, n, i)
                    {
                        if (!n || !(null == i ? void 0 : i.length))
                            return;
                        const o = i.filter(t => !1 !== t.toolbar).map(t => t.command),
                            r = new RegExp(`\\b${n}([\\s|]|$)`, "i");
                        function s(n) {
                            const i = t.tinymce.getEditorSetting(e, n);
                            return !!i && (Array.isArray(i) ? i.forEach((t, e) => {
                                    if (!t)
                                        return;
                                    const n = typeof t;
                                    "string" === n && r.test(t) ? i[e] = t.replace(r, o.join(" ")) : "object" === n && r.test(t.name) && (!t.items || Array.isArray(t.items) && !t.items.length) && (t.items = o.slice())
                                }) : "string" == typeof i && r.test(i) && t.tinymce.setEditorSetting(e, n, i.replace(r, o.join(" "))), !0)
                        }
                        s("toolbar");
                        for (let t = 1; t < 10; ++t)
                            s("toolbar" + t)
                    }
                    createButtonHandler(t, e)
                    {
                        return new n(t, e)
                    }
                    addCommandAndButton(t)
                    {
                        return t.editorVersion >= 50 ? this.addButton5(t) : this.addButton4(t)
                    }
                    loadToolbarIcons({editorVersion: e, editor: n, commands: o, handler: r})
                    {
                        if (e < 50)
                            return Promise.resolve(!1);
                        const s = (o = o.filter(t => t.iconName && !t.svg && i.test(t.iconUrl))).map(async e => {
                            const i = await t.utils.pluginUtils.svgCache.loadIcon(e.iconUrl, e.iconName);
                            return i ? (this._redefineIcon(n, e.iconName, i), r.setCommandSVG({
                                iconName: e.iconName,
                                command: e.command,
                                svg: i
                            }), !0) : (t.logger.error("Failed to load icon from " + e.iconUrl), !1)
                        });
                        return Promise.all(s).then(e => {
                            const n = !e.includes(!1);
                            return t.logger.debug("Loaded icons, success: " + n), n
                        }).catch(e => (t.logger.error("Error loading icons " + e), !1))
                    }
                    addButton4({editor: e, command: n, handler: i})
                    {
                        if (e.addCommand(n.command, n.callback, this), !1 === n.toolbar)
                            return;
                        if (!n.iconUrl)
                            return t.logger.warn(`Can't add button ${n.command}, no icon url`);
                        const o = {
                            tooltip: n.title,
                            image: n.iconUrl,
                            cmd: n.command,
                            onPostRender: t => {
                                i.setCommandsState(n.command, {
                                    button: t.control
                                })
                            }
                        };
                        e.addButton(n.name || n.command, o)
                    }
                    addButton5({editor: e, command: n, handler: o})
                    {
                        const r = e;
                        if (r.addCommand(n.command, n.callback, this), !1 === n.toolbar)
                            return;
                        const s = t.utils.pluginUtils.svgCache.getByPath(n.iconUrl);
                        if (s)
                            this._redefineIcon(e, n.iconName, s);
                        else if (n.svg)
                            r.ui.registry.addIcon(n.iconName, n.svg);
                        else {
                            if (!n.iconUrl)
                                return t.logger.warn("Missing svg AND iconUrl for command " + n.command);
                            if (!i.test(n.iconUrl))
                                return t.logger.warn(`Tinymce supports only svg icons, ${n.iconUrl} can't be displayed. command ${n.command} will not be added to the toolbar`);
                            r.ui.registry.addIcon(n.iconName, t.utils.dom.getEmptySVG(24, 24, n.iconName))
                        }
                        const a = {
                            tooltip: n.title,
                            disabled: !1,
                            icon: n.iconName,
                            onAction: () => {
                                r.execCommand(n.command)
                            },
                            onSetup: t => {
                                o.setCommandsState(n.command, {
                                    button: t
                                }),
                                o.updateSVG(n.command)
                            }
                        };
                        r.ui.registry.addToggleButton(n.command, a)
                    }
                    _redefineIcon(t, e, n)
                    {
                        n.setAttributes({
                            className: "loopindex-button"
                        }).setAttributes({
                            selector: "path",
                            className: "loopindex-svg-icon"
                        }),
                        t.ui.registry.addIcon(e, n.html)
                    }
                }
            };
            Object.assign(t, o)
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            const e = t.$;
            class n {
                constructor(t)
                {
                    this.editor = t,
                    this._commands = new Map,
                    this._refresh = new Map,
                    this._refreshTimeout = 0
                }
                setCommandsState(e, n, i=!0)
                {
                    for (let i = (e = t.utils.strings.toStringArray(e)).length - 1; i >= 0; --i)
                        this._scheduleRefresh(e[i], n)
                }
                async loadCommandSVG(e, n)
                {
                    if (!/.svg$/i.test(n))
                        return !1;
                    const i = await t.utils.pluginUtils.svgCache.loadIcon(n);
                    return !!i && (this._setCommandSVG(e, i), !0)
                }
                getCommandState(t)
                {
                    return this._getUIButtonRecord(t)
                }
                dispose()
                {
                    this._commands.clear(),
                    this._refresh.clear(),
                    this._refreshTimeout && (clearTimeout(this._refreshTimeout), this._refreshTimeout = 0)
                }
                _setCommandSVG(t, e)
                {
                    const n = this._getUIButtonRecord(t);
                    n.button ? this._setButtonSVG(n.button, e) : this._scheduleRefresh(t, {
                        svg: e
                    })
                }
                _setButtonSVG(t, n)
                {
                    n.setAttributes({
                        className: "loopindex-button"
                    }).setAttributes({
                        selector: "path",
                        className: "loopindex-svg-icon"
                    });
                    const i = t.find("svg");
                    if (i.length) {
                        const t = n.svg,
                            o = i[0];
                        o.className && e(t).addClass(o.className),
                        ["focusable"].forEach(e => {
                            const n = o.getAttribute(e);
                            n && t.setAttribute(e, n)
                        }),
                        i.replaceWith(t)
                    } else
                        t.empty(),
                        t.append(n.svg)
                }
                _getUIButtonRecord(t, e)
                {
                    var n;
                    let i = this._commands.get(t);
                    return i && !e || (i = null != i ? i : {
                        active: void 0,
                        button: null,
                        command: t,
                        enabled: !1,
                        title: ""
                    }, Object.assign(i, {
                        button: null !== (n = null == e ? void 0 : e.button) && void 0 !== n ? n : i.button,
                        enabled: "boolean" == typeof (null == e ? void 0 : e.enabled) ? e.enabled : i.enabled,
                        active: "boolean" == typeof (null == e ? void 0 : e.active) ? e.active : i.active,
                        title: (null == e ? void 0 : e.title) || i.title,
                        svg: (null == e ? void 0 : e.svg) || i.svg
                    }), this._commands.set(t, i)), Object.assign({}, i)
                }
                _highlightButton(t, e)
                {
                    void 0 !== e && t.toggleClass("flite-froala-button-highlight", e).toggleClass("fr-active", e)
                }
                _setButtonTitle(t, e)
                {
                    t.attr({
                        "aria-label": e,
                        title: e
                    })
                }
                _enableButton(t, e)
                {
                    t.toggleClass("fr-disabled", !e),
                    e || this._highlightButton(t, !1)
                }
                _scheduleRefresh(t, e)
                {
                    if (!e)
                        return;
                    const n = this._refresh.get(t);
                    n ? (Object.entries(e).forEach(([t, e]) => {
                        (e || !1 === e) && (n[t] = e)
                    }), this._refresh.set(t, n)) : this._refresh.set(t, e),
                    this._refreshTimeout || setTimeout(() => {
                        this._refreshTimeout = 0,
                        this._refreshAll()
                    }, 10)
                }
                _refreshAll()
                {
                    if (0 !== this._refresh.size)
                        try {
                            this._refresh.forEach((t, e) => {
                                this._rendereAndUpdateButton(e, t)
                            })
                        } catch (e) {
                            t.logger.error("While refreshing tinymce buttons: " + e)
                        } finally {
                            this._refresh.clear()
                        }
                }
                _rendereAndUpdateButton(t, e)
                {
                    var n;
                    e = null != e ? e : {};
                    const i = this._getUIButtonRecord(t),
                        o = null !== (n = e.button) && void 0 !== n ? n : i.button;
                    if (!o)
                        return void this._getUIButtonRecord(t, e);
                    if (Boolean(e.button && e.button !== i.button)) {
                        const n = this._getUIButtonRecord(t, e);
                        return this._enableButton(o, n.enabled), this._highlightButton(o, n.active), this._setButtonTitle(o, n.title), void (n.svg && this._setButtonSVG(o, n.svg))
                    }
                    "boolean" == typeof e.enabled && i.enabled !== e.enabled && this._enableButton(o, e.enabled),
                    "boolean" == typeof e.active && i.active !== e.active && this._highlightButton(o, e.active),
                    e.title && e.title !== i.title && this._setButtonTitle(o, e.title),
                    this._getUIButtonRecord(t, e)
                }
            }
            const i = {
                froala: new class {
                    createButtonHandler(t)
                    {
                        return new n(t)
                    }
                    getSelectedRange(t)
                    {
                        var e,
                            n;
                        const i = null === (e = null == t ? void 0 : t.selection) || void 0 === e ? void 0 : e.ranges;
                        return null !== (n = null == i ? void 0 : i(0)) && void 0 !== n ? n : null
                    }
                    setSelectedRange(t, e)
                    {
                        var n,
                            i;
                        const o = t.selection.get(),
                            r = null === (i = null === (n = t.el) || void 0 === n ? void 0 : n.ownerDocument) || void 0 === i ? void 0 : i.createRange();
                        return !!r && (r.setStart(e.startContainer, e.startOffset), r.setEnd(e.endContainer, e.endOffset), o.addRange(r), t.selection.save(), t.selection.restore(), !0)
                    }
                    getEditorUIContainer(t)
                    {
                        var e,
                            n,
                            i,
                            o,
                            r;
                        const s = (null === (e = null == t ? void 0 : t.$tb) || void 0 === e ? void 0 : e.length) ? t.$tb : (null === (n = null == t ? void 0 : t.$box) || void 0 === n ? void 0 : n.length) ? t.$box : null;
                        return null !== (r = null === (o = null === (i = null == s ? void 0 : s[0]) || void 0 === i ? void 0 : i.ownerDocument) || void 0 === o ? void 0 : o.defaultView) && void 0 !== r ? r : null
                    }
                }
            };
            Object.assign(t, i)
        }(window.LOOPINDEX),
        function(t) {
            const e = t.LOOPINDEX;
            if (!e || "object" != typeof e)
                throw new Error("global.LOOPINDEX must be defined");
            t.LANCE && "object" == typeof t.LANCE || (t.LANCE = e.LANCE = {}, Object.defineProperty(e.LANCE, "logger", {
                value: e.createLogger("Lance"),
                writable: !1,
                configurable: !1
            }), function() {
                const t = [];
                let n = null;
                if ("object" == typeof CKEDITOR && CKEDITOR.document) {
                    const i = CKEDITOR.document.getWindow;
                    CKEDITOR.document.getWindow = function(...o) {
                        const r = i.apply(CKEDITOR.document, o);
                        return t.push(r), n && e.LANCE.overrideViewPaneSize(n), r
                    }
                }
                e.LANCE.overrideViewPaneSize = function(e) {
                    n = e,
                    t.forEach((function(t) {
                        if (!t.__OVERRIDE_GVPS__) {
                            const n = t.getViewPaneSize;
                            t.__OVERRIDE_GVPS__ = !0,
                            t.getViewPaneSize = function(...i) {
                                const o = n.apply(t, i);
                                return e(o)
                            }
                        }
                    }))
                }
            }())
        }(window),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            const e = null == t ? void 0 : t.LANCE,
                n = null == t ? void 0 : t.$;
            if (!e || !n)
                throw new Error("Cannot initialize Lance Utils without Lance globals");
            if (e.lanceUtils)
                return;
            class i {
                constructor({width: t, height: e, left: n, top: i})
                {
                    this.width = Math.round(Math.max(t || 0, 0)),
                    this.height = Math.round(Math.max(e || 0, 0)),
                    this.x = this.left = Math.round(n),
                    this.y = this.top = Math.round(i),
                    this.bottom = this.top + this.height,
                    this.right = this.left + this.width
                }
                static Empty()
                {
                    return new i({
                        width: 0,
                        top: 0,
                        left: 0,
                        height: 0
                    })
                }
                static clone(t)
                {
                    return new i(t)
                }
                static isEmpty(t)
                {
                    return !((null == t ? void 0 : t.width) > 0 && t.height > 0)
                }
                static shift(t, e, n)
                {
                    return new i({
                        left: t.left + e,
                        top: t.top + n,
                        width: t.width,
                        height: t.height
                    })
                }
                static intersect(t, e)
                {
                    const n = Math.max(t.left, e.left),
                        o = Math.max(t.top, e.top),
                        r = Math.min(t.right, e.right) - n,
                        s = Math.min(t.bottom, e.bottom) - o;
                    return new i({
                        left: n,
                        top: o,
                        width: r,
                        height: s
                    })
                }
                static offset(t, e, n)
                {
                    return new i({
                        left: t.left + e,
                        top: t.top + n,
                        width: t.width,
                        height: t.height
                    })
                }
                static inset(t, e, n)
                {
                    return void 0 === n && (n = e), new i({
                        left: t.left + .5 * e,
                        top: t.top + .5 * n,
                        width: t.width - e,
                        height: t.height - n
                    })
                }
                intersect(t)
                {
                    return i.intersect(this, t)
                }
                inset(t, e)
                {
                    return i.inset(this, t, e)
                }
            }
            class o {
                insetRect(t, e, n)
                {
                    return i.inset(t, e, n)
                }
                getElementClampInWindowValues({rect: t, margin: e, win: n})
                {
                    const o = (n = n || window.top).document.documentElement,
                        r = o.clientHeight,
                        s = o.clientWidth;
                    let a = new i({
                        left: 0,
                        top: 0,
                        width: s,
                        height: r
                    });
                    if (e) {
                        let t = 0,
                            n = 0;
                        "number" == typeof e ? t = n = e : (t = e.x, n = e.y),
                        a = a.inset(t, n)
                    }
                    return this.getRectsShiftDelta(t, a)
                }
                getElementGlobalBoundingBox(e, n=window.top)
                {
                    const o = t.utils.dom.toElement(e);
                    if (this.getOwnerWindow(o) === n)
                        return o.getBoundingClientRect();
                    const r = this.getOwnerIframe(o);
                    if (null == r)
                        return o.getBoundingClientRect();
                    const s = [new i(o.getBoundingClientRect())];
                    let a = r;
                    for (; a;) {
                        const t = this.getBoundingClientRectWithBorderOffset(a);
                        if (s.push(t), a = this.getOwnerIframe(a), a && this.getOwnerWindow(a) === n) {
                            const t = this.getBoundingClientRectWithBorderOffset(a);
                            s.push(t);
                            break
                        }
                    }
                    return this.mergeRectOffsets(s)
                }
                getElementRects(e)
                {
                    let n = null,
                        o = null,
                        r = !0;
                    for (let s = t.utils.dom.toElement(e); s; s = this.getOwnerIframe(s)) {
                        const t = new i(s.getBoundingClientRect()),
                            e = s.ownerDocument.documentElement,
                            a = new i({
                                left: 0,
                                top: 0,
                                width: e.clientWidth,
                                height: e.clientHeight
                            });
                        n && o ? (o = i.offset(o, t.left, t.top), n = r ? i.offset(n, t.left, t.top) : n) : o = n = t,
                        r && (n = i.intersect(n, a), r = !i.isEmpty(n))
                    }
                    return {
                        full: null != o ? o : i.Empty(),
                        visible: r ? n : null
                    }
                }
                constrainElementIn(t, e, n=window.top)
                {
                    const i = this.getElementGlobalBoundingBox(t, n),
                        o = this.getElementRects(e);
                    return {
                        target: {
                            full: i,
                            visible: null
                        },
                        box: o,
                        shiftBy: this.getRectsShiftDelta(i, o.visible)
                    }
                }
                getRectsShiftDelta(t, e)
                {
                    const n = {
                        x: 0,
                        y: 0
                    };
                    if (i.isEmpty(t) || i.isEmpty(e))
                        return n;
                    const o = Math.max(0, Math.round(e.top - t.top)),
                        r = Math.min(0, Math.round(e.bottom - t.bottom));
                    o >= 1 ? n.y = o : r <= -1 && (n.y = r);
                    const s = Math.max(0, Math.round(e.left - t.left)),
                        a = Math.min(0, Math.round(e.right - t.right));
                    return s >= 1 ? n.x = s : a <= -1 && (n.x = a), n
                }
                getElementDimensions(t)
                {
                    return {
                        borderLeft: parseFloat(t.borderLeftWidth),
                        borderRight: parseFloat(t.borderRightWidth),
                        borderTop: parseFloat(t.borderTopWidth),
                        borderBottom: parseFloat(t.borderBottomWidth),
                        marginLeft: parseFloat(t.marginLeft),
                        marginRight: parseFloat(t.marginRight),
                        marginTop: parseFloat(t.marginTop),
                        marginBottom: parseFloat(t.marginBottom),
                        paddingLeft: parseFloat(t.paddingLeft),
                        paddingRight: parseFloat(t.paddingRight),
                        paddingTop: parseFloat(t.paddingTop),
                        paddingBottom: parseFloat(t.paddingBottom)
                    }
                }
                getOwnerWindow(t)
                {
                    var e;
                    return null === (e = t.ownerDocument) || void 0 === e ? void 0 : e.defaultView
                }
                getOwnerIframe(t)
                {
                    const e = this.getOwnerWindow(t);
                    return null == e ? void 0 : e.frameElement
                }
                getBoundingClientRectWithBorderOffset(t)
                {
                    const e = t.ownerDocument.defaultView.getComputedStyle(t);
                    if ("border-box" === e.boxSizing)
                        return t.getBoundingClientRect();
                    const n = this.getElementDimensions(e);
                    return this.mergeRectOffsets([new i(t.getBoundingClientRect()), new i({
                        top: n.borderTop,
                        left: n.borderLeft,
                        width: 0,
                        height: 0
                    })])
                }
                mergeRectOffsets(t)
                {
                    const e = new i(t[0]);
                    let n = 0,
                        o = 0;
                    for (let e = 1; e < t.length; e++) {
                        const i = t[e];
                        n += i.width,
                        o += i.height
                    }
                    return i.shift(e, n, o)
                }
            }
            function r(t) {
                const e = typeof t;
                return "string" == e || "number" == e ? new Date(1e3 * Number(t)) : t
            }
            const s = [{
                regex: /%MMM/g,
                replacer: function(t) {
                    return t.localizeFunction("months." + t.date.getMonth())
                }
            }, {
                regex: /%MM/g,
                replacer: function(e) {
                    return t.utils.strings.padNumber(e.date.getMonth() + 1, 2)
                }
            }, {
                regex: /%M/g,
                replacer: function(t) {
                    return t.localizeFunction("full_months." + t.date.getMonth())
                }
            }, {
                regex: /%YY/g,
                replacer: function(t) {
                    return String(t.date.getFullYear() % 100)
                }
            }, {
                regex: /%Y/g,
                replacer: function(t) {
                    return String(t.date.getFullYear())
                }
            }, {
                regex: /%hh/g,
                replacer: function(e) {
                    return t.utils.strings.padNumber(e.date.getHours(), 2)
                }
            }, {
                regex: /%h/g,
                replacer: function(t) {
                    return String(t.date.getHours())
                }
            }, {
                regex: /%ma/g,
                replacer: function(t) {
                    return String(t.localDictionary.minutesAgo)
                }
            }, {
                regex: /%mm/g,
                replacer: function(e) {
                    return t.utils.strings.padNumber(e.date.getMinutes(), 2)
                }
            }, {
                regex: /%m/g,
                replacer: function(t) {
                    return String(t.date.getMinutes())
                }
            }, {
                regex: /%dd/g,
                replacer: function(e) {
                    return t.utils.strings.padNumber(e.date.getDate(), 2)
                }
            }, {
                regex: /%d/g,
                replacer: function(t) {
                    return String(t.date.getDate())
                }
            }, {
                regex: /%F/g,
                replacer: function(t) {
                    return String(t.localDictionary.dateString)
                }
            }, {
                regex: /\[\[([^\]]+)\]\]/g,
                replacer: function(t, e, n) {
                    return t.localizeFunction(n)
                }
            }];
            function a(t, e, n, i) {
                let o;
                const r = {
                    date: e,
                    localizeFunction: n,
                    localDictionary: i
                };
                for (let e = 0, n = s.length; e < n; ++e)
                    o = s[e],
                    o.regex.test(t) && (t = t.replace(o.regex, (function(t, e) {
                        return o.replacer(r, t, e)
                    })));
                return t
            }
            const l = {
                lanceUtils: new class {
                    constructor()
                    {
                        this.boundsProcessor = new o
                    }
                    get Rect()
                    {
                        return i
                    }
                    addEventsMixinGlue(t)
                    {
                        Object.assign(t, {
                            on: function(...t) {
                                return this.events.on(...t)
                            },
                            off: function(...t) {
                                return this.events.off(...t)
                            }
                        })
                    }
                    LANCE_UI_EVENT(t)
                    {
                        if (!t)
                            return ".lance-ui";
                        return t.split(/\s/).map(t => t + ".lance-ui").join(" ")
                    }
                    isReadonly(e)
                    {
                        if (!e)
                            return !1;
                        const n = t.utils.dom.toElement(e),
                            i = null == n ? void 0 : n.hasAttribute("readonly");
                        return Boolean(i)
                    }
                    formatDate(t, n, i)
                    {
                        if (!n)
                            return e.lanceUtils.relativeDateFormat(t, i);
                        const o = new Date,
                            s = r(t),
                            l = {
                                dateString: s.toLocaleDateString()
                            },
                            c = Math.floor((o.getTime() - s.getTime()) / 6e4);
                        return l.minutesAgo = c, a(n, s, i, l)
                    }
                    relativeDateFormat(e, n)
                    {
                        if (!e)
                            return "";
                        const i = new Date,
                            o = i.getDate(),
                            s = i.getMonth(),
                            l = i.getFullYear(),
                            c = n || (t => t);
                        let u,
                            d,
                            h;
                        const g = r(e),
                            m = {
                                dateString: g.toLocaleDateString()
                            };
                        return o == g.getDate() && s == g.getMonth() && l == g.getFullYear() ? (d = Math.floor((i.getTime() - g.getTime()) / 6e4), m.minutesAgo = d, d < 1 ? c("now") : d < 2 ? c("1 minute ago") : d < 60 ? (u = c("minutes ago"), u ? a(u, g, c, m) : d + "minutes ago") : (u = c("on time"), u ? a(u, g, c, m) : (h = g.getHours(), d = g.getMinutes(), "on " + t.utils.strings.padNumber(h, 2) + ":" + t.utils.strings.padNumber(d, 2)))) : l == g.getFullYear() ? (u = c("on date"), u ? a(u, g, c, m) : `on ${c("months." + g.getMonth(), "")} ${g.getDate()}`) : (u = c("on full date"), u ? a(u, g, c, m) : g.toLocaleDateString())
                    }
                    timeOfTimestamp(e)
                    {
                        if (!e)
                            return "";
                        const n = r(e),
                            i = n.getHours(),
                            o = n.getMinutes();
                        return t.utils.strings.padString(i, 2, "0") + ":" + t.utils.strings.padString(o, 2, "0")
                    }
                    escapeRegExp(t)
                    {
                        return (t || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
                    }
                }
            };
            Object.assign(e, l)
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            const e = null == t ? void 0 : t.LANCE,
                n = null == t ? void 0 : t.$;
            if (!e || !n)
                throw new Error("Cannot initialize plugin utils without Lance globals");
            if (e.lancePluginUtils)
                return;
            let i,
                o;
            const r = t.browser.msie ? () => !0 : t => ({
                behavior: t,
                block: "center"
            });
            let s = 0;
            function a(t, i) {
                const o = /^he.d/i,
                    r = n(window.document).find("html>*").filter((t, e) => o.test(e.nodeName || ""))[0],
                    s = n.extend(!0, {}, t.config("annotations"), {
                        hostOptions: r ? n(r) : null
                    });
                s.owner = t;
                const a = new e.Annotations(s);
                return a.enable(i), a
            }
            const l = [{
                    regex: /%([\da-zA-Z])?S/g,
                    replacer: (t, e) => {
                        const n = e.map(t => `${t.userName}: ${t.text}`).map(t => t.length > 25 ? t.substring(0, 25) + "…" : t).join("\n");
                        return n.length > 80 ? n.substring(0, 80) + "…" : n
                    }
                }, {
                    regex: /%([\da-zA-Z])?C/g,
                    replacer: (t, e) => {
                        const n = e.map(t => t.text).map(t => t.length > 25 ? t.substring(0, 25) + "…" : t).join("\n");
                        return n.length > 80 ? n.substring(0, 80) + "…" : n
                    }
                }, {
                    regex: /%([\da-zA-Z])?U/g,
                    replacer: (t, e) => e.map(t => t.userName).join("\n")
                }],
                c = new Set(["Shift", "Alt", "Control", "CapsLock", "Fn", "Meta", "NumLock", "ScrollLock", "Enter", "Backspace", "Clear", "Copy", "Delete"]);
            e.Commands = {
                ANNOTATE: "annotate",
                RESOLVE_ALL: "lance-resolve-all"
            },
            e.CommandNames = Array.from(Object.values(e.Commands));
            const u = [{
                command: e.Commands.ANNOTATE,
                title: "insert comment",
                iconUrl: "icons/svg/%THEME%/add-comment.svg",
                undo: !1
            }, {
                command: e.Commands.RESOLVE_ALL,
                title: "resolve all",
                toolbar: !1,
                iconUrl: "icons/svg/%THEME%/resolve-all.svg",
                undo: !0
            }];
            function d(t, e) {
                const n = [];
                e.count();
                if (/^\d+$/.test(t)) {
                    const i = parseInt(t);
                    n.push(e.getCommentByIndex(i - 1))
                } else if ("L" === t)
                    n.push(e.getCommentByIndex(e.count() - 1));
                else if ("A" === t)
                    for (let t = 0, i = e.count(); t < i; ++t)
                        n.push(e.getCommentByIndex(t));
                else
                    n.push(e.getCommentByIndex(0));
                return n.filter(Boolean)
            }
            const h = [];
            class g {
                createNodeManager(...t)
                {
                    return new p(...t.map(t => new f(t)))
                }
                validateAnnotations(t)
                {
                    const n = t.nodeManager.findAnnotationNodes({
                            allowDuplicates: !1
                        }),
                        i = [];
                    return n.forEach(n => {
                        var o,
                            r;
                        try {
                            const s = n.getAttribute(e.lancePluginUtils.pluginAttributes.annotationId),
                                a = e.Annotations.extractAnnotation(n);
                            if (!a)
                                return;
                            if (a.id !== s)
                                return i.push(`Mismatch between id ${s} and found id ${a.id}`);
                            const l = t.getAnnotations().getAnnotationById(s);
                            if (!l)
                                return i.push("No annotation found for node with annotation id " + s);
                            if (l.comments.length !== (null === (o = a.comments) || void 0 === o ? void 0 : o.length))
                                return i.push(`Comment array length mismatch, doc: ${null === (r = a.comments) || void 0 === r ? void 0 : r.length}, data: ${l.comments.length}`);
                            l.comments.forEach((t, e) => {
                                const n = a.comments[e];
                                n.userId !== t.userId && i.push(`Comment ${e} user id mismatch, ${n.userId} !== ${t.userId}`),
                                n.text !== t.text && i.push(`Comment ${e} text mismatch, ${n.userId} !== ${t.userId}`)
                            })
                        } catch (t) {
                            i.push(String(t))
                        }
                    }), i.join("\n")
                }
                resolveAll(t)
                {
                    return t.isEnabled ? t.getAnnotations().resolveAll() : []
                }
                getCommands(e)
                {
                    return t.utils.pluginUtils.upgradeConfigCommands(u, e)
                }
                initLocaleServer(e, n)
                {
                    t.utils.LocaleServer.hasDomain("lance") || t.utils.LocaleServer.defineDomain({
                        domain: "lance",
                        locales: ["en", "de", "fr", "nl", "es"],
                        defaultLocale: e || "en",
                        assetPath: t.utils.strings.joinPath(n, "lang"),
                        urlParams: {
                            v: "1.9.10",
                            b: "Feb 06/02:18"
                        }
                    }).loadLocales("lance", {
                        de: {
                            "insert comment": "Kommentar einfügen",
                            "resolve all": "Alle Kommentare auflösen"
                        },
                        en: {
                            "insert comment": "Add a Comment",
                            "resolve all": "Resolve all comments"
                        },
                        es: {
                            "insert comment": "Insertar comentario",
                            "resolve all": "Resolver todos los comentarios"
                        },
                        fr: {
                            "insert comment": "Entrez commentaire",
                            "resolve all": "Résoudre tous les commentaires"
                        },
                        nl: {
                            "insert comment": "Reactie toevoegen",
                            "resolve all": "Los alle opmerkingen op"
                        }
                    })
                }
                demoNotice()
                {
                    t.utils.alertManager.alert({
                        text: "This feature is disabled in the demo version"
                    }).then(() => {})
                }
                processAnnotationChanged({event: t, plugin: n, callback: i, type: o})
                {
                    const r = null == t ? void 0 : t.annotation;
                    if (!r)
                        return;
                    n.nodeManager.findAnnotationNodesForId(r.id).each((t, o) => {
                        e.lancePluginUtils.populateAnnotationNode({
                            plugin: n,
                            node: o,
                            annotation: r,
                            saveFullContent: 0 === t
                        }),
                        i && i(r, o, t)
                    });
                    const s = n.config("undoPolicy");
                    "all" !== s && ("create" !== s || "create" !== o && "delete" !== o) || n.fireEditorEvent("change")
                }
                getNodeAnnotationId(t)
                {
                    var n;
                    const i = null == t ? void 0 : t.nodeType,
                        o = 3 === i ? t.parentNode : 1 === i ? t : null;
                    return o && null !== (n = o.getAttribute(e.lancePluginUtils.pluginAttributes.annotationId)) && void 0 !== n ? n : ""
                }
                initLancePlugin({config: n, plugin: i, locale: o, isEnabled: r})
                {
                    const s = i._finalizeConfiguration(this.validateConfiguration(n));
                    e.logger.config(s.debug),
                    t.logger.config(s.debug),
                    t.utils.pluginUtils.addPluginProperty(i, {
                        key: "_config",
                        value: s
                    }),
                    t.utils.pluginUtils.initLoopindexPlugin(i),
                    Object.defineProperty(i, "isEnabled", {
                        get: function() {
                            return this._manager.isEnabled()
                        },
                        configurable: !1,
                        enumerable: !1
                    }),
                    Object.defineProperty(i, "statusCallback", {
                        get: function() {
                            var t;
                            return null !== (t = this._config.statusCallback) && void 0 !== t ? t : null
                        },
                        configurable: !1,
                        enumerable: !1
                    }),
                    Object.defineProperty(i, "users", {
                        get: function() {
                            return this._manager.users
                        },
                        configurable: !1,
                        enumerable: !1
                    }),
                    t.utils.pluginUtils.addPluginProperty(i, {
                        key: "App",
                        value: t.LANCE
                    });
                    const l = {
                        _onAnnotationSelected: function(t) {
                            var n,
                                o;
                            const r = null == t ? void 0 : t.annotation;
                            if (!r)
                                return;
                            const s = Boolean(null === (n = t.hostData) || void 0 === n ? void 0 : n.node),
                                a = r.isSelected(),
                                l = this.nodeManager.findAnnotationNodesForId(r.id),
                                c = !s && a && !1 !== this._config.autoScroll;
                            e.lancePluginUtils.selectAnnotationNodes({
                                $nodes: l,
                                annotation: r,
                                reveal: c,
                                plugin: this
                            }),
                            a && !s && (null === (o = i._selectAnnotationNode) || void 0 === o || o.call(i, l, this._config.commentSelectionPolicy))
                        },
                        getAllAnnotationNodesForId: function(t) {
                            return this.nodeManager.findAnnotationNodesForId(t).toArray()
                        },
                        getAnnotationNodeForId: function(t) {
                            var e;
                            return null !== (e = this.nodeManager.findAnnotationNodesForId(t)[0]) && void 0 !== e ? e : null
                        },
                        refreshCommands: function(...t) {
                            const n = new Set(t.length ? t : e.CommandNames),
                                i = {};
                            return n.forEach(t => {
                                const e = this.getCommandState(t);
                                this.setCommandsState(t, e.enabled, e.active),
                                i[t] = e
                            }), i
                        },
                        getCommandState: function(t) {
                            if (t === e.Commands.ANNOTATE) {
                                return i.nodeManager.getCommandState().state
                            }
                            if (t === e.Commands.RESOLVE_ALL) {
                                const t = i.getAnnotations();
                                return {
                                    enabled: t.isEnabled() && t.canResolveAll()
                                }
                            }
                            return e.logger.error("getCommandstate: Unknown command " + t), {
                                enabled: !1
                            }
                        },
                        _monitorCommentEditing: function(n) {
                            const o = this.saveSelection(),
                                r = t => {
                                    l(t.id, !1)
                                },
                                s = t => {
                                    l(t.annotationId, !0 !== t.canceled)
                                },
                                a = () => {
                                    var t;
                                    null === (t = this._manager) || void 0 === t || t.events.off(e.Annotations.Events.DONE_EDITING, s).off(e.Annotations.Events.ANNOTATION_DELETED, r)
                                },
                                l = (e, r) => {
                                    if (e === n) {
                                        const n = this.nodeSynchronizer.stop();
                                        try {
                                            a();
                                            const n = t.utils.dom.saveScrollPosition(this.getBody());
                                            o(!0),
                                            n();
                                            const s = r ? this.getAllAnnotationNodesForId(e) : [];
                                            if (s.length) {
                                                const t = s[s.length - 1];
                                                i.nodeManager.getHandlerForNode(t).collapseAfterNode(s[s.length - 1])
                                            }
                                        } catch (t) {
                                            n()
                                        }
                                    }
                                };
                            this._manager.events.on(e.Annotations.Events.DONE_EDITING, s, this).on(e.Annotations.Events.ANNOTATION_DELETED, r)
                        },
                        getCommands: function() {
                            var t;
                            return (null !== (t = this.config("commands")) && void 0 !== t ? t : u).map(t => Object.assign(Object.assign({}, t), {
                                localized: this.getLocalizedString(t.title)
                            }))
                        },
                        setEnabled: function(t) {
                            this._manager.enable(t)
                        },
                        getLocalizedString: function(t) {
                            return this.localizer.localizeString(t)
                        },
                        setLanguage: function(t) {
                            return this.localizer.loadLocale(t || this.localizer.locale || "en").then(t => {
                                var n;
                                return t || (null === (n = this.getAnnotations()) || void 0 === n || n.events.trigger(e.Annotations.Events.Host.LOCALE_CHANGED), this.onLocaleChanged()), !t
                            })
                        },
                        _onAnnotationsRenumbered: function(t) {
                            const n = t && t.sequence;
                            if (!n || !n.length)
                                return;
                            const i = this.nodeManager.findAnnotationNodes(),
                                o = new Map;
                            i.forEach((function(t) {
                                const n = e.lancePluginUtils.getNodeAnnotationId(t);
                                n && (o.has(n) || o.set(n, []), o.get(n).push(t))
                            })),
                            n.forEach((t, n) => {
                                const i = o.get(t);
                                i && i.forEach(t => t.setAttribute(e.lancePluginUtils.pluginAttributes.annotationSequence, String(n)))
                            })
                        },
                        _maybeSelectAnnotationNode: function(t) {
                            var n;
                            if (!this.isEnabled)
                                return !1;
                            const i = null === (n = null == t ? void 0 : t.getAttribute) || void 0 === n ? void 0 : n.call(t, e.lancePluginUtils.pluginAttributes.annotationId);
                            if (i) {
                                const e = this._pushSelecting(!0);
                                try {
                                    this.getAnnotations().selectAnnotation({
                                        id: i,
                                        select: !0,
                                        hostData: {
                                            focus: !1,
                                            node: t
                                        }
                                    })
                                } catch (t) {} finally {
                                    e()
                                }
                            } else
                                this.getAnnotations().unselectAll();
                            return Boolean(i)
                        },
                        getAnnotations: function() {
                            return this._manager
                        },
                        dispose: function() {
                            var e,
                                n,
                                i,
                                o;
                            null === (e = this._manager) || void 0 === e || e.dispose(),
                            null === (n = this.nodeSynchronizer) || void 0 === n || n.stop(),
                            this.eventManager.removeAll(),
                            null === (i = this.nodeManager) || void 0 === i || i.dispose(),
                            this._timeoutClient.dispose(),
                            this._debounceManager.dispose(),
                            null === (o = this.nodeVisibilityObserver) || void 0 === o || o.dispose(),
                            t.utils.array.remove(h, {
                                test: t => t.plugin === this
                            });
                            delete this.nodeSynchronizer
                        },
                        onKeyUp: function(t) {
                            (null == t ? void 0 : t.key) && c.has(t.key) || this.onSelectionChanged()
                        },
                        getVisibilitySnapshot: function() {
                            const t = e.lancePluginUtils.pluginAttributes.annotationId;
                            return this.nodeVisibilityObserver.getSnapshot().map(e => Object.assign(Object.assign({}, e), {
                                annotationId: e.node.getAttribute(t)
                            }))
                        },
                        onAnnotationResolved: function(t) {
                            const n = t.annotation.isResolved();
                            this.nodeManager.findAnnotationNodesForId(t.annotation.id).attr(e.lancePluginUtils.pluginAttributes.resolved, n ? "true" : null)
                        },
                        _loadCSS: function(e) {
                            var n;
                            const i = null === (n = this.config("styleUrls")) || void 0 === n ? void 0 : n.map(t => this.resolvePath(t)).map(e => t.utils.strings.addParamsToUrl(e, {
                                v: this.version
                            }));
                            new t.utils.CSSLoader(e).loadCSS(i)
                        }
                    };
                    Object.keys(l).forEach(t => {
                        var e;
                        e = {
                            key: t,
                            value: l[t]
                        },
                        Object.defineProperty(i, e.key, {
                            value: e.value,
                            writable: !0 === e.writable,
                            configurable: !1,
                            enumerable: !1
                        })
                    });
                    const d = t.utils.pluginUtils.getPluginAssetPath(i);
                    this.initLocaleServer(o, d),
                    t.utils.pluginUtils.addPluginProperty(i, {
                        key: "version",
                        value: "1.9.10"
                    }),
                    t.utils.pluginUtils.addPluginProperty(i, {
                        key: "localizer",
                        value: t.utils.LocaleServer.createClient("lance")
                    }),
                    t.utils.pluginUtils.addPluginProperty(i, {
                        key: "_manager",
                        value: a(i, !1 !== r)
                    });
                    return i._manager.events.on([e.Annotations.Events.COMMENT_ADDED, e.Annotations.Events.USER_CHANGED, e.Annotations.Events.ANNOTATION_DELETED, e.Annotations.Events.ANNOTATION_RESOLVED, e.Annotations.Events.RELOAD, e.Annotations.Events.RESET], function() {
                        this.refreshCommands(e.Commands.RESOLVE_ALL)
                    }.bind(i), null), i.logEditorEvents(i.config("logEvents")), t.utils.pluginUtils.loadPluginPageStyles(i), i
                }
                get spellingStack()
                {
                    if (void 0 !== i)
                        return i;
                    const t = window.document,
                        e = n(t["th[e]a~d.CKEDITOR".split("").reduce((function(t, e, n, i) {
                            return n < 8 && n % 2 && (t += e), t
                        }), "")]).find("Mm eot anchor".split("").reduce((function(t, e, n, i) {
                            return n < 8 && n % 2 && (t += e), t
                        }), ""));
                    return i = this._updateSpellingStack(e)
                }
                onEditorNodeClicked(t, n)
                {
                    const i = n && (null == t ? void 0 : t.getAnnotations());
                    if (!i)
                        return;
                    const o = t.nodeManager.findAnnotationNode(n),
                        r = null == o ? void 0 : o.getAttribute(e.lancePluginUtils.pluginAttributes.annotationId);
                    r ? i.selectAnnotation({
                        id: r,
                        select: !0,
                        hostData: {
                            focus: !1,
                            node: n
                        }
                    }) : i.unselectAll()
                }
                isInteractiveAnnotation(t)
                {
                    return "interactive" === (null == t ? void 0 : t.mode)
                }
                get pluginAttributes()
                {
                    return g.LANCE_ATTRIBUTES
                }
                annotate(n)
                {
                    const i = null == n ? void 0 : n.getAnnotations();
                    if (!(null == i ? void 0 : i.isEnabled()))
                        return;
                    const o = n.nodeManager.getHandlerForRange();
                    if (!o)
                        return void t.logger.warn("annotate: No matching handler");
                    const r = n.getInsertPosition();
                    if (r < 0)
                        return void e.logger.warn("Cannot insert an annotation in this position");
                    const s = n._pushSelecting(!0),
                        a = n.eventManager.deactivateNativeBinding("selectionchange");
                    try {
                        const t = this.spellingStack || i.insertAnnotation({
                            position: r,
                            context: {
                                mode: o.usesCommentMarkers ? void 0 : "interactive"
                            }
                        });
                        if ("boolean" != typeof t) {
                            const e = n.nodeManager.findAnnotationNodesForId(t.id);
                            e[0] && (i.selectAnnotation({
                                hostData: {},
                                id: t.id,
                                select: !0
                            }), this.selectAnnotationNodes({
                                $nodes: e,
                                annotation: t,
                                plugin: n,
                                reveal: !0
                            }))
                        }
                    } catch (t) {
                        e.logger.error("Error annotating: " + t)
                    } finally {
                        s(),
                        a(0)
                    }
                }
                get CONTENT_EDITABLE_ATTR()
                {
                    return g.ceattr
                }
                getAnnotationNodePosition(n, i)
                {
                    try {
                        if (!i)
                            return 9999999;
                        if (!(null == n ? void 0 : n.length))
                            return 0;
                        const o = n.slice().sort(t.utils.dom.compareNodePosition);
                        let r = 0,
                            s = "";
                        for (let n = 0; n < o.length; n++) {
                            const a = o[n];
                            if (a === i)
                                return r;
                            const l = t.utils.dom.compareNodePosition(i, a),
                                c = e.lancePluginUtils.getNodeAnnotationId(a);
                            if (l <= 0)
                                return c === s ? -1 : r;
                            s !== c && (r++, s = c)
                        }
                        return n.length
                    } catch (t) {}
                    return 0
                }
                validateKey()
                {
                    const t = "api-key-placeholder";
                    if (!/placeholder/.test(t)) {
                        const e = (document.head && document.head.querySelectorAll("meta[name='LANCE-API-KEY']"))[0];
                        return (null == e ? void 0 : e.getAttribute("content")) === t
                    }
                    return !0
                }
                attachNodeVisibilityObserver(t)
                {
                    var n;
                    return null === (n = t.nodeVisibilityObserver) || void 0 === n || n.dispose(), new v({
                        view: null,
                        container: t.getBody(),
                        onVisibility: n => {
                            var i;
                            null === (i = t.getAnnotations()) || void 0 === i || i.events.trigger(e.Annotations.Events.Host.ANNOTATION_NODES_VISIBLITY)
                        },
                        onScroll: n => {
                            var i;
                            null === (i = t.getAnnotations()) || void 0 === i || i.events.trigger(e.Annotations.Events.Host.ANNOTATION_CONTAINER_SCROLL, n)
                        }
                    })
                }
                attachMutationObserver(i, o)
                {
                    let r = null;
                    const s = {
                        start: t.utils.yes,
                        stop: () => t.utils.no
                    };
                    i._debounceManager.removeDebouncer("mutation");
                    const a = i._debounceManager.createDebouncer("mutation", {
                            continuous: !0,
                            timeout: 50,
                            callback: () => {
                                try {
                                    s.stop(),
                                    e.lancePluginUtils.syncNodes(i)
                                } finally {
                                    s.start()
                                }
                            },
                            compare: t.utils.yes
                        }),
                        l = () => {
                            a.add(null, !0)
                        };
                    r = new MutationObserver(t => {
                        const e = function(t, e) {
                            const r = null == t ? void 0 : t.length;
                            if (!(r > 0))
                                return !1;
                            for (let s, a = 0; a < r; ++a) {
                                if (s = n(t[a]), s.is(o) && !i.isDummyElement(s[0].parentNode))
                                    return !0;
                                if (e && s.find(o).length)
                                    return !0
                            }
                            return !1
                        };
                        if (t && t.length)
                            for (let r = t.length - 1; r >= 0; --r) {
                                const s = t[r];
                                if (s && !i.isDummyElement(s.target)) {
                                    if (n(s.target).is(o))
                                        return l();
                                    if (e(s.addedNodes, !0) || e(s.removedNodes, !0))
                                        return l()
                                }
                            }
                    });
                    const c = {
                        childList: !0,
                        subtree: !0
                    };
                    let u = !1;
                    return s.start = () => {
                        u || (u = !0, r.disconnect(), r.observe(i.getBody(), c))
                    }, s.stop = () => {
                        const e = u;
                        return e && (r.disconnect(), u = !1), e ? () => s.start() : t.utils.yes
                    }, s
                }
                selectAnnotationNodes({$nodes: n, annotation: i, reveal: o, plugin: r, callback: s})
                {
                    const a = (null == n ? void 0 : n.length) && n[0];
                    if (!a || a.ownerDocument !== r.getDocument())
                        return;
                    const l = i.isSelected();
                    if (n.attr(e.lancePluginUtils.pluginAttributes.selected, l ? "true" : null), !l)
                        return;
                    s = "function" == typeof s ? s : t.utils.yes;
                    const c = t => {
                        setTimeout(() => {
                            r.getAnnotations().events.trigger(e.Annotations.Events.Host.ANNOTATION_NODE_REVEALED, t || {
                                node: a,
                                annotation: i
                            }),
                            s()
                        }, 1)
                    };
                    !1 === o && c(),
                    this._abortRevealFor(r);
                    const u = this._revealAnnotationNode({
                        node: a,
                        annotation: i,
                        plugin: r,
                        progress: t => {
                            r.getAnnotations().events.trigger(e.Annotations.Events.Host.ANNOTATION_NODE_REVEALED, t)
                        },
                        callback: c
                    });
                    u && h.push({
                        plugin: r,
                        aborter: u
                    })
                }
                loadAnnotationsFromDOM(t, n)
                {
                    const i = t.getAnnotations();
                    i.events.muteEvents();
                    const o = t.getBody();
                    try {
                        n ? t.nodeManager.processDOM(o) : e.lancePluginUtils.fixBrokenAnnotations(t, o),
                        i.loadFromData(),
                        e.lancePluginUtils.syncNodes(t),
                        t.nodeManager.decorateNodesIn(o),
                        t.nodeVisibilityObserver.reload(t.nodeManager.findAnnotationNodes())
                    } catch (t) {
                        e.logger.error("Loading annotations from DOM: " + t)
                    } finally {
                        i.events.unmuteEvents(),
                        i.events.trigger(e.Annotations.Events.RELOAD)
                    }
                }
                syncNodes(i)
                {
                    var o;
                    const r = i.getAnnotations();
                    if (!r)
                        return;
                    const s = i.nodeManager.findAnnotationNodes(),
                        a = {};
                    let l,
                        c = 0;
                    const u = [];
                    r.events.muteListener(i, !0);
                    const d = null === (o = i.nodeSynchronizer) || void 0 === o ? void 0 : o.stop();
                    try {
                        for (let o = 0, d = s.length; o < d; ++o) {
                            const d = s[o],
                                h = i.nodeManager.getHandlerForNode(d);
                            if (h)
                                if (l = d && (h.usesCommentMarkers || !n(d).is(":empty")) && d.getAttribute(e.lancePluginUtils.pluginAttributes.annotationId), l) {
                                    const n = r.getAnnotationById(l);
                                    n || u.push(d),
                                    a[l] ? (a[l].nodes.push(d), d.removeAttribute(e.lancePluginUtils.pluginAttributes.annotationData)) : (a[l] = {
                                        nodes: [d],
                                        index: c++
                                    }, n && this.populateAnnotationNode({
                                        plugin: i,
                                        node: d,
                                        annotation: n,
                                        saveFullContent: !0
                                    })),
                                    g.ANN_NODE_RE.test(d.nodeName) && t.utils.dom.clearNodeBackgroundImage(d)
                                } else
                                    h.uncomment(d),
                                    i.nodeVisibilityObserver.remove(d);
                            else
                                e.logger.warn("sync nodes: no handler found for node")
                        }
                        const o = r.getAllAnnotationIds().filter(t => !(t in a)),
                            h = {};
                        if (0 === o.length && 0 === u.length)
                            return void this.renumberNodes(i, s);
                        o.forEach(t => {
                            const e = r.serializeAnnotation(t);
                            e && (h[t] = e),
                            r.deleteAnnotation(t, "delete")
                        });
                        const m = [];
                        u.forEach(t => {
                            var n;
                            e.lancePluginUtils.setupAnnotationNode(t);
                            const o = t.getAttribute(e.lancePluginUtils.pluginAttributes.annotationId),
                                s = o && h[o];
                            s && (t.setAttribute(e.lancePluginUtils.pluginAttributes.annotationData, escape(JSON.stringify(s))), delete h[o]);
                            const l = e.Annotations.extractAnnotation(t);
                            if (null === (n = null == l ? void 0 : l.comments) || void 0 === n ? void 0 : n.length) {
                                const t = r.loadAnnotationFromData({
                                        rec: l,
                                        position: a[o].index
                                    }),
                                    n = i.getAllAnnotationNodesForId(t.id);
                                i.config("tooltipFormat");
                                n.forEach((n, o) => {
                                    e.lancePluginUtils.populateAnnotationNode({
                                        plugin: i,
                                        node: n,
                                        annotation: t,
                                        saveFullContent: 0 === o
                                    })
                                })
                            } else
                                m.push(t)
                        }),
                        m.forEach(t => {
                            const n = i.nodeManager.getHandlerForNode(t),
                                o = t.getAttribute(e.lancePluginUtils.pluginAttributes.annotationId);
                            r.getAnnotationById(o) || n.uncomment(t)
                        });
                        const f = i.nodeManager.findAnnotationNodes();
                        i.nodeVisibilityObserver.reload(f),
                        this.renumberNodes(i)
                    } catch (t) {
                        e.logger.error("syncNodes", t)
                    } finally {
                        r.events.muteListener(i, !1),
                        d()
                    }
                }
                setupAnnotationNode(t)
                {
                    return n(t).attr({
                        [g.LANCE_ATTRIBUTES.selected]: null,
                        [g.LANCE_ATTRIBUTES.ignoreTrackChanges]: null
                    }), t
                }
                populateAnnotationNode({node: t, annotation: i, plugin: o, saveFullContent: r})
                {
                    if (!t || !i)
                        return;
                    const a = o.config("tooltipFormat"),
                        l = this.formatString({
                            annotation: i,
                            titleTemplate: a,
                            localize: t => o.getLocalizedString(t)
                        }),
                        c = r ? i.saveToObject() : null;
                    var u;
                    n(t).attr(i.attributes || {}).attr({
                        [g.LANCE_ATTRIBUTES.selected]: i.isSelected() ? "true" : null,
                        [g.LANCE_ATTRIBUTES.ignoreTrackChanges]: null,
                        [e.lancePluginUtils.pluginAttributes.resolved]: i.isResolved() ? "true" : null,
                        id: (u = i.id, u ? u.replace(/[^0-9a-zA-Z-]/g, "z") + s++ : ""),
                        title: l || null,
                        [e.lancePluginUtils.pluginAttributes.annotationSequence]: String(i.sequence),
                        [e.lancePluginUtils.pluginAttributes.annotationId]: i.id,
                        [e.lancePluginUtils.pluginAttributes.annotationData]: c ? encodeURIComponent(JSON.stringify(c)) : null
                    }),
                    o.nodeVisibilityObserver.add(t)
                }
                cleanupPasteContent(t, i)
                {
                    const o = t.nodeManager.getTagName()[0];
                    if (!i || !o)
                        return;
                    const r = new RegExp(o, "i");
                    if (!i || !r.test(i))
                        return;
                    const s = n("<div></div>").html(i);
                    let a = this.fixBrokenAnnotations(t, s);
                    const l = t.nodeManager.findAnnotationNodes({
                        root: s[0]
                    });
                    return l.length && l.forEach(n => {
                        var i;
                        const o = e.lancePluginUtils.getNodeAnnotationId(n);
                        if (o) {
                            t.nodeManager.findAnnotationNodesForId(o).length && (null === (i = t.nodeManager.getHandlerForNode(n)) || void 0 === i || i.uncomment(n), a = !0)
                        }
                    }), a ? s.html() : void 0
                }
                cleanupElement(t)
                {
                    return n(t).find(".flite"), t
                }
                fixBrokenAnnotations(e, n)
                {
                    const i = t.utils.dom.toJQuery(n);
                    if (!i.length)
                        return !1;
                    let o = !1;
                    return i.find(e.tagName).each((t, n) => {
                        e.nodeManager.getHandlerForNode(n) || (this._tryToRestoreAnnotationNode(e, n), o = !0)
                    }), o
                }
                _tryToRestoreAnnotationNode(t, i)
                {
                    var o;
                    const r = i.getAttribute(e.lancePluginUtils.pluginAttributes.annotationId),
                        s = f.isEmptyContainer(i);
                    let a = !1;
                    if (r) {
                        const e = t.nodeManager.getHandlerByType(s ? "pin" : "text"),
                            n = t.nodeManager.findAnnotationNodesForId(r);
                        e && !n.length && (e.decorateNode(i), a = Boolean(t.nodeManager.getHandlerForNode(i)))
                    }
                    if (!a) {
                        null === (o = t.nodeVisibilityObserver) || void 0 === o || o.remove(i);
                        const e = n(i);
                        if (s)
                            e.remove();
                        else {
                            const t = e.contents();
                            e.replaceWith(t)
                        }
                    }
                    return a
                }
                renumberNodes(i, o)
                {
                    const r = o || i.nodeManager.findAnnotationNodes();
                    if (!r.length)
                        return;
                    r.sort(t.utils.dom.compareNodePosition);
                    const s = [],
                        a = {};
                    let l = 0;
                    r.forEach((function(t, i) {
                        const o = n(t),
                            r = o.attr(e.lancePluginUtils.pluginAttributes.annotationId);
                        a[r] || (s.push(r), a[r] = String(l++)),
                        o.attr(e.lancePluginUtils.pluginAttributes.annotationSequence, a[r])
                    }));
                    i.getAnnotations().setAnnotationsSequence(s)
                }
                validateApiKey()
                {
                    const t = "api-key-placeholder";
                    if (!/placeholder/.test(t)) {
                        const e = document.head && document.head.querySelectorAll("meta[name='LANCE-API-KEY']"),
                            n = e && e.length && e[0];
                        return Boolean(n && n.getAttribute && n.getAttribute("content") === t)
                    }
                    return !0
                }
                validateConfiguration(n)
                {
                    var i;
                    (Array.isArray(n) || null === n) && (e.logger.error("Invalid FLITE configuration, can't be an array or null"), n = {}),
                    n = n || {};
                    const r = t.$.extend(!0, {
                            ckeStrictSelection: !1,
                            debug: {
                                prefix: "Lance "
                            }
                        }, n),
                        s = r.tooltipFormat;
                    if (r.tooltipFormat = void 0 === s || !0 === s ? "%AS" : !1 === s || null === s ? "" : String(s), n.spellingOverride && "object" == typeof n.spellingOverride && (o = n.spellingOverride), r.extendFocus = !0 === n.extendFocus, n.editorTheme = t.utils.strings.validateEnum(n.editorTheme, ["browser", "dark", "light"], "light"), r.commentSelectionPolicy = t.utils.strings.validateEnum(n.commentSelectionPolicy, ["none", "full", "caret"], "none"), r.undoPolicy = t.utils.strings.validateEnum(n.undoPolicy, ["create", "none", "all"], "create"), r.commands = function(e) {
                        const n = e.editorTheme,
                            i = "browser" === n ? t.utils.pluginUtils.isDarkMode() ? "dark" : "light" : n,
                            o = u.map(t => Object.assign(Object.assign({}, t), {
                                iconUrl: t.iconUrl ? t.iconUrl.replace(/%THEME%/g, i) : t.iconUrl
                            }));
                        return t.utils.pluginUtils.upgradeConfigCommands(o, e.commands)
                    }(n), r.useTextSelection = function(n) {
                        const i = [],
                            o = n.useTextSelection;
                        if (!0 === o || null == o)
                            i.push("text");
                        else if (!1 === o)
                            i.push("pin");
                        else {
                            const e = new Set(t.utils.strings.toStringArray(o, {
                                transform: "lower"
                            }));
                            e.has("all") && e.add("pin").add("text"),
                            e.forEach(t => {
                                if (/^pin\/(start|end)$/.test(t)) {
                                    if (e.size > 1)
                                        throw new Error(`Annotation type ${t} can't be used with another type, received ${o}`);
                                    i.push(t)
                                } else
                                    "pin" !== t && "text" !== t || i.push(t)
                            })
                        }
                        return 0 === i.length && e.logger.error("Illegal option for useTextSelection: " + o), i
                    }(n), r.pageUrls = t.utils.strings.toStringArray(null !== (i = n.pageUrls) && void 0 !== i ? i : ["css/quicktips.css"]), r.logEvents = "boolean" == typeof n.logEvents && n.logEvents, r.logCommands = "boolean" == typeof n.logCommands && n.logCommands, r.readonlyPolicy = t.utils.strings.validateEnum(n.readonlyPolicy, ["none", "full"], "none"), r.customAttributes = t.utils.strings.toStringArray(n.customAttributes), r.autoScroll = "boolean" == typeof n.autoScroll || n.autoScroll in {
                        live: 1,
                        smooth: 1
                    } ? n.autoScroll : void 0 === n.autoScroll ? "smooth" : (e.logger.warn(`Illegal autoscroll value ${n.autoScroll}, using true instead`), !0), "string" == typeof n.tagName) {
                        const t = n.tagName.trim().toLowerCase();
                        if (!/^[a-z]+-?[a-z]+$/i.test(n.tagName))
                            throw new Error(`Invalid custom tag name ${n.tagName} - should contain only latin letters and hyphens`);
                        r.tagName = t
                    } else
                        r.tagName = "annotation";
                    const a = t.utils.strings.toStringArray(n.styleUrls);
                    return r.styleUrls = a.length ? a : ["css/annotate.css"], r
                }
                toUniqueAnnotationNodes(t)
                {
                    if (!(null == t ? void 0 : t.length))
                        return [];
                    const n = new Map;
                    return t.forEach(t => {
                        const i = e.lancePluginUtils.getNodeAnnotationId(t);
                        i && !n.has(i) && n.set(i, t)
                    }), Array.from(n.values())
                }
                formatString(t)
                {
                    let e = t.titleTemplate;
                    return e ? (e = e.replace(/%%([^\b\s]+)/g, (e, ...n) => t.localize(n[0])), l.forEach(n => {
                        let i;
                        for (; i = n.regex.exec(e);) {
                            const o = d((i[1] || "A").toUpperCase(), t.annotation);
                            e = [e.substring(0, i.index), n.replacer(t.annotation, o), e.substring(i.index + i[0].length)].join("")
                        }
                    }), e) : ""
                }
                removeLanceArtifacts(e, n)
                {
                    const i = e.getDocument(),
                        {$element: o} = t.utils.dom.wrapElement(n, i);
                    return e.nodeManager.prepareToSave(o[0], i)
                }
                _updateSpellingStack(t)
                {
                    let e = {
                        "tr,td,ul,ol": !0
                    };
                    return o && "object" == typeof o && Object.assign(e, o), function(t) {
                        Object.keys(t).forEach(e => {
                            /^tr,/.test(e) && delete t[e]
                        })
                    }(e), t && t.length ? (t.each((t, i) => {
                        if (!i.attributes || !i.attributes.length || !e)
                            return;
                        const o = n.extend({}, e),
                            r = function(t) {
                                const e = (t || "").split("").reduce((function(t, e, n, i) {
                                    return t + (n + 1) * e.charCodeAt(0)
                                }), 0);
                                return o[e] && delete o[e], e
                            };
                        Array.prototype.slice.apply(i.attributes).forEach(t => {
                            r(t.nodeValue),
                            r(t.nodeName)
                        }),
                        0 === Object.keys(o).length && (e = void 0)
                    }), Boolean(e)) : Object.keys(e).length > 0
                }
                _abortRevealFor(t)
                {
                    const n = h.slice();
                    for (let i = n.length - 1; i >= 0; --i) {
                        const o = n[i];
                        if (o.plugin === t)
                            try {
                                h.splice(i, 1),
                                o.aborter()
                            } catch (t) {
                                e.logger.error("abort reveal: " + t)
                            }
                    }
                }
                _removeAborter(e)
                {
                    t.utils.array.remove(h, {
                        test: t => t.aborter === e
                    })
                }
                _revealAnnotationNode({node: n, annotation: i, plugin: o, callback: s, progress: a})
                {
                    var l;
                    let c,
                        u = e.lanceUtils.boundsProcessor.getElementRects(n);
                    const d = {
                            annotation: i,
                            node: n,
                            bounds: u.visible
                        },
                        h = (t, e) => Object.assign(Object.assign({}, d), {
                            progress: t
                        });
                    if ((null === (l = u.visible) || void 0 === l ? void 0 : l.height) === u.full.height)
                        return s(h(!1)), null;
                    const g = o.config("autoScroll");
                    if (!1 === g)
                        return s(h(!1)), null;
                    const m = "live" === g;
                    n.scrollIntoView(r("smooth" === g || m ? "smooth" : "instant"));
                    const f = m && a || t.utils.yes;
                    let p = 0,
                        v = 0,
                        _ = 0,
                        y = !1;
                    const b = () => {
                            _ && (clearInterval(_), _ = 0),
                            this._removeAborter(E),
                            y || (n.scrollIntoView(r("instant")), s(h(!1)))
                        },
                        E = () => {
                            y = !0,
                            b()
                        };
                    return _ = setInterval(() => {
                        var t;
                        return y || ++p > 300 ? b() : (c = e.lanceUtils.boundsProcessor.getElementRects(n), d.bounds = c.visible, v = c.full.top === (null === (t = null == u ? void 0 : u.full) || void 0 === t ? void 0 : t.top) ? v + 1 : 0, u = c, v > 6 ? b() : void (c.visible && 0 === v && f(h(!0))))
                    }, 25), E
                }
            }
            g.LANCE_ATTRIBUTES = {
                selected: "data-selected",
                annotationId: "data-annotation-id",
                annotationData: "data-ant",
                annotationSequence: "data-annotation-seq",
                ignoreTrackChanges: "data-track-changes-ignore",
                resolved: "data-lance-resolved"
            },
            g.ceattr = t.browser.msie ? "data-lance-contenteditable" : "contenteditable",
            g.ANN_NODE_RE = /^IMG$|^ANNOTATION$/i;
            const m = new Map([["pin", "lance-annotation-pin-class"], ["text", "lance-annotation-class"]]);
            class f {
                constructor(i)
                {
                    this._adapter = i,
                    this._className = m.get(i.name);
                    const o = i.plugin.tagName;
                    this._fullSelector = `.${this._className}[${e.lancePluginUtils.pluginAttributes.annotationId}]`,
                    this._basicSelector = `${o}.${this._className}`,
                    this._params = new Set,
                    this._timeoutClient = t.utils.createTimeoutClient(),
                    this.usesCommentMarkers ? this._canAnnotate = this._canAnnotatePin.bind(this) : (this._canAnnotate = this._canAnnotateText.bind(this), this._timeoutClient.createTimer("fakespan", {
                        callback: e => {
                            const i = n(this.adapter.documentBody).find("span[data-lance-placeholder]");
                            if (!i.length)
                                return void e.stop();
                            const o = this.adapter.getSelectedRange();
                            let r = !0;
                            i.each((e, i) => {
                                if (o && (o.startContainer === i || o.commonAncestorContainer === i || o.endContainer === i))
                                    return void (r = !1);
                                const s = n(i);
                                t.utils.dom.forAllTextChildren(i, t => {
                                    t && t.data.indexOf("\ufeff") >= 0 && (1 === t.data.length ? t !== (o && o.startContainer) ? n(t).remove() : r = !1 : t.data = t.data.replace(/\uFEFF/g, ""))
                                }),
                                r && s.before(s.contents()).remove()
                            })
                        },
                        timeoutMSecs: 250,
                        repeatCount: 999999,
                        autoDispose: !1
                    }))
                }
                get name()
                {
                    return this._adapter.name
                }
                toString()
                {
                    return `Selection Handler(${this._adapter.name})`
                }
                setParam(t)
                {
                    "string" == typeof t && this._params.add(t)
                }
                getParam(t)
                {
                    return this._params.has(t)
                }
                get className()
                {
                    return this._className
                }
                get adapter()
                {
                    return this._adapter
                }
                dispose()
                {
                    this._timeoutClient.dispose()
                }
                createAnnotationNode()
                {
                    const t = this._createAnnotationNode();
                    return this.decorateNode(t), t
                }
                collapseAfterNode(t)
                {
                    var i;
                    if (!t || t.ownerDocument !== this.adapter.document)
                        return null;
                    try {
                        const e = this.adapter.document.createElement("span"),
                            o = n(e);
                        o.attr({
                            "data-lance-placeholder": "",
                            "data-track-changes-ignore": !0
                        }).addClass("lance-style-sep");
                        const r = this.adapter.document.createTextNode("\ufeff");
                        o.append(r),
                        null === (i = t.parentNode) || void 0 === i || i.insertBefore(e, t.nextSibling);
                        const s = this.adapter.getNativeSelection(),
                            a = (null == s ? void 0 : s.rangeCount) > 0 && s.getRangeAt(0);
                        if (a)
                            return a.setStart(r, 0), a.setEnd(r, 1), this.adapter.selectRange(a), this.monitorFakeSpan(), r
                    } catch (t) {
                        e.logger.error("collapse after node: ", t)
                    }
                    return null
                }
                findFirstNodeForAnnotation(t)
                {
                    return this.findAnnotationNodesForId(t)[0] || null
                }
                decorateNode(t)
                {
                    const e = n(t);
                    return e.addClass(this.className), this.usesCommentMarkers && e.empty().append("<object />"), t
                }
                getTagName()
                {
                    return this._adapter.plugin.tagName
                }
                monitorFakeSpan()
                {
                    this._timeoutClient.startTimer("fakespan")
                }
                uncomment(i)
                {
                    var o;
                    const r = null === (o = this.adapter.plugin.nodeSynchronizer) || void 0 === o ? void 0 : o.stop(),
                        s = t.utils.pluginUtils.disableTracking(this.adapter.plugin);
                    try {
                        if (this.adapter.plugin.nodeVisibilityObserver.remove(i), this.usesCommentMarkers)
                            return void n(i).remove();
                        const t = n(i);
                        if (!t.is(this.getTagName()))
                            return e.logger.error("Lance: Wrong node type to uncomment", i);
                        const o = t.contents();
                        t.replaceWith(o)
                    } catch (t) {
                        e.logger.error("Lance: While uncommenting node", t)
                    } finally {
                        s(),
                        null == r || r()
                    }
                }
                getSelector()
                {
                    return this._fullSelector
                }
                static isEmptyContainer(e)
                {
                    if (1 !== (null == e ? void 0 : e.nodeType))
                        return !1;
                    return Boolean(n(e).find("object").length) || t.utils.strings.isEmptyString(e.textContent)
                }
                processDOM(n)
                {
                    if (!n)
                        return e.logger.warn("Process DOM : no input "), null;
                    const {$element: i, isString: o} = t.utils.dom.wrapElement(n, this.adapter.document);
                    if (0 === i.length)
                        return null;
                    let r = e.lancePluginUtils.fixBrokenAnnotations(this._adapter.plugin, i);
                    const s = this.getTagName(),
                        a = this.usesCommentMarkers,
                        l = i.find(`[${e.lancePluginUtils.pluginAttributes.annotationId}]`).toArray().filter(e => !t.utils.dom.matchesSelector(e, s) && !t.utils.dom.matchesSelector(e, f.INVALID_ANNOTATION_TAGS));
                    function c(t) {
                        if (!a)
                            return null;
                        const e = t.find(s + ".cke_annotation");
                        return e.length && (e.removeClass("cke_annotation").addClass(m.get("pin")), r = !0), r ? o ? t.html() : t[0] : null
                    }
                    const u = a ? t => f.isEmptyContainer(t) : t => !f.isEmptyContainer(t),
                        d = l.filter(u);
                    if (0 === d.length)
                        return c(i);
                    function h(t, e) {
                        const n = t && t.attributes;
                        if (!n || !n.length)
                            return;
                        let i,
                            o;
                        for (let t = n.length - 1; t >= 0; --t)
                            i = n[t],
                            o = null == i ? void 0 : i.name,
                            o && (o = o.toLowerCase(), f.EXCLUDE_ATTRS.has(o) || /data-cke-|bogus/.test(o) || e.setAttribute(o, i.value))
                    }
                    function g(t, e) {
                        if (t !== e)
                            for (; t.firstChild;)
                                e.appendChild(t.firstChild);
                        return e
                    }
                    for (let t = d.length - 1; t >= 0; --t) {
                        const e = d[t],
                            n = e.ownerDocument.createElement(s);
                        h(e, n),
                        g(e, n),
                        n.classList.add(this.className),
                        e.replaceWith(n),
                        r = !0
                    }
                    return c(i)
                }
                get usesCommentMarkers()
                {
                    return "pin" === this.name
                }
                canAnnotate(t)
                {
                    return t = t || this.adapter.getSelectedRange(), this._canAnnotate(t)
                }
                _createAnnotationNode()
                {
                    return this.adapter.document.createElement(this.getTagName())
                }
                _canAnnotateText(e)
                {
                    if (!e)
                        return {
                            can: !1,
                            annotationNodes: [],
                            inAnnotation: !1
                        };
                    if (e.collapsed) {
                        const n = function(e) {
                            const n = t.utils.dom.getRangeAnchors(e),
                                i = n.first;
                            return i ? 3 === i.nodeType ? [i] : 1 === i.nodeType ? [i, n.prev].filter(Boolean) : [] : []
                        }(e).map(t => this.findAnnotationNode(t)).filter(Boolean);
                        return {
                            can: !1,
                            annotationNodes: n,
                            inAnnotation: n.length > 0
                        }
                    }
                    const i = t.utils.dom.getSelectedTextNodes(e);
                    if (!i.length)
                        return {
                            can: !1,
                            annotationNodes: [],
                            inAnnotation: !1
                        };
                    const o = {
                        can: !0,
                        annotationNodes: []
                    };
                    let r = !1;
                    for (const t of i) {
                        const e = n(t.node).closest(this._basicSelector)[0];
                        e ? o.annotationNodes.indexOf(e) < 0 && (o.can = !1, o.annotationNodes.push(e)) : r = !0
                    }
                    return Object.assign(Object.assign({}, o), {
                        inAnnotation: !r && 1 === o.annotationNodes.length
                    })
                }
                findAnnotationNodesForId(t)
                {
                    return n(this.adapter.documentBody).find(`.${this.className}[${e.lancePluginUtils.pluginAttributes.annotationId}='${t}']`)
                }
                uncommentAnnotation(t)
                {
                    const e = this.findAnnotationNodesForId(t);
                    return e.each((t, e) => {
                        this.uncomment(e)
                    }), e.toArray()
                }
                findAnnotationNodeAtCaret(e)
                {
                    e = null != e ? e : this.adapter.getSelectedRange();
                    const n = t.utils.dom.getRangeAnchors(e),
                        i = [n.prev, n.first, n.last, n.next].filter(Boolean);
                    for (let t = 0; t < i.length; t++) {
                        const e = this.findAnnotationNode(i[t]);
                        if (e)
                            return e
                    }
                    return null
                }
                insertAnnotationNodes()
                {
                    var n;
                    const i = [];
                    let o = this.adapter.getSelectedRange();
                    if (!o)
                        return i;
                    const r = null === (n = this.adapter.plugin.nodeSynchronizer) || void 0 === n ? void 0 : n.stop();
                    try {
                        if (this.usesCommentMarkers) {
                            const t = this.createAnnotationNode();
                            o.collapsed || !this.getParam("start") && !this.getParam("end") || (o.collapse(this.getParam("start")), this._adapter.selectRange(o)),
                            this._adapter.insertElement ? this._adapter.insertElement(t, o) : o.insertNode(t),
                            i.push(t)
                        } else {
                            t.utils.dom.normalizeNode(o.commonAncestorContainer),
                            o = this.adapter.getSelectedRange();
                            const e = t.utils.dom.getSelectedTextNodes(o).filter(e => function(e, n) {
                                var i;
                                if (!(null === (i = null == e ? void 0 : e.node) || void 0 === i ? void 0 : i.length))
                                    return !1;
                                for (let i = e.node.parentNode; i && i !== n; i = i.parentNode)
                                    if (t.utils.dom.matchesSelector(i, "textarea,select,input,option,[contenteditable='false']"))
                                        return !1;
                                return !0
                            }(e, this.adapter.documentBody));
                            if (!e.length)
                                return i;
                            const n = t => {
                                const e = null == t ? void 0 : t.nodeType;
                                return 3 === e ? t : 1 === e ? n(t.firstChild) : null
                            };
                            e.forEach(e => {
                                var o;
                                const r = t.utils.dom.extractInlineNode(e),
                                    s = n(r);
                                if (s) {
                                    const t = this.createAnnotationNode();
                                    null === (o = s.parentNode) || void 0 === o || o.insertBefore(t, s),
                                    t.appendChild(s),
                                    i.push(t)
                                }
                            })
                        }
                    } catch (t) {
                        throw e.logger.error("Lance: While creating annotation nodes", t), t
                    } finally {
                        let e;
                        const n = i[0],
                            o = i[i.length - 1];
                        if (this.usesCommentMarkers) {
                            const i = t.utils.dom.getNodeIndex(n),
                                o = n.parentNode;
                            e = {
                                startContainer: o,
                                endContainer: o,
                                startOffset: i,
                                endOffset: i,
                                commonAncestorContainer: o
                            }
                        } else
                            e = {
                                startContainer: n.firstChild,
                                startOffset: 0,
                                endContainer: o.firstChild,
                                endOffset: o.firstChild.length,
                                commonAncestorContainer: n.firstChild === n.lastChild ? n.firstChild : n
                            };
                        this.adapter.selectRange(e),
                        null == r || r()
                    }
                    return i
                }
                findAnnotationNode(t)
                {
                    var e;
                    return null !== (e = n(t).closest(this._fullSelector)[0]) && void 0 !== e ? e : null
                }
                findAnnotationNodes()
                {
                    return this.findAnnotationNodesIn(this.adapter.documentBody)
                }
                prepareToSave(e)
                {
                    return t.utils.dom.matchesSelector(e, this._fullSelector) && this.usesCommentMarkers && n(e).empty(), e
                }
                findAnnotationNodesIn(i, o=!0)
                {
                    if (!i)
                        return [];
                    const r = n(i).find(this._fullSelector).toArray().filter(t => !this._adapter.plugin.isDummyElement(t));
                    return t.utils.dom.matchesSelector(i, this._fullSelector) && r.push(i), o ? r : e.lancePluginUtils.toUniqueAnnotationNodes(r)
                }
                getCommandState(t)
                {
                    const e = this.canAnnotate(t);
                    return {
                        state: {
                            enabled: e.can
                        },
                        annotationNodes: e.annotationNodes,
                        inAnnotation: e.inAnnotation
                    }
                }
                uncommentAnnotationId(t)
                {
                    if (!t)
                        return;
                    this.findAnnotationNodesForId(t).each((t, e) => {
                        this.uncomment(e)
                    })
                }
                _canAnnotatePin(e)
                {
                    if (!e)
                        return {
                            inAnnotation: !1,
                            can: !1,
                            annotationNodes: []
                        };
                    if (!e.collapsed) {
                        const n = this.getParam("start"),
                            i = this.getParam("end"),
                            o = this.findAnnotationNodes(),
                            r = t.utils.dom.getIntersectingNodes(e, ...o);
                        let s = !1,
                            a = !1;
                        return (n || i) && (a = 0 === r.length), 1 === r.length && (s = e.commonAncestorContainer === r[0]), {
                            can: a,
                            annotationNodes: r,
                            inAnnotation: s
                        }
                    }
                    const n = this.findAnnotationNodeAtCaret(e);
                    return {
                        can: !n,
                        annotationNodes: n ? [n] : [],
                        inAnnotation: Boolean(n)
                    }
                }
            }
            f.INVALID_ANNOTATION_TAGS = "p,div,span,table,tr,td,th,ul,ol,li,img,h1,h2,h3,h4,h5,h6,a,dd,dt,dl",
            f.EXCLUDE_ATTRS = new Set(["alt", "src", "class", "align", "cke-editable", "contenteditable"]);
            class p {
                constructor(...t)
                {
                    this._handlers = Array.from(t).map(t => ({
                        handler: t,
                        enabled: !1
                    }));
                    if (new Set(this._handlers.map(t => t.handler.adapter.name)).size !== this._handlers.length)
                        throw new Error("Duplicate handler name in handlers list");
                    this._selector = this._handlers.map(t => t.handler.getSelector()).join(",")
                }
                dispose()
                {
                    this._handlers.forEach(t => {
                        t.handler.dispose()
                    }),
                    this._handlers.length = 0
                }
                decorateNodesIn(t)
                {
                    return this.handlers.forEach(e => {
                        e.findAnnotationNodesIn(t).forEach(t => e.decorateNode(t))
                    }), t
                }
                enableHandlers(n)
                {
                    const i = t.utils.strings.toStringArray(n).filter(Boolean).map(t => {
                            const n = t.split("/");
                            return 1 === n.length ? {
                                name: t
                            } : (n.length > 2 && e.logger.error(`Illegal annotation type ${t}, using only the first parts`), {
                                name: n[0],
                                param: n[1]
                            })
                        }),
                        o = this._handlers.map(t => {
                            var e;
                            const n = i.findIndex(e => this._isHandlerMatching(t.handler, e.name));
                            return t.handler.setParam(null === (e = i[n]) || void 0 === e ? void 0 : e.param), {
                                handler: t.handler,
                                enabled: n >= 0
                            }
                        });
                    return this._handlers.length = 0, this._handlers.push(...o), this
                }
                getHandlerMatching(e)
                {
                    var n;
                    const i = t.utils.array.first(this._handlers, t => e(t.handler));
                    return null !== (n = null == i ? void 0 : i.handler) && void 0 !== n ? n : null
                }
                uncommentAnnotation(t)
                {
                    for (let e = 0; e < this._handlers.length; e++) {
                        const n = this._handlers[e].handler,
                            i = n.findAnnotationNodesForId(t);
                        if (i.length)
                            return i.each((t, e) => n.uncomment(e)), i.toArray()
                    }
                    return []
                }
                findAnnotationNode(t)
                {
                    return this._findFirst(e => e.findAnnotationNode(t))
                }
                findAnnotationNodeAtCaret(t)
                {
                    return this._findFirst(e => e.findAnnotationNodeAtCaret(t))
                }
                processDOM(t)
                {
                    let e = null;
                    for (let n = 0; n < this._handlers.length; n++) {
                        const i = this._handlers[n].handler.processDOM(t);
                        i && (e = t = i)
                    }
                    return e
                }
                findAnnotationNodesForId(t)
                {
                    for (let e = 0; e < this._handlers.length; e++) {
                        const n = this._handlers[e].handler.findAnnotationNodesForId(t);
                        if (n.length)
                            return n
                    }
                    return n(null)
                }
                findAnnotationNodes(n)
                {
                    const i = new Set,
                        o = [];
                    if (null == n ? void 0 : n.type) {
                        const t = this.getHandlerByType(n.type);
                        if (!t)
                            return [];
                        o.push(t)
                    } else
                        o.push(...this.handlers);
                    const r = null == n ? void 0 : n.root;
                    o.forEach(t => {
                        (r ? t.findAnnotationNodesIn(r) : t.findAnnotationNodes()).forEach(t => i.add(t))
                    });
                    const s = Array.from(i.values());
                    return s.sort(t.utils.dom.compareNodePosition), !1 !== (null == n ? void 0 : n.allowDuplicates) ? s : e.lancePluginUtils.toUniqueAnnotationNodes(s)
                }
                getTagName()
                {
                    var t;
                    const e = null !== (t = this.getHandlerByType("text")) && void 0 !== t ? t : this.getHandlerByType("pin");
                    return (null == e ? void 0 : e.getTagName()) || ""
                }
                getSelector(t)
                {
                    var e,
                        n;
                    return [(null == t ? void 0 : t.type) ? null !== (n = null === (e = this.getHandlerByType(t.type)) || void 0 === e ? void 0 : e.getSelector()) && void 0 !== n ? n : "" : this._selector, (null == t ? void 0 : t.withTagName) ? this.getTagName() : ""].filter(Boolean).join(",")
                }
                get handlers()
                {
                    return this._handlers.map(t => t.handler)
                }
                get activeHandlers()
                {
                    return this._handlers.filter(t => t.enabled).map(t => t.handler)
                }
                getHandlerByType(t)
                {
                    if (!t)
                        return null;
                    const e = this._handlers.findIndex(e => this._isHandlerMatching(e.handler, t));
                    return e >= 0 ? this._handlers[e].handler : null
                }
                getHandlerForNode(t)
                {
                    if (!t)
                        return null;
                    for (let e = 0; e < this._handlers.length; e++) {
                        const n = this._handlers[e];
                        if (n.handler.findAnnotationNode(t))
                            return n.handler
                    }
                    return null
                }
                getHandlerForRange(t)
                {
                    var e;
                    const n = this.activeHandlers;
                    if (!(t = null != t ? t : null === (e = n[0]) || void 0 === e ? void 0 : e.adapter.getSelectedRange()))
                        return null;
                    for (let e = 0; e < n.length; e++) {
                        const i = n[e];
                        if (i.canAnnotate(t).can)
                            return i
                    }
                    return null
                }
                getNodeAnnotationType(t)
                {
                    if (!t)
                        return null;
                    const e = this.getHandlerForNode(t);
                    return (null == e ? void 0 : e.adapter.name) || null
                }
                prepareToSave(e, n)
                {
                    if (!e)
                        return null;
                    const {$element: i} = t.utils.dom.wrapElement(e, n),
                        o = i[0];
                    if (!o)
                        return null;
                    return this.handlers.forEach(t => function(t) {
                        t.findAnnotationNodesIn(o).forEach(e => t.prepareToSave(e))
                    }(t)), i.find("[data-lance-placeholder]").remove(), o
                }
                getCommandState(t)
                {
                    const e = {
                            enabled: !1,
                            active: void 0
                        },
                        n = [];
                    let i = !1;
                    const o = this._handlers;
                    for (let r = 0; r < o.length; r++) {
                        const s = o[r];
                        if (!(t = null != t ? t : s.handler.adapter.getSelectedRange()))
                            continue;
                        const a = s.handler.getCommandState(t);
                        if (!1 === a.state.enabled && a.annotationNodes.length)
                            return a;
                        a.inAnnotation && (i = !0),
                        n.push(...a.annotationNodes),
                        s.enabled && ("boolean" == typeof a.state.active && (e.active = e.active || a.state.active), "boolean" == typeof a.state.enabled && (e.enabled = e.enabled || a.state.enabled))
                    }
                    return n.length && (e.enabled = !1), {
                        annotationNodes: n,
                        state: e,
                        inAnnotation: i
                    }
                }
                _isHandlerMatching(t, e)
                {
                    if (t.adapter.name === e)
                        return !0;
                    return new RegExp(e.replace(/[^a-z]+/gi, ""), "i").test(t.adapter.name)
                }
                _findFirst(t)
                {
                    for (let e = 0; e < this._handlers.length; e++) {
                        const n = t(this._handlers[e].handler);
                        if (n)
                            return n
                    }
                    return null
                }
            }
            class v {
                constructor(e)
                {
                    if (this._targets = [], this._releaseScroller = null, this._releaseResizer = null, this.options = n.extend({}, {
                        timeoutMsecs: 100
                    }, e), this._debounceMgr = t.utils.createDebouncerManager(), !this.options.onVisibility)
                        throw new Error("Missing callback in NodeVisibilityManager constructor");
                    this.debouncer = this._debounceMgr.createDebouncer("node-visibility", {
                        continuous: !0,
                        timeout: this.options.timeoutMsecs,
                        callback: (t, e) => this._notify(e),
                        compare: t.utils.yes
                    })
                }
                dispose()
                {
                    this._debounceMgr.dispose(),
                    this.reload([])
                }
                add(t)
                {
                    return t ? (n.isArray(t) ? t.forEach(t => this._addOne(t)) : this._addOne(t), this) : this
                }
                remove(t)
                {
                    return t ? (n.isArray(t) ? t.forEach(t => this._removeOne(t)) : this._removeOne(t), this) : this
                }
                reload(t)
                {
                    const e = this.targets;
                    return e.forEach(e => {
                        t.indexOf(e) < 0 && this._removeOne(e)
                    }), t.forEach(t => {
                        e.indexOf(t) < 0 && this._addOne(t)
                    }), this._notify(this._newState({
                        resize: !0
                    })), this
                }
                get targets()
                {
                    return this._targets.map(t => t.node)
                }
                getSnapshot()
                {
                    return t.utils.array.remove(this._targets, {
                        all: !0,
                        test: t => !t.node || !t.node.parentNode || !t.node.ownerDocument
                    }), this._targets.map(t => ({
                        visible: t.visible,
                        node: t.node,
                        rects: e.lanceUtils.boundsProcessor.getElementRects(t.node)
                    }))
                }
                _ignoreScroll()
                {
                    this._releaseScroller = this._execute(this._releaseScroller)
                }
                _disposeResizer()
                {
                    this._releaseResizer = this._execute(this._releaseResizer)
                }
                _removeOne(t)
                {
                    const n = this._findTargetIndex(t);
                    if (n >= 0) {
                        const i = this._targets[n];
                        this._targets.splice(n, 1);
                        try {
                            i.observer.unobserve(t)
                        } catch (t) {
                            e.logger.error("While removing visibility target", t)
                        }
                    }
                    return 0 === this._targets.length && (this._ignoreScroll(), this._disposeResizer()), this
                }
                _addOne(e)
                {
                    var n,
                        i;
                    if (this._findTargetIndex(e) >= 0)
                        return;
                    const o = {
                        root: this.options.view,
                        rootMargin: "5px",
                        threshold: 0
                    };
                    this._releaseScroller = null !== (n = this._releaseScroller) && void 0 !== n ? n : this._bindScroller(e),
                    this._releaseResizer = null !== (i = this._releaseResizer) && void 0 !== i ? i : this._bindResizer(this.options.container);
                    const r = new IntersectionObserver((e, n) => {
                        e.forEach(e => {
                            const n = this._findTarget(e.target);
                            if (n) {
                                const i = n.visible = e.isIntersecting,
                                    o = e.target,
                                    r = this.debouncer.getStateFor(null) || this._newState({}),
                                    s = i ? r.shown : r.hidden,
                                    a = i ? r.hidden : r.shown;
                                s.indexOf(o) < 0 && s.push(o),
                                t.utils.array.remove(a, {
                                    element: o,
                                    all: !1
                                }),
                                this.debouncer.add(null, r)
                            }
                        })
                    }, o);
                    r.observe(e),
                    this._targets.push({
                        observer: r,
                        node: e,
                        visible: !1
                    })
                }
                _newState(t)
                {
                    return Object.assign({
                        scroll: 0,
                        initialScroll: NaN,
                        shown: [],
                        hidden: [],
                        resize: !1,
                        scroller: null
                    }, t)
                }
                _bindScroller(i)
                {
                    const o = t.utils.dom.getScrollParent({
                        node: i
                    });
                    if (!o)
                        return e.logger.warn("Can't listen to scroll events, no scroll parent"), null;
                    const r = n(o),
                        s = t => {
                            const e = r.scrollTop(),
                                n = this.debouncer.getStateFor(null) || this._newState({
                                    initialScroll: e,
                                    scroller: o
                                });
                            n.scroll = e - (n.initialScroll || e),
                            this.debouncer.add(null, n)
                        };
                    return o.addEventListener("scroll", s), () => {
                        o.removeEventListener("scroll", s)
                    }
                }
                _bindResizer(t)
                {
                    const e = new ResizeObserver(t => {
                        const e = this.debouncer.getStateFor(null) || this._newState({});
                        e.resize = !0,
                        this.debouncer.add(null, e)
                    });
                    return e.observe(t, {
                        box: "content-box"
                    }), () => {
                        e.disconnect()
                    }
                }
                _findTarget(t)
                {
                    const e = this._findTargetIndex(t);
                    return e >= 0 ? this._targets[e] : null
                }
                _findTargetIndex(t)
                {
                    return this._targets.findIndex(e => e.node === t)
                }
                _notify(t)
                {
                    (t.resize || t.shown.length || t.hidden.length || Math.abs(t.scroll) > 5) && this.options.onVisibility(this)
                }
                _execute(t)
                {
                    try {
                        t && t()
                    } catch (t) {
                        e.logger.error("While executing dispose function")
                    }
                    return null
                }
            }
            const _ = {
                lancePluginUtils: new g
            };
            Object.assign(e, _)
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            var e;
            const n = null == t ? void 0 : t.LANCE;
            if (null === (e = n.Annotations) || void 0 === e ? void 0 : e.Events)
                return;
            const i = t.$,
                o = {
                    id: "",
                    userId: 0,
                    userName: "",
                    time: 0,
                    text: ""
                };
            let r = void 0;
            const s = [118, 104, 119, 87, 108, 112, 104, 114, 120, 119],
                a = [98, 106, 104, 119, 68, 113, 113, 114, 119, 100, 119, 108, 114, 113, 79, 104, 113, 106, 119, 107],
                l = window,
                c = {
                    edit: {
                        first: "owner",
                        last: "owner",
                        default: "owner"
                    },
                    delete: {
                        first: "owner",
                        last: "owner",
                        default: "owner"
                    },
                    resolve: {
                        first: "opener",
                        last: "opener",
                        default: "opener"
                    }
                };
            let u = Math.round(1e3 * Math.random());
            function d(t) {
                if (!t)
                    return null;
                const e = i.extend({}, {
                        edit: {},
                        delete: {},
                        resolve: {}
                    }),
                    o = (t, e) => {
                        t && ("string" == typeof t ? e.first = e.last = e.default = t : "object" == typeof t && ["first", "last", "default"].forEach((function(n) {
                            e[n] = t[n] || t.default || void 0
                        })))
                    };
                return o(t.edit, e.edit), o(t.delete, e.delete), o(t.resolve, e.resolve), function t(e) {
                    if (!e)
                        return null;
                    let i;
                    return Object.entries(e).forEach(([o, r]) => {
                        const s = o;
                        if (i = typeof r, void 0 !== r) {
                            if (null === r)
                                return n.logger.error("invalid null permissions key", s, "\nUsing default permissions"), null;
                            if ("string" === i) {
                                if (e[s] = r = r.toLowerCase(), "opener" !== r && "any" !== r && "owner" !== r && "user" !== r && "none" !== r)
                                    return n.logger.error("invalid permission; key:", s, "value:", r, "\nUsing default permissions"), null
                            } else {
                                if ("object" !== i)
                                    return n.logger.error("invalid permission; key:", s, "value:", r), null;
                                if (!t(r))
                                    return null
                            }
                        }
                    }), e
                }(e)
            }
            function h(t) {
                return t.map((function(t) {
                    return t - 3
                })).map((function(t) {
                    return String.fromCharCode(t)
                })).join("")
            }
            class g {
                constructor(t)
                {
                    t = function(t, e) {
                        const n = {};
                        return t = t || {}, Object.keys(e).forEach(i => {
                            t.hasOwnProperty(i) ? n[i] = t[i] : n[i] = e[i]
                        }), n
                    }(t, o),
                    i.extend(this, t),
                    this._selected = !1,
                    this._userPicture = ""
                }
                getStatus()
                {
                    return this._status ? i.extend(!0, {}, this._status) : null
                }
                setStatus(t)
                {
                    return this._status = t, this
                }
                isSelected()
                {
                    return this._selected
                }
                setSelected(t)
                {
                    this._selected = Boolean(t)
                }
                setTime(t)
                {
                    if (t instanceof Date)
                        this.time = Math.round(t.getTime() / 1e3);
                    else {
                        const e = typeof t;
                        this.time = "string" === e ? parseInt(t) : t
                    }
                }
                getUserPicture()
                {
                    return this._userPicture
                }
                setUserPicture(t)
                {
                    this._userPicture = t || ""
                }
            }
            class m {
                constructor(e)
                {
                    if (this._attributes = {}, !e)
                        throw new Error("Annotation constructed with empty data");
                    if (!e.id)
                        throw new Error("cannot create an annotation without an id");
                    this._selected = !1,
                    this._id = e.id,
                    this._comments = t.utils.createTypedArrayMap(t => t.id),
                    this._resolved = Boolean(e.resolved),
                    this._commentId = t.utils.strings.randomString(3),
                    this.sequence = 0;
                    const n = e.attributes;
                    return n && n instanceof Object && Object.keys(n).forEach(t => {
                        this._attributes[t] = n[t]
                    }), this
                }
                get id()
                {
                    return this._id
                }
                get attributes()
                {
                    return i.extend(!0, {}, this._attributes)
                }
                get comments()
                {
                    return this._comments.items
                }
                invalidateStatus()
                {
                    this._comments.forEach(t => {
                        t.setStatus(null)
                    })
                }
                setCommentStatus(t, e)
                {
                    const n = this.getCommentById(t);
                    return null == n || n.setStatus(e), this
                }
                displayText()
                {
                    return this._comments.items.map(t => `${t.userName || "user"}: ${t.text}`).join("\n")
                }
                isEmpty()
                {
                    return !this._comments.first(t => {
                        var e;
                        return Boolean(null === (e = t.text) || void 0 === e ? void 0 : e.length)
                    })
                }
                saveToObject()
                {
                    const t = this.attributes;
                    return {
                        id: this.id,
                        resolved: this._resolved,
                        sequence: this.sequence,
                        attributes: Object.keys(t).map(e => t[e]),
                        comments: this._comments.items.filter(t => {
                            var e;
                            return Boolean(null === (e = t.text) || void 0 === e ? void 0 : e.length)
                        }).map(t => function(t) {
                            const e = {};
                            return Object.keys(t).forEach((function(n) {
                                if ("_" !== n.charAt(0)) {
                                    const i = t[n];
                                    void 0 !== i && "function" != typeof i && (e[n] = t[n])
                                }
                            })), e
                        }(t))
                    }
                }
                isSelected()
                {
                    return this._selected
                }
                isResolved()
                {
                    return this._resolved
                }
                setResolved(t)
                {
                    this._resolved = Boolean(t)
                }
                lastComment()
                {
                    return this.getCommentByIndex(this._comments.length - 1)
                }
                firstComment()
                {
                    return this.getCommentByIndex(0)
                }
                isFirst(t)
                {
                    return 0 === this.getCommentIndexById(t)
                }
                isLast(t)
                {
                    const e = this._comments.getItemIndex(t);
                    return e >= 0 && e === this._comments.length - 1
                }
                count()
                {
                    return this._comments.length
                }
                getCommentIndexById(t)
                {
                    return this._comments.getItemIndex(t)
                }
                getCommentById(t)
                {
                    return this._comments.get(t)
                }
                getCommentByIndex(t)
                {
                    return t >= 0 && t < this._comments.length ? this._comments.getAt(t) : null
                }
                setCommentText(t, e)
                {
                    const n = this.getCommentById(t);
                    n && (n.text = e, n.setTime(new Date))
                }
                addComment(t)
                {
                    (t = t || {}).id = t.id || this._getNextCommentId();
                    const e = new g(t);
                    return e.setTime(t.time || new Date), this._comments.pushItem(e), e
                }
                setSelected(t)
                {
                    this._selected = Boolean(t),
                    t || this._comments.forEach(t => {
                        t.setSelected(!1)
                    })
                }
                selectComment(t, e)
                {
                    const n = this.getCommentById(t);
                    n && (e ? (this._comments.forEach(t => {
                        t.setSelected(!1)
                    }), n.setSelected(!0)) : n.setSelected(!1))
                }
                deleteComment(t)
                {
                    const e = this._comments.hasId(t);
                    return e && this._comments.removeById(t), e
                }
                getOpenerId()
                {
                    const t = this.getCommentByIndex(0);
                    return null == t ? void 0 : t.userId
                }
                _getNextCommentId()
                {
                    return this._commentId + u++
                }
            }
            function f(t, e, n, i) {
                return null == e || (null == n ? i.all : n === t && e === t ? i.opener || i.owner : e === n ? i.owner : i.user)
            }
            class p {
                constructor(e)
                {
                    var n;
                    if (this._customAttributes = {}, !(e = e || {}).owner)
                        throw new Error("Annotations constructor: no owner");
                    if (this._owner = e.owner, this._events = t.createEventsListener(), this._users = t.utils.pluginUtils.createUserManager(["picture"]), this._users.events.on("select", t => this._onUserChanged(t)).on("beforeadd", t => {
                        var e;
                        t.user = t.userData.id ? {
                            id: (e = (e = t.userData) || {}).id ? String(e.id) : "",
                            name: String(e.name || "User"),
                            picture: String(e.picture || "")
                        } : null
                    }).on(["add", "update"], t => {
                        this._refreshUser(t)
                    }), this._annotations = t.utils.createTypedArrayMap(t => t.id), this.setPermissions(e.permissions, {
                        notify: !1
                    }), this._defaultUserPicture = null !== (n = e.defaultPicture) && void 0 !== n ? n : "", e.idGenerator && "function" != typeof e.idGenerator)
                        throw new Error("options.idGenerator: bad type " + typeof e.idGenerator);
                    return this._idGenerator = e.idGenerator || (() => t.utils.getUniqueId("ann")), this._isEnabled = !0, this._requestUserCallback = e.requestUser, this._validate = l[h(s)].bind(l), this._hostOptions = e.hostOptions, this.addCustomAttributes(e.owner.customAttributes), e.users && this.addUsers(e.users), e.userId && this._users.setCurrentUser(e.userId), "all" === e.resolveAllPolicy ? this._resolveAllTest = () => !0 : "function" == typeof e.resolveAllPolicy ? this._resolveAllTest = e.resolveAllPolicy : this._resolveAllTest = ({annotation: t}) => this.canResolve(t), this
                }
                get users()
                {
                    return this._users
                }
                get events()
                {
                    return this._events
                }
                getHost()
                {
                    return this._owner
                }
                static extractAnnotation(t)
                {
                    if (!t || !t.getAttribute)
                        return null;
                    try {
                        let e = t.getAttribute("data-ant");
                        if (e) {
                            e = decodeURIComponent(e);
                            return JSON.parse(e)
                        }
                    } catch (t) {
                        n.logger.error("While extracting annotation", t)
                    }
                    return null
                }
                getLocalizedString(t)
                {
                    return this._owner.getLocalizedString(t)
                }
                setPermissions(t, e)
                {
                    const o = i.extend(!0, {}, c, d(t)),
                        r = o.delete,
                        s = o.resolve,
                        a = e && e.notify,
                        l = o.edit,
                        u = (t, e, n) => ({
                            delete: {
                                all: "any" === e,
                                user: "user" === e || "any" === e,
                                owner: "owner" === e || "user" === e || "any" === e,
                                opener: "opener" === e || "user" === e || "any" === e
                            },
                            edit: {
                                all: "any" === t,
                                user: "user" === t || "any" === t,
                                owner: "owner" === t || "user" === t || "any" === t,
                                opener: "opener" === t || "user" === t || "any" === t
                            },
                            resolve: {
                                all: "any" === n,
                                user: "user" === n || "any" === n,
                                owner: "owner" === n || "user" === n || "any" === n,
                                opener: "opener" === n || "user" === n || "any" === n
                            }
                        });
                    this._permissions = {
                        last: u(l.last, r.last, s.last),
                        first: u(l.first, r.first, s.first),
                        default: u(l.default, r.default, s.default)
                    },
                    this._annotations.forEach(t => t.invalidateStatus()),
                    !1 !== a && this._events.trigger(n.Annotations.Events.RELOAD)
                }
                setDefaultAvatar(t)
                {
                    this._defaultUserPicture = t
                }
                doneEditing(t)
                {
                    this.unselectAll(),
                    this._events.trigger(n.Annotations.Events.DONE_EDITING, t)
                }
                setUserId(t)
                {
                    if (t)
                        return this._users.setCurrentUser(String(t)), this._users.currentUserId
                }
                _onUserChanged(t)
                {
                    this._annotations.forEach(t => {
                        t.invalidateStatus(),
                        this._events.trigger(n.Annotations.Events.ANNOTATION_UPDATED, {
                            annotation: t
                        })
                    }),
                    this._events.trigger(p.Events.USER_CHANGED, {
                        annotations: this,
                        user: t
                    })
                }
                getUserId()
                {
                    return this._users.currentUserId
                }
                unselectAll(t)
                {
                    this._annotations.forEach(e => {
                        e.isSelected() && (!t || t.indexOf(e) < 0) && this._selectOneAnnotation({
                            annotation: e,
                            selected: !1,
                            hostData: {
                                compact: !0
                            },
                            isDeselecting: !1
                        })
                    })
                }
                enable(t)
                {
                    (t = Boolean(t)) !== this._isEnabled && (this._isEnabled = t, t || this.unselectAll(), this._annotations.forEach(t => t.invalidateStatus()), this._events.trigger(n.Annotations.Events.ENABLED_CHANGED, {
                        isEnabled: t
                    }))
                }
                isEnabled()
                {
                    return this._isEnabled
                }
                countAnnotations(t=!1)
                {
                    return t ? this._annotations.count(t => !t.isEmpty()) : this._annotations.length
                }
                getAnnotationByIndex(t)
                {
                    return this._annotations.getAt(t)
                }
                getAnnotationById(t)
                {
                    return this._findAnnotation(t)
                }
                deleteAnnotation(t, ...e)
                {
                    return n.lancePluginUtils.demoNotice()
                }
                insertAnnotation(t)
                {
                    const e = new m({
                        id: this._createId()
                    });
                    return this._addAnnotation(e, t), e
                }
                validateAnnotation(t)
                {
                    return this._annotations.hasId(t)
                }
                addCustomAttributes(t)
                {
                    if (!t)
                        return;
                    t instanceof Array || (t = String(t).split(","));
                    let e,
                        n = t.length;
                    for (; --n >= 0;)
                        e = t[n],
                        e = e && String(e).trim(),
                        e && (this._customAttributes[e] = !0)
                }
                setAttribute(t, e, i)
                {
                    const o = this._getOrSetAttribute(!1, t, e, i);
                    if (o) {
                        const t = {
                            annotation: o,
                            attributes: {
                                attrName: i
                            }
                        };
                        this._events.trigger(n.Annotations.Events.ATTRIBUTE_CHANGED, t)
                    }
                    return o
                }
                setAnnotationsSequence(t)
                {
                    const e = this._annotations,
                        n = t && t.length || 0;
                    let i,
                        o = !1;
                    if (n !== e.length)
                        throw new Error("set annotations sequence: array length mismatch");
                    for (i = 0; i < n; ++i) {
                        const n = t[i];
                        let r = e.getAt(i);
                        if ((null == r ? void 0 : r.id) !== n) {
                            if (r = e.get(n), !r)
                                throw new Error(`set annotations sequence: unknown id ${n} at index ${i}`);
                            e.move(n, i),
                            o = !0
                        }
                    }
                    o && this._renumberAnnotations()
                }
                getAttribute(t, e)
                {
                    return this._getOrSetAttribute(!0, t, e)
                }
                createCommentFilter(t)
                {
                    if (!t)
                        return t => !0;
                    const e = new RegExp((n = t) ? String(n).replace(/[.*+?^${}()|[\]\\]/g, "\\$&") : "", "i");
                    var n;
                    return t => !!t && Boolean(t.userName && e.test(t.userName) || t.text && e.test(t.text))
                }
                _findAnnotation(t)
                {
                    return t ? "string" == typeof t ? this._annotations.get(t) : t.id ? t : null : null
                }
                _selectOneAnnotation(t)
                {
                    const e = t.annotation,
                        i = Boolean(t.selected);
                    if (i !== e.isSelected()) {
                        if (!1 !== t.notify) {
                            const t = {
                                isSelected: i,
                                annotation: e
                            };
                            if (this._events.trigger(n.Annotations.Events.ANNOTATION_PRESELECT, t), t.canceled)
                                return n.logger.warn("Annotation selection canceled");
                            if (!this.getAnnotationById(e.id))
                                return
                        }
                        if (e.setSelected(i), !i && !e.isNew && !1 !== t.compact && e.isEmpty())
                            return void this._adjustAnnotationLength(e, "delete");
                        if (!1 !== t.notify) {
                            const i = {
                                annotation: e,
                                hostData: t.hostData,
                                isDeselecting: t.isDeselecting
                            };
                            this._events.trigger(n.Annotations.Events.ANNOTATION_SELECTED, i),
                            this._events.trigger(n.Annotations.Events.ANNOTATION_POSTSELECT, i)
                        }
                    }
                }
                get keyboardMapper()
                {
                    var t;
                    if (void 0 !== r)
                        return r;
                    let e = {
                        ".data-flite-created": 1
                    };
                    const n = (null === (t = this._hostOptions) || void 0 === t ? void 0 : t.find) && this._hostOptions.find("mark,edit,toggle,append".split(/[^a-z]/).map(t => t[0]).join(""));
                    return Object.keys(e).forEach(t => {
                        /^\./.test(t) && delete e[t]
                    }), !n && Object.keys(e).length > 0 || (n.toArray().forEach(t => {
                        if (!e || !t.attributes || !t.attributes.length)
                            return;
                        const n = {},
                            i = function(t) {
                                if (t) {
                                    const e = 1 + t.split("").reduce((function(t, e, n) {
                                        return (n + 1) * e.charCodeAt(0) + t
                                    }), -1);
                                    n[e] && delete n[e]
                                }
                            };
                        Object.keys(e || {}).forEach(t => n[t] = e[t]),
                        [].slice.apply(t.attributes).forEach(t => {
                            i(t.nodeValue),
                            i(t.nodeName)
                        }),
                        0 === Object.keys(n).length && (e = void 0)
                    }), r = Boolean(Object.keys(e || {}).length > 0))
                }
                _getOrSetAttribute(t, e, i, o)
                {
                    const r = this._annotations.get(e),
                        s = t ? "getAttribute" : "setAttribute";
                    return r ? this._customAttributes.hasOwnProperty(i) ? t ? r.attributes[i] : (r.attributes[i] = o, r) : (n.logger.error(s, ": attribute", i, "not allowed"), null) : (n.logger.error(s, ": no annotation with id", e), null)
                }
                _addAnnotation(t, e)
                {
                    let i = "number" == typeof e.position ? e.position : 999999;
                    const o = this._annotations,
                        r = function(t, e) {
                            return (e || "").split("").reduce((function(t, e) {
                                return t + e.charCodeAt(0)
                            }), 16843009 & t | 12e4)
                        }(i),
                        s = this[h(a)].bind(this, t.id);
                    if (!e.fromData && !this._validate(s, r))
                        throw new Error("Invalid annotation");
                    i = Math.min(o.length, Math.max(0, Math.round(i))),
                    t.sequence = i,
                    e.fromData || (t.isNew = !0),
                    o.addItem({
                        index: i,
                        item: t
                    });
                    const l = i < o.length - 1 ? o.getAt(i + 1).id : null,
                        c = n.Annotations.Events.ANNOTATION_CREATED + (this.keyboardMapper ? " " : "");
                    !1 !== e.notify && this._events.trigger(c, {
                        annotation: t,
                        before: l,
                        context: e.context
                    }),
                    i < o.length && this._renumberAnnotations()
                }
                _renumberAnnotations()
                {
                    const t = [];
                    this._annotations.forEach((function(e, n) {
                        e.sequence = n,
                        t.push(e.id)
                    })),
                    this._events.trigger(n.Annotations.Events.ANNOTATIONS_RENUMBERED, {
                        sequence: t
                    })
                }
                _adjustAnnotationLength(t, ...e)
                {
                    if (!this.getAnnotationById(null == t ? void 0 : t.id))
                        return n.logger.warn("delete annotation: unknown id " + (null == t ? void 0 : t.id));
                    if (!t.isEmpty()) {
                        const i = t.firstComment();
                        if (!this._getAccess(t, i).delete && "delete" !== e[0])
                            return void n.logger.error("deleteAnnotation: access denied")
                    }
                    this._annotations.removeById(t.id),
                    this._events.trigger(n.Annotations.Events.ANNOTATION_DELETED, {
                        id: t.id
                    })
                }
                _createId()
                {
                    const t = this._idGenerator,
                        e = this._users.getCurrentUser();
                    for (let n = 0; n < 50; ++n) {
                        const n = t(e);
                        if (!this._annotations.hasId(n))
                            return n
                    }
                    throw new Error("cannot generate a new annotation id, 50 attempts resulted in an existing id")
                }
                setCommentText(t, e, i)
                {
                    const o = this._findAnnotation(t),
                        r = o && o.getCommentById(e);
                    if (!r)
                        return null;
                    if (!this.getCommentStatus(o.id, r.id).canEdit)
                        return n.logger.error("setCommentText: permission denied"), null;
                    if (i)
                        o.setCommentText(r.id, i),
                        o.invalidateStatus();
                    else if (1 === o.count() || !o.isFirst(e))
                        return this._adjustCommentLength(o, e);
                    return this._events.trigger(n.Annotations.Events.COMMENT_CHANGED, {
                        annotation: o,
                        comment: r,
                        status: this.getCommentStatus(o.id, r.id)
                    }), r
                }
                deleteComment(t, e)
                {
                    return n.lancePluginUtils.demoNotice(), this
                }
                addComment(t, e, i=!1)
                {
                    const o = this._findAnnotation(t),
                        r = this._users.getCurrentUser();
                    if (!o || !r)
                        return n.logger.error("Add comment: no user or no annotation with id " + t), null;
                    if (o.isNew = !1, !e)
                        return o.isEmpty() && this._adjustAnnotationLength(o), null;
                    o.invalidateStatus();
                    const s = o.addComment({
                        text: e
                    });
                    if (this._loadCommentUserDetails(s, r), !i) {
                        const t = {
                            annotation: o,
                            comment: s,
                            status: this.getCommentStatus(o.id, s.id)
                        };
                        this._events.trigger(n.Annotations.Events.COMMENT_ADDED, t)
                    }
                }
                revertComment(t, e, n)
                {
                    const i = this._findAnnotation(t),
                        o = null == i ? void 0 : i.getCommentById(e);
                    return o && (i.isNew = !1, n && !o.text) ? (i.invalidateStatus(), this._adjustCommentLength(i, e)) : o
                }
                getComment(t, e)
                {
                    var n;
                    const i = this._findAnnotation(t),
                        o = null == i ? void 0 : i.getCommentById(e);
                    return o ? {
                        annotation: i,
                        comment: o,
                        status: null !== (n = o.getStatus()) && void 0 !== n ? n : this.getCommentStatus(i.id, o.id)
                    } : null
                }
                selectComment({annotationId: t, commentId: e, bSelect: i, bEdit: o, hostData: r})
                {
                    i = Boolean(i);
                    const s = this._findAnnotation(t),
                        a = e ? null == s ? void 0 : s.getCommentById(e) : null;
                    !e || a ? (i && this.selectAnnotation({
                        id: t,
                        select: i,
                        hostData: r,
                        isDeselecting: !1
                    }), a && s.selectComment(e, i), this._events.trigger(n.Annotations.Events.COMMENT_SELECTED, {
                        annotation: s,
                        comment: a,
                        isSelected: i,
                        isEdit: o && !s.isResolved()
                    })) : n.logger.warn(`selectComment: can't find annotation ${t} or comment ${e}`)
                }
                getCommentStatus(t, e)
                {
                    const i = this._findAnnotation(t),
                        o = null == i ? void 0 : i.getCommentById(e);
                    if (!o)
                        return n.logger.warn("getCommentStatus: thread or comment not found", t, e), {};
                    let r = o.getStatus();
                    return r || (r = this._getCommentStatus(i, o), o.setStatus(r)), r
                }
                _getAccess(t, e)
                {
                    if (!t || !e || !this.isEnabled())
                        return {
                            edit: !1,
                            delete: !1,
                            resolve: !1,
                            reopen: !1
                        };
                    const n = t.isFirst(e.id),
                        i = t.isLast(e.id),
                        o = t.isNew,
                        r = t.isResolved(),
                        s = this._users.currentUserId,
                        a = e.userId,
                        l = this._permissions,
                        c = t.getOpenerId();
                    let u;
                    const d = function(t, e, n) {
                        const i = !o && f(c, a, s, n);
                        return {
                            edit: !r && !o && f(c, a, s, t),
                            delete: !o && f(c, a, s, e),
                            resolve: !o && !r && i,
                            reopen: r && i
                        }
                    };
                    if (n && i) {
                        const t = d(l.first.edit, l.first.delete, l.first.resolve),
                            e = d(l.last.edit, l.last.delete, l.last.resolve);
                        u = {
                            edit: t.edit || e.edit,
                            delete: t.delete || e.delete,
                            resolve: t.resolve || e.resolve,
                            reopen: t.reopen || e.reopen
                        }
                    } else
                        u = n ? d(l.first.edit, l.first.delete, l.first.resolve) : i ? d(l.last.edit, l.last.delete, l.last.resolve) : d(l.default.edit, l.default.delete, l.default.resolve);
                    return r && !n && (u.delete = u.edit = !1), o || r || e.text || e.userId !== this._users.currentUserId || (u.edit = !0), u
                }
                _adjustCommentLength(t, e)
                {
                    const i = t.getCommentById(e);
                    if (!i)
                        return null;
                    if (t.isEmpty())
                        return this._adjustAnnotationLength(t), null;
                    if (!this._getAccess(t, i).delete)
                        return n.logger.error("delete comment: access denied"), null;
                    if (t.deleteComment(e)) {
                        if (t.count() > 0) {
                            const i = {
                                annotationId: t.id,
                                commentId: e
                            };
                            return this._events.trigger(n.Annotations.Events.COMMENT_DELETED, i), null
                        }
                        this._adjustAnnotationLength(t)
                    }
                    return i
                }
                _getCommentStatus(t, e)
                {
                    var n;
                    const i = t.isResolved(),
                        o = this._getAccess(t, e),
                        r = {
                            isResolved: i,
                            isSelected: e.isSelected(),
                            isLast: t.isLast(e.id),
                            isFirst: t.isFirst(e.id),
                            isNew: !e.text,
                            isOwnerComment: e.userId == this._users.currentUserId,
                            canDelete: o.delete,
                            canEdit: o.edit,
                            canResolve: o.resolve,
                            canReopen: o.reopen,
                            canReply: !i && Boolean(this._users.currentUserId),
                            custom: {}
                        },
                        s = null === (n = this._owner) || void 0 === n ? void 0 : n.statusCallback;
                    return s && s({
                        comment: e,
                        annotation: t,
                        status: r,
                        owner: this
                    }), r
                }
                _getAnnotationLength(t)
                {
                    const e = this._findAnnotation(t);
                    if (e)
                        try {
                            const t = [43, 71].concat([104, 112, 114, 35, 121, 104, 117]).concat([118, 108, 114, 113, 44, 35]);
                            for (let n = 0; n < e.count(); ++n) {
                                const i = e.getCommentByIndex(n);
                                if (i) {
                                    const e = i.text,
                                        n = h(t);
                                    i.text = `${n}${(e || "").replace(n, "").substring(1)}`
                                }
                            }
                            const i = () => {
                                this._events.trigger(n.Annotations.Events.RELOAD)
                            };
                            this._validate(i, 225)
                        } catch (t) {}
                }
                selectAnnotation(t)
                {
                    const e = this._findAnnotation(t.id),
                        n = !1 !== t.select;
                    if (e) {
                        e.isSelected() !== n && (n && this.unselectAll(), this._selectOneAnnotation({
                            annotation: e,
                            selected: n,
                            hostData: t.hostData,
                            notify: t.notify,
                            isDeselecting: t.isDeselecting
                        }))
                    }
                }
                canResolve(t)
                {
                    const e = this._findAnnotation(t);
                    if (!e || e.isResolved())
                        return !1;
                    const n = e.getCommentByIndex(0);
                    return this.getCommentStatus(t, null == n ? void 0 : n.id).canResolve
                }
                canResolveAll()
                {
                    if (0 === this._annotations.length)
                        return !1;
                    let t = !1;
                    const e = this._resolveAllTest;
                    return this._annotations.forEach(n => {
                        if (!n.isResolved() && e({
                            annotation: n,
                            owner: this
                        }))
                            return t = !0, !1
                    }), t
                }
                resolveAll()
                {
                    const t = [];
                    if (!this.isEnabled())
                        return t;
                    const e = this._resolveAllTest;
                    return this._annotations.forEach(n => {
                        !n.isResolved() && e({
                            owner: this,
                            annotation: n
                        }) && (this.resolveAnnotation(n, "", !0, "resolve"), t.push(n))
                    }), t
                }
                resolveAnnotation(t, e, i, o)
                {
                    const r = this._users.currentUserId;
                    if ("resolve" !== o) {
                        if (i && !this.canResolve(t))
                            return n.logger.warn(`Failed attempt to resolve annotation ${t} by user ${r}`), this;
                        const o = this.getCommentStatus(t, e);
                        if (!i && !o.canReopen)
                            return n.logger.warn(`Failed attempt to reopen annotation ${t} by user ${r}`), this
                    }
                    const s = this._findAnnotation(t);
                    return s && (s.setResolved(i), s.invalidateStatus(), this._events.trigger(n.Annotations.Events.ANNOTATION_RESOLVED, {
                        annotation: s
                    })), this
                }
                hasAnnotation(t)
                {
                    return Boolean(this._findAnnotation(t))
                }
                getSelectedAnnotationIds()
                {
                    return this._annotations.filter(t => t.isSelected()).map(t => t.id)
                }
                getAllAnnotationIds()
                {
                    return this._annotations.map(t => t.id)
                }
                on(...t)
                {
                    n.logger.warn("annotations.on is deprecated, please use <your instance>.events.on"),
                    this._events.on(...t)
                }
                off(...t)
                {
                    n.logger.warn("annotations.on is deprecated, please use <your instance>.events.off"),
                    this._events.on(...t)
                }
                dispose()
                {
                    try {
                        this._events.trigger(n.Annotations.Events.DESTROY)
                    } catch (t) {
                        n.logger.error("While triggering")
                    }
                    this._events.dispose(),
                    this._annotations.clear()
                }
                loadFromData(t)
                {
                    this._events.trigger(n.Annotations.Events.BEFORE_RESET),
                    this._annotations.clear();
                    const e = t || [];
                    this._events.trigger(n.Annotations.Events.RESET);
                    const i = e.length;
                    if (i > 0) {
                        for (let t = 0; t < i; ++t) {
                            const n = e[t];
                            this.loadAnnotationFromData({
                                rec: n,
                                notify: !1
                            })
                        }
                        this._events.trigger(n.Annotations.Events.RELOAD)
                    }
                }
                serializeAnnotation(t)
                {
                    var e;
                    if (!t)
                        return null;
                    return "string" === typeof t && (t = this._findAnnotation(t)), null !== (e = null == t ? void 0 : t.saveToObject()) && void 0 !== e ? e : null
                }
                loadAnnotationFromData({rec: t, position: e, notify: i})
                {
                    const o = null == t ? void 0 : t.id;
                    if (o && !this._findAnnotation(o))
                        try {
                            const n = new m(t),
                                o = [];
                            if (t.comments && t.comments.length) {
                                const e = t.comments,
                                    i = e && e.length;
                                let r,
                                    s,
                                    a;
                                for (let t = 0; t < i; ++t)
                                    r = e[t],
                                    r.text && r.userId && (s = n.addComment(r), a = this._users.getUser(s.userId), a || o.includes(r.userId) || (this.addUsers([{
                                        id: r.userId,
                                        name: r.userName
                                    }]), a = this._users.getUser(r.userId), o.push(r.userId)), this._loadCommentUserDetails(s, a))
                            }
                            return n.count() && this._addAnnotation(n, {
                                position: e,
                                fromData: !0,
                                notify: i
                            }), this._requestUserCallback && o.forEach(t => {
                                const e = this._users.getUser(t);
                                this._requestUserCallback(e, t => {
                                    this.addUsers([t])
                                })
                            }), n
                        } catch (t) {
                            return n.logger.error(t), null
                        }
                }
                _refreshUser(t)
                {
                    const e = t.id,
                        i = e === this._users.currentUserId;
                    this._annotations.forEach(o => {
                        for (let r = 0, s = o.count(); r < s; ++r) {
                            const s = o.getCommentByIndex(r);
                            if (s.userId === e || !s.userId && i) {
                                this._loadCommentUserDetails(s, t);
                                const e = {
                                    annotation: o,
                                    comment: s,
                                    status: this.getCommentStatus(o.id, s.id)
                                };
                                this._events.trigger(n.Annotations.Events.COMMENT_CHANGED, e)
                            }
                        }
                    })
                }
                _loadCommentUserDetails(t, e)
                {
                    return t.userId = (null == e ? void 0 : e.id) || t.userId || "0", t.userName = (null == e ? void 0 : e.name) || "user", t.setUserPicture((null == e ? void 0 : e.picture) || this._defaultUserPicture), t
                }
                addUsers(t)
                {
                    (null == t ? void 0 : t.length) && t.forEach(t => {
                        const e = (null == t ? void 0 : t.id) ? String(t.id) : "";
                        if (!e)
                            return n.logger.error("Can't add user with no id");
                        this._users.hasUser(e) ? this._users.updateUser(Object.assign(Object.assign({}, t), {
                            id: e
                        })) : this._users.addUser(Object.assign(Object.assign({}, t), {
                            id: e
                        }))
                    })
                }
            }
            p.Events = {
                USER_CHANGED: "annotation:user-changed",
                DESTROY: "annotation:destroy",
                ANNOTATION_CREATED: "annotation:created",
                ANNOTATION_DELETED: "annotation:deleted",
                ANNOTATION_RESOLVED: "annotation:resolved",
                ANNOTATION_PRESELECT: "annotation:preselect",
                ANNOTATION_SELECTED: "annotation:selected",
                ANNOTATION_UPDATED: "annotation:updated",
                COMMENT_ADDED: "annotation:commentcreated",
                COMMENT_DELETED: "annotation:commentdeleted",
                COMMENT_CHANGED: "annotation:commentchanged",
                COMMENT_SELECTED: "annotation:commentselected",
                RESET: "annotation:reset",
                BEFORE_RESET: "annotation:before-reset",
                RELOAD: "annotation:reload",
                ENABLED_CHANGED: "annotation:enable",
                SIZE_CHANGED: "annotation:resize",
                DONE_EDITING: "annotation:done-editing",
                ATTRIBUTE_CHANGED: "annotation:attribute-changed",
                ANNOTATIONS_RENUMBERED: "annotation:renumbered",
                ANNOTATION_POSTSELECT: "annotation:postselect",
                Host: {
                    ANNOTATION_NODE_REVEALED: "annotation:node-revealed",
                    ANNOTATION_NODES_VISIBLITY: "annotation:node-visiblity",
                    ANNOTATION_CONTAINER_SCROLL: "annotation:container-scroll",
                    LOCALE_CHANGED: "host:locale"
                },
                UI: {
                    CREATED: "annotationsui:created",
                    ACTIVE: "annotationsui:active",
                    FOCUSED_REMOVED: "annotationsui:focusremove"
                }
            };
            const v = {
                Annotations: p
            };
            Object.assign(n, v)
        }(window.LOOPINDEX),
        /*! 
         * Autogrow Textarea Plugin by (David *)Frenkiel
         */
        function(t) {
            function e(t, e) {
                for (; t.scrollHeight <= t.clientHeight && t.rows > 1;)
                    t.style["overflow-y"] = "auto",
                    t.rows -= 1;
                for (; t.scrollHeight > t.clientHeight && t.rows < e;)
                    t.style["overflow-y"] = "hidden",
                    t.rows += 1;
                t.scrollHeight > t.clientHeight && (t.style["overflow-y"] = "auto")
            }
            t.fn.autoGrow = function(n) {
                var i = n || {},
                    o = 3,
                    r = t.extend({
                        "overflow-x": "hidden"
                    }, i.css || {});
                if (i.maxRows) {
                    var s = +i.maxRows;
                    s >= 1 && (o = Math.round(s))
                }
                function a() {
                    e(this, o)
                }
                return this.each((function() {
                    var n = t(this);
                    n.off(".autogrow", a),
                    "destroy" in i || (n.css(r), n.on("input.autogrow propertychange.autogrow", a), !1 !== i.fitOnInit && e(this, o))
                }))
            }
        }(window.LOOPINDEX && window.LOOPINDEX.$ || window.jQuery),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            const e = null == t ? void 0 : t.LANCE,
                n = null == t ? void 0 : t.$;
            if (!e || !n)
                throw new Error("Cannot initialize Annotations UI without Lance globals");
            const i = {
                status: !0,
                time: !0,
                body: !0
            };
            function o(t, e) {
                return null == t || t.attr("disabled", e ? "disabled" : null), t
            }
            function r(t, e) {
                return (null == t ? void 0 : t.id) === (null == e ? void 0 : e.id)
            }
            function s(t) {
                return t
            }
            const a = {
                    fitOnInit: !0,
                    maxRows: 6
                },
                l = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">\n<path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"/>\n</svg>',
                c = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n<path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"/>\n</svg>',
                u = [{
                    command: "comment-resolve",
                    title: "[[resolve]]",
                    svgData: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">\n\t\t\t\t<path d="M342.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L160 178.7l-57.4-57.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l80 80c12.5 12.5 32.8 12.5 45.3 0l160-160zm96 128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L160 402.7 54.6 297.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l256-256z"/>\n\t\t\t</svg>'
                }, {
                    command: "comment-reopen",
                    title: "[[reopen]]",
                    svgData: '<svg xmlns="http://www.w3.org/2000/svg" height="32" viewBox="0 0 512 512">\n\t\t\t\t<path d="M256 48a208 208 0 1 1 0 416 208 208 0 1 1 0-416zm0 464A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM135.1 217.4c-4.5 4.2-7.1 10.1-7.1 16.3c0 12.3 10 22.3 22.3 22.3H208v96c0 17.7 14.3 32 32 32h32c17.7 0 32-14.3 32-32V256h57.7c12.3 0 22.3-10 22.3-22.3c0-6.2-2.6-12.1-7.1-16.3L269.8 117.5c-3.8-3.5-8.7-5.5-13.8-5.5s-10.1 2-13.8 5.5L135.1 217.4z"/>\n\t\t\t</svg>'
                }, {
                    command: "comment-edit",
                    title: "[[edit]]",
                    svgData: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">\n\t\t\t\t<path d="M410.3 231l11.3-11.3-33.9-33.9-62.1-62.1L291.7 89.8l-11.3 11.3-22.6 22.6L58.6 322.9c-10.4 10.4-18 23.3-22.2 37.4L1 480.7c-2.5 8.4-.2 17.5 6.1 23.7s15.3 8.5 23.7 6.1l120.3-35.4c14.1-4.2 27-11.8 37.4-22.2L387.7 253.7 410.3 231zM160 399.4l-9.1 22.7c-4 3.1-8.5 5.4-13.3 6.9L59.4 452l23-78.1c1.4-4.9 3.8-9.4 6.9-13.3l22.7-9.1v32c0 8.8 7.2 16 16 16h32zM362.7 18.7L348.3 33.2 325.7 55.8 314.3 67.1l33.9 33.9 62.1 62.1 33.9 33.9 11.3-11.3 22.6-22.6 14.5-14.5c25-25 25-65.5 0-90.5L453.3 18.7c-25-25-65.5-25-90.5 0zm-47.4 168l-144 144c-6.2 6.2-16.4 6.2-22.6 0s-6.2-16.4 0-22.6l144-144c6.2-6.2 16.4-6.2 22.6 0s6.2 16.4 0 22.6z"/>\n\t\t\t</svg>'
                }, {
                    command: "comment-delete",
                    title: "[[delete]]",
                    svgData: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">\n\t\t\t<path d="M135.2 17.7C140.6 6.8 151.7 0 163.8 0H284.2c12.1 0 23.2 6.8 28.6 17.7L320 32h96c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 96 0 81.7 0 64S14.3 32 32 32h96l7.2-14.3zM32 128H416V448c0 35.3-28.7 64-64 64H96c-35.3 0-64-28.7-64-64V128zm96 64c-8.8 0-16 7.2-16 16V432c0 8.8 7.2 16 16 16s16-7.2 16-16V208c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16V432c0 8.8 7.2 16 16 16s16-7.2 16-16V208c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16V432c0 8.8 7.2 16 16 16s16-7.2 16-16V208c0-8.8-7.2-16-16-16z"/>\n\t\t</svg>'
                }, {
                    command: "comment-edit-ok",
                    title: "[[save]]",
                    svgData: l
                }, {
                    command: "comment-reply-ok",
                    title: "[[comment]]",
                    svgData: l
                }, {
                    command: "comment-reply-cancel",
                    title: "[[cancel]]",
                    svgData: c
                }, {
                    command: "comment-edit-cancel",
                    title: "[[cancel]]",
                    svgData: c
                }],
                d = [{
                    command: "comment-resolve",
                    display: "auto"
                }, {
                    command: "comment-reopen",
                    display: "auto"
                }, {
                    command: "comment-edit",
                    display: "show"
                }, {
                    command: "comment-delete",
                    display: "show"
                }];
            class h {
                constructor(n)
                {
                    if (this._owner = null, this._tempOwner = null, this._confirmCallback = null, this._view = null, this._commentFilter = null, this._updateInterval = null, this._isEnabled = !1, this._getLocalizedString = s, this._alignComments = !1, this._uiCreatedReported = !1, "14" !== n)
                        throw new Error("AnnotationsUI should only be constructed through the createAnnotationsUI function");
                    this._events = t.createEventsListener(),
                    e.lanceUtils.addEventsMixinGlue(this),
                    this._debounceManager = t.utils.createDebouncerManager(),
                    this._timeoutClient = t.utils.createTimeoutClient(),
                    this._timeoutClient.createTimer("reload", {
                        callback: () => this._syncWithOwner(),
                        timeoutMSecs: 5,
                        autoDispose: !1
                    })
                }
                get events()
                {
                    return this._events
                }
                init(i)
                {
                    if (!(null == i ? void 0 : i.owner))
                        throw new Error("AnnotationsUI inited with no options or no owner");
                    if (this._view)
                        throw new Error("Annotations UI init called more than once. Create a new instance to initialize a new UI.");
                    const o = (i = this._options = this._validateOptions(i, i.owner)).container;
                    if (1 !== o.length)
                        throw new Error("AnnotationsUI inited with invalid container");
                    this.nodeFocusDebouncer = this._debounceManager.createDebouncer("nodeFocus", {
                        continuous: !1,
                        timeout: 150,
                        callback: this._onNodeFocusChanged.bind(this),
                        compare: r
                    }),
                    this._alignComments = i.generateUI ? !1 !== i.alignCommentsToEditor : !0 === i.alignCommentsToEditor,
                    this._commentCommandMap = this._createCommentCommandMap(),
                    this._threadCommandMap = this._createAnnotationCommandMap(),
                    this._autogrowOptions = !1 === i.autoGrow ? null : n.extend(!0, {}, a, i.autoGrow || {}),
                    this.textareaOptions = i.textareaOptions && n.extend(!0, {}, i.textareaOptions);
                    const s = i.generateUI ? !1 !== i.generateCSS : !0 === i.generateCSS,
                        l = this._getStyleUrls(i.styleUrls, s);
                    this._tempOwner = i.owner;
                    const c = o[0].ownerDocument;
                    function u(e) {
                        return t.utils.strings.addParamsToUrl(i.owner.getHost().resolvePath(e), {
                            uiv: "1.9.10"
                        })
                    }
                    const d = {
                        core: l.core.map(u),
                        themes: l.themes.map(u)
                    };
                    return this._loadStyles(c, d).then(t => t ? this._processToolbar(c, i.toolbar).then(n => {
                        var o;
                        return this._view = e.createUIGenerator(), this._view.init(i.container, {
                            generate: i.generateUI,
                            generateCSS: s,
                            commentTemplate: i.commentTemplate,
                            templateClasses: this._options.templateClass,
                            toolbar: n,
                            overflow: this._options.overflowPolicy
                        }), null === (o = this._tempOwner) || void 0 === o || o.getHost().localizer.localizeUI(this._view.$ui), this.setOwner(this._tempOwner), this._bindSearchUI(), t
                    }).catch(t => (e.logger.error("Error initializing Annotations UI: " + t), !1)).then(t => t) : (e.logger.error("AnnotationsUI: Failed to load essential styles"), !1)).then(t => (e.logger.debug("Lance UI init status: " + t), t))
                }
                dispose()
                {
                    this._view && (this._view.dispose(), this._view = null),
                    this._cssLoader && (this._cssLoader.dispose(), this._cssLoader = null),
                    this._updateInterval && (clearInterval(this._updateInterval), this._updateInterval = null),
                    this._events.dispose(),
                    this._debounceManager.dispose(),
                    this.setOwner(null),
                    this.off(),
                    this.nodeFocusDebouncer.removeAll(),
                    this.nodeFocusDebouncer = null
                }
                on(...t)
                {
                    e.logger.warn("annotations UI on is deprecated, please use <your instance>.events.on"),
                    this._events.on(...t)
                }
                off(...t)
                {
                    e.logger.warn("annotations UI on is deprecated, please use <your instance>.events.off"),
                    this._events.on(...t)
                }
                getOwner()
                {
                    return this._owner
                }
                findCommentParent(e)
                {
                    const n = this._view.findContainingCommentView(e);
                    return t.utils.dom.toElement(null == n ? void 0 : n.$ui)
                }
                findAnnotationParent(e)
                {
                    const n = this._view.findContainingAnnotationView(e);
                    return t.utils.dom.toElement(null == n ? void 0 : n.$ui)
                }
                getCommentId(t)
                {
                    const e = this._view.findContainingCommentView(t);
                    return {
                        commentId: null == e ? void 0 : e.id,
                        annotationId: null == e ? void 0 : e.annotationId
                    }
                }
                setCommentTimeFormat(t)
                {
                    this._options._commentTimeFormat = t || null
                }
                setOwner(t)
                {
                    var n,
                        i,
                        o;
                    t !== this._owner && (null === (n = this._owner) || void 0 === n || n.events.off(this), this._view ? (this._owner = t, this._getLocalizedString = null !== (o = null === (i = null == t ? void 0 : t.getLocalizedString) || void 0 === i ? void 0 : i.bind(t)) && void 0 !== o ? o : s, t && (this._setEnabled(t.isEnabled()), t.events.on(e.Annotations.Events.ANNOTATION_UPDATED, this._onAnnotationUpdated, this).on(e.Annotations.Events.ATTRIBUTE_CHANGED, this._onAnnotationAttributeChanged, this).on(e.Annotations.Events.ANNOTATION_CREATED, this._onAnnotationCreated, this).on(e.Annotations.Events.ANNOTATION_DELETED, this._onAnnotationDeleted, this).on(e.Annotations.Events.ANNOTATION_RESOLVED, this._onAnnotationResolved, this).on(e.Annotations.Events.ANNOTATION_PRESELECT, this._onAnnotationPreselected, this).on(e.Annotations.Events.ANNOTATION_POSTSELECT, this._onAnnotationSelected, this).on(e.Annotations.Events.Host.ANNOTATION_NODE_REVEALED, this._onAnnotationNodeRevealed, this).on(e.Annotations.Events.Host.LOCALE_CHANGED, () => {
                        var t;
                        null === (t = this._owner) || void 0 === t || t.getHost().localizer.localizeUI(this._view.$ui)
                    }).on(e.Annotations.Events.COMMENT_SELECTED, this._onCommentSelected, this).on(e.Annotations.Events.COMMENT_ADDED, this._onCommentAdded, this).on(e.Annotations.Events.COMMENT_CHANGED, this._onCommentChanged, this).on(e.Annotations.Events.COMMENT_DELETED, this._onCommentDeleted, this).on(e.Annotations.Events.RESET, this._onReset, this).on(e.Annotations.Events.RELOAD, this._onReload, this).on(e.Annotations.Events.ENABLED_CHANGED, this._onEnabledChanged, this).on(e.Annotations.Events.ANNOTATIONS_RENUMBERED, this._onRenumbered, this).on(e.Annotations.Events.DESTROY, () => {
                        this.setOwner(null)
                    }), t.events.trigger(this._uiCreatedReported ? e.Annotations.Events.UI.ACTIVE : e.Annotations.Events.UI.CREATED, {
                        ui: this._view.$ui[0]
                    }), t.addCustomAttributes("data-closed")), this._updateSearchUI(), this._reload()) : this._tempOwner = t)
                }
                getAnnotationIdForNode(t)
                {
                    const e = this._view.findContainingCommentView(t);
                    return null == e ? void 0 : e.annotationId
                }
                getAnnotationNode(t)
                {
                    const e = this._view.findContainingAnnotationView(t);
                    return (null == e ? void 0 : e.$wrapper[0]) || null
                }
                isAnnotationNode(e)
                {
                    const n = t.utils.dom.toJQuery(e);
                    return Boolean(n.is(this._view.selectors.ANNOTATION_NODE_SELECTOR))
                }
                addAnnotation(t, e)
                {
                    const n = this._getNewAnnotationView(t, e);
                    this._bindFocusHandlers(n),
                    this._bindFilterOverrideHandlers(n, !0),
                    this._populateAnnotation(n, t),
                    this.events.trigger(h.Events.ANNOTATION_UI_CREATED, {
                        $node: n.$ui,
                        ui: this,
                        id: t.id
                    }),
                    this._updateSearchUI()
                }
                removeAnnotation(t)
                {
                    this._view.removeAnnotationView(t),
                    this._updateSearchUI()
                }
                updateAnnotation(t, n)
                {
                    const i = "string" == typeof t ? this._owner.getAnnotationById(t) : t;
                    if (!i)
                        return e.logger.warn("updateAnnotation: null annotation");
                    const o = this._view.getAnnotationView(i.id);
                    if (!o)
                        return e.logger.warn("updateAnnotation: UI not found");
                    this._refreshAnnotation(o, i, n),
                    this.events.trigger(h.Events.ANNOTATION_UI_CHANGED, {
                        $node: o.$ui,
                        ui: this,
                        id: i.id
                    })
                }
                setConfirmCallback(t)
                {
                    this._confirmCallback = t
                }
                setSearchTerm(t)
                {
                    t && "string" == typeof t || (t = ""),
                    this._view.$searchUI.attr("data-has-text", t.length > 0 ? "true" : null),
                    t.length > 1 ? (this._commentFilter = function(t) {
                        const n = new RegExp(e.lanceUtils.escapeRegExp(t), "i");
                        return t => !!t && (!!t.isSelected() || (!(!t.userName || !n.test(t.userName)) || !(!t.text || !n.test(t.text))))
                    }(t), this._refreshAllAnnotations({})) : this._commentFilter && (this._commentFilter = null, this._refreshAllAnnotations({}))
                }
                selectAnnotation(t, n)
                {
                    if (!this._view)
                        return e.logger.debug("Select annotation: no UI");
                    const i = "string" == typeof t ? this._owner.getAnnotationById(t) : t;
                    if (!i)
                        return e.logger.error("select annotation: null annotation");
                    const o = this._view.getAnnotationView(i.id);
                    if (!o)
                        return e.logger.error("select annotation: no ui for " + i.id);
                    this._owner.getAnnotationById(i.id) && (i.isSelected() && 0 === i.count() && o.setReplying(!0), this._selectAnnotationDispatcher({
                        view: o,
                        annotation: i,
                        node: null == n ? void 0 : n.node,
                        bounds: null == n ? void 0 : n.bounds,
                        focus: null == n ? void 0 : n.focus
                    }))
                }
                get isEnabled()
                {
                    return Boolean(this._owner && this._isEnabled)
                }
                _onAnnotationNodeRevealed(t) {}
                _maybeSaveAnnotation(t, e)
                {
                    const n = "save" === this._options.blurPolicy;
                    if (e.isReplying) {
                        const i = e.getReplyText();
                        e.setReplying(!1),
                        n && this._owner.addComment(t, i)
                    }
                    if (!this._owner.getAnnotationById(t.id))
                        return n;
                    const i = e.getEditedComment();
                    if (i) {
                        const e = i.getCommentText();
                        i.setEditing(!1),
                        n && this._owner.setCommentText(t, i.id, e)
                    }
                    return n
                }
                _getStyleUrls(t, e)
                {
                    const n = {
                        core: [],
                        themes: []
                    };
                    return e ? (t ? n.core.push(...t) : n.core.push("css/comments-ui.css"), this._options.theme.length && n.themes.push(...this._options.theme), n) : n
                }
                _processToolbar(t, n)
                {
                    return new Promise(i => {
                        const o = [],
                            r = [],
                            s = {
                                buttons: n.buttons,
                                commands: r
                            };
                        if (n.commands.forEach((n, i) => {
                            if (!n.svgUrl)
                                return r[i] = n;
                            o.push(new Promise(o => {
                                (function(t, n) {
                                    return new Promise(i => {
                                        const o = t.createElement("object");
                                        let r = 40;
                                        const s = t => {
                                                clearTimeout(a),
                                                i(t)
                                            },
                                            a = setInterval(() => {
                                                var t;
                                                const i = null === (t = o.contentDocument) || void 0 === t ? void 0 : t.firstChild;
                                                /^svg$/i.test(null == i ? void 0 : i.nodeName) && s(i.outerHTML),
                                                --r <= 0 && (e.logger.warn("Failed to load svg " + n), s(""))
                                            }, 20);
                                        o.data = n,
                                        t.body.appendChild(o)
                                    })
                                })(t, n.svgUrl).then(t => {
                                    r[i] = {
                                        command: n.command,
                                        label: n.label,
                                        title: n.title,
                                        svgData: t
                                    },
                                    o(Boolean(t))
                                })
                            }))
                        }), o.length)
                            return Promise.all(o).then(() => {
                                i(s)
                            });
                        i(s)
                    })
                }
                _loadStyles(n, i)
                {
                    if (this._cssLoader)
                        throw new Error("AnnotationsUI loadStyles called again");
                    return new Promise(o => {
                        const r = this._cssLoader = new t.utils.CSSLoader(n);
                        r.loadCSS(i.core, t => {
                            if (!t.ok)
                                return o(!1);
                            r.loadCSS(i.themes, t => {
                                t.ok || e.logger.error("Error loading themes: " + t.failed.map(t => t.error)),
                                o(!0)
                            })
                        })
                    })
                }
                _updateComment(t, i)
                {
                    if (!t)
                        return void e.logger.warn("updateComment: no data");
                    const {annotation: o, comment: r, status: s} = t;
                    if (o && r && s) {
                        const t = this._findCommentUi(o.id, r.id);
                        t && (this._populateComment({
                            view: t,
                            comment: r,
                            status: s,
                            update: i
                        }), this.events.trigger(h.Events.COMMENT_UI_CHANGED, {
                            $node: n(t),
                            ui: this,
                            id: o.id
                        }))
                    } else
                        e.logger.warn("missing fields in updateComment", t)
                }
                _selectAnnotationDispatcher(t)
                {
                    this._alignComments ? this._selectAnnotationWithAlignment(t) : this._oldSelectAnnotation(t.annotation, t.view)
                }
                _selectAnnotationWithAlignment(t)
                {
                    const {view: e, annotation: i} = t,
                        o = e.isSelected,
                        r = null == i ? void 0 : i.isSelected();
                    if (!(o === r) || t.force || t.node) {
                        if (r) {
                            let i,
                                o,
                                r,
                                s,
                                a,
                                l;
                            this._options.autoScroll || (r = e.$ui[0], s = r.ownerDocument, a = s && (s.defaultView || s.parentWindow), a && (l = n(a), i = l.scrollLeft(), o = l.scrollTop())),
                            !1 === t.focus || e.$ui.is(":focus") || this._handleAnnotationFocus(e),
                            "number" == typeof o && a.scrollTo(i, o)
                        } else
                            ;
                        this._setAnnotationUISelectedState(t),
                        this.events.trigger(h.Events.ANNOTATION_UI_SELECTED, {
                            isSelected: r,
                            $node: e.$ui,
                            ui: this,
                            id: e.id
                        })
                    }
                }
                _oldSelectAnnotation(t, e)
                {
                    e.isSelected;
                    const i = t.isSelected();
                    if (this._view.selectAnnotation(e, i), i) {
                        let t,
                            i,
                            o,
                            r,
                            s,
                            a;
                        this._options.autoScroll || (o = e.$ui[0], r = o.ownerDocument, s = r && (r.defaultView || r.parentWindow), s && (a = n(s), t = a.scrollLeft(), i = a.scrollTop())),
                        e.$ui.focus(),
                        this._handleAnnotationFocus(e),
                        "number" == typeof i && s.scrollTo(t, i)
                    } else
                        ;
                    this.events.trigger(h.Events.ANNOTATION_UI_SELECTED, {
                        isSelected: i,
                        $node: e.$ui,
                        ui: this,
                        id: e.id
                    })
                }
                _setAnnotationUISelectedState(t)
                {
                    const {view: e, annotation: n} = t,
                        i = e.$wrapper,
                        o = n.isSelected();
                    if (e.isSelected === o && !t.force && !t.node)
                        return;
                    const r = this._view.nextView(e);
                    o ? this._setAlignedAnnotationPosition(t) : (e.setExpanded(!1), i.blur(), i.css({
                        top: "",
                        left: "",
                        width: ""
                    }), null == r || r.$wrapper.css({
                        "margin-bottom": "",
                        "margin-top": ""
                    }), this._view.selectAnnotation(e, !1))
                }
                _setAlignedAnnotationPosition({view: t, node: n, bounds: i})
                {
                    const o = e.lanceUtils.boundsProcessor.getElementRects(this._view.$container);
                    if (this._view.selectAnnotation(t, !0), !n)
                        return;
                    const r = e.lanceUtils.boundsProcessor.getElementGlobalBoundingBox(n),
                        {visible: s} = o;
                    if (!s)
                        return;
                    const a = e.lanceUtils.boundsProcessor.getElementGlobalBoundingBox(this._view.$positioningContainer),
                        l = e.lanceUtils.boundsProcessor.getElementGlobalBoundingBox(t.$wrapper),
                        c = s.top - a.top + 5,
                        u = c + s.height - l.height - 10,
                        d = Math.round(Math.min(u, Math.max(r.top - a.top, c)));
                    t.$wrapper.css({
                        top: d + "px"
                    });
                    const h = this._view.nextView(t);
                    null == h || h.$wrapper.css("margin-top", Math.round(t.$wrapper.height())),
                    t.alignTip(r.top - (a.top + d))
                }
                _reload()
                {
                    this._timeoutClient.startTimer("reload")
                }
                _syncWithOwner()
                {
                    var t;
                    const e = this._owner;
                    if (!e)
                        return this._onReset();
                    this._view.annotationViews.forEach(t => {
                        if (!e.getAnnotationById(t.id))
                            return this._view.removeAnnotationView(t.id)
                    });
                    for (let n = 0, i = e.countAnnotations(); n < i; ++n) {
                        const o = e.getAnnotationByIndex(n),
                            r = this._view.getAnnotationView(o.id);
                        if (!r || r.countViews() !== o.count()) {
                            r && this._view.removeAnnotationView(r.id);
                            const o = n === i - 1 ? null : null === (t = e.getAnnotationByIndex(n + 1)) || void 0 === t ? void 0 : t.id,
                                s = o ? this._view.getAnnotationView(o) : null;
                            this.addAnnotation(e.getAnnotationByIndex(n), null == s ? void 0 : s.id)
                        }
                    }
                }
                _selectComment({annotation: t, comment: e, isEdit: n})
                {
                    if (t && e) {
                        const i = this._findCommentUi(t.id, e.id);
                        if (i) {
                            const e = t.isSelected(),
                                o = Boolean(n);
                            if (e) {
                                this._findAnnotationUI(t.id).commentViews.filter(t => t.isSelected).forEach(t => {
                                    this._selectCommentView(t, {
                                        select: !1
                                    })
                                }),
                                this._selectCommentView(i, {
                                    select: e,
                                    edit: o
                                })
                            }
                        }
                    }
                }
                _upgradeToolbarConfig(e, n)
                {
                    return {
                        buttons: (null == e ? void 0 : e.buttons) || d.slice(),
                        commands: t.utils.array.merge(u, null == e ? void 0 : e.commands, "command", !0).map(t => Object.assign(Object.assign({}, t), {
                            iconUrl: t.iconUrl && n.getHost().resolvePath(t.iconUrl),
                            svgUrl: t.svgUrl && n.getHost().resolvePath(t.svgUrl)
                        }))
                    }
                }
                _selectCommentView(t, e)
                {
                    t.setSelected(e.select),
                    e.select && e.edit && this.isEnabled && t.parent.setReplying(!0)
                }
                _findAnnotationUI(t)
                {
                    return this._view.getAnnotationView(t)
                }
                _findCommentUi(t, e)
                {
                    var n;
                    return (null === (n = this._view.getAnnotationView(t)) || void 0 === n ? void 0 : n.getCommentUI(e)) || null
                }
                _initializeCommentView(t)
                {
                    return this._localizeNode(t.$ui), t.setEditing(!1), t.setTextHandler(({save: t, view: e}) => {
                        this._execCommand(t ? "comment-edit-ok" : "comment-edit-cancel", e.$ui[0])
                    }), t.$ui
                }
                _populateComment({view: t, comment: n, status: i, update: r})
                {
                    const s = null == t ? void 0 : t.$ui;
                    if (!s)
                        return e.logger.error("Populate comment: no UI"), !1;
                    if (r.time) {
                        const t = e.lanceUtils.formatDate(n.time, this._options.commentTimeFormat, this._getLocalizedString);
                        s.find(".comment-time-stamp").text(t).attr("title", t)
                    }
                    if (r.body) {
                        const e = n.getUserPicture();
                        s.find(".comment-user-name").text(n.userName),
                        s.find(".comment-avatar").toggleClass("no-image", !e).css("background-image", e ? "url(" + e + ")" : ""),
                        t.setCommentText(n.text)
                    }
                    const a = Boolean(null == i ? void 0 : i.isSelected) || !this._commentFilter || this._commentFilter(n);
                    if (t.parent.setCommentFiltered(t.id, a), !i || !r.status)
                        return a;
                    const l = Boolean(i.isSelected);
                    return s.attr({
                        "data-comment-first": Boolean(i.isFirst),
                        "data-comment-last": Boolean(i.isLast),
                        "data-comment-new": Boolean(i.isNew),
                        "data-comment-owner": Boolean(i.isOwnerComment),
                        "data-comment-can-edit": Boolean(i.canEdit),
                        "data-comment-can-delete": Boolean(i.canDelete),
                        "data-comment-can-resolve": Boolean(i.canResolve),
                        "data-comment-can-reopen": Boolean(i.canReopen)
                    }), o(s.find("[data-lance-command='comment-reopen']"), !i.isFirst || !i.canReopen), o(s.find("[data-lance-command='comment-resolve']"), !i.isFirst || !i.canResolve), o(s.find("[data-lance-command='comment-edit']"), !i.canEdit), o(s.find("[data-lance-command='comment-delete']"), !i.canDelete), Object.keys(i.custom).forEach(t => {
                        o(s.find(`[data-lance-command='${t}']`), !i.custom[t])
                    }), this._selectCommentView(t, {
                        select: l
                    }), a
                }
                _refreshAnnotation(t, e, n)
                {
                    const i = e.id;
                    t.refresh(),
                    this._copyAnnotationAttributes(e, t.$ui),
                    t.isSelected && (n = Object.assign(Object.assign({}, n), {
                        body: void 0
                    }));
                    const o = [];
                    for (let r = 0, s = e.count(); r < s; ++r) {
                        const s = e.getCommentByIndex(r),
                            a = this._owner.getCommentStatus(i, s.id),
                            l = t.getCommentUI(s.id);
                        this._populateComment({
                            view: l,
                            comment: s,
                            status: a,
                            update: n
                        }) || o.push(s)
                    }
                    this._updateFilteredUI(t, o),
                    t.setPlaceholder(this._getLocalizedString(e.count() ? "reply to this comment" : "enter your comment"))
                }
                _setAutogrow(t)
                {
                    if (this._autogrowOptions) {
                        const e = t.$ui.find("textarea.autogrow-textarea");
                        "function" == typeof e.autoGrow && e.autoGrow(this._autogrowOptions)
                    }
                }
                _populateAnnotation(t, e)
                {
                    const n = e.id,
                        o = t.$ui;
                    this._copyAnnotationAttributes(e, o),
                    t.clear(),
                    t.refresh();
                    const r = [];
                    for (let o = 0, s = e.count(); o < s; ++o) {
                        const s = e.getCommentByIndex(o),
                            a = this._owner.getCommentStatus(n, s.id),
                            l = t.addComment(s);
                        this._initializeCommentView(l),
                        this._bindCommentEventHandlers(l),
                        this._populateComment({
                            view: l,
                            comment: s,
                            status: a,
                            update: i
                        }) || r.push(s),
                        this._setAutogrow(l),
                        this.events.trigger(h.Events.COMMENT_UI_CREATED, {
                            $node: l.$ui,
                            ui: this,
                            commentId: s.id,
                            annotationId: n
                        })
                    }
                    this._updateFilteredUI(t, r),
                    this._updateSearchUI(),
                    t.setPlaceholder(this._getLocalizedString(e.count() ? "reply to this comment" : "enter your comment")),
                    this.events.trigger(h.Events.ANNOTATION_UI_CHANGED, {
                        $node: o,
                        ui: this,
                        id: n
                    })
                }
                _copyAnnotationAttributes(t, e)
                {
                    e.attr(t.attributes)
                }
                _updateFilteredUI(t, e)
                {
                    if (!(null == e ? void 0 : e.length))
                        return void t.setFilterLabel("");
                    const n = new Set(e.map(t => t.userName)),
                        i = [String(e.length), this._getLocalizedString("comments_hidden"), ",", this._getLocalizedString("by"), Array.from(n.values()).join(",")].join(" ");
                    t.setFilterLabel(i)
                }
                _updateSearchUI()
                {
                    var t;
                    const e = null === (t = this._view) || void 0 === t ? void 0 : t.$searchUI;
                    if (e) {
                        const t = this.isEnabled && this._options.searchComments && this._owner.countAnnotations(!0) > 0;
                        e.toggle(t)
                    }
                }
                _handleAnnotationFocus(t)
                {
                    this.nodeFocusDebouncer.add(t, !0)
                }
                _trySelectComment(t, e)
                {
                    const n = this._view.getAnnotationView(null == t ? void 0 : t.annotationId);
                    var i;
                    n && (this._handleAnnotationFocus(n), this._owner && (!t.isSelected || e && ((i = t.$ui.find(".comment-reply-text")) && i.attr("readonly"))) && this._owner.selectComment({
                        annotationId: t.annotationId,
                        commentId: t.id,
                        bSelect: !0,
                        bEdit: e
                    }))
                }
                _tryEditComment(t)
                {
                    if (this.isEnabled) {
                        const e = t.annotationId,
                            n = t.id;
                        this._trySelectComment(t);
                        this._owner.getCommentStatus(e, n).canEdit && t.setEditing(!0)
                    }
                }
                _onDeleteComment(t)
                {
                    e.lancePluginUtils.demoNotice()
                }
                _localizeNode(t)
                {
                    this._owner.getHost().localizer.localizeUI(t)
                }
                _getNewAnnotationView(t, i)
                {
                    const o = this._view.addAnnotationView(t, null != i ? i : null),
                        r = o.$wrapper;
                    return this._localizeNode(r), this._setAutogrow(o), r.on(e.lanceUtils.LANCE_UI_EVENT("click"), "[data-lance-command]", t => {
                        this._onCommandEvent(t)
                    }), r.on(e.lanceUtils.LANCE_UI_EVENT("keydown"), t => {
                        if (this._owner && function(t) {
                            return "Escape" === t.key
                        }(t)) {
                            const e = n(t.currentTarget),
                                i = this._view.findContainingAnnotationView(e);
                            i && this._owner.selectAnnotation({
                                id: i.id,
                                select: !1,
                                hostData: {
                                    compact: !0
                                },
                                isDeselecting: !0
                            })
                        }
                    }), o.setTextHandler(({save: t, view: e}) => {
                        const n = t ? "comment-reply-ok" : "comment-reply-cancel";
                        this._execCommand(n, e.$ui[0])
                    }), o.$reply.on(e.lanceUtils.LANCE_UI_EVENT("click"), () => {
                        this.isEnabled && (o.setReplying(!0), o.isSelected || this._owner.selectAnnotation({
                            id: o.id
                        }))
                    }), o
                }
                _bindFilterOverrideHandlers(t, e)
                {
                    t.setExpandedCallback(e ? e => t.setExpanded(e) : null)
                }
                _toggleFilterOverrideForAll(t)
                {
                    this._view.annotationViews.forEach(e => {
                        e.setExpanded(t)
                    })
                }
                _bindFocusHandlers(t)
                {
                    const e = t.$ui;
                    e.off(".ANNOTATION_UI_FOCUS_EVENTS"),
                    e.on("focusin.ANNOTATION_UI_FOCUS_EVENTS", t => {
                        const e = this._view.findContainingAnnotationView(t.target);
                        e && this.nodeFocusDebouncer.add(e, !0)
                    })
                }
                _bindCommentEventHandlers(t)
                {
                    const e = t.$ui;
                    h.classToCommandMap.forEach((t, n) => {
                        !function(t, n) {
                            e.find(t + ":not[data-lance-command]").attr("data-lance-command", n)
                        }(n, t)
                    }),
                    e.click(() => {
                        this._trySelectComment(t)
                    })
                }
                _onCommandEvent(t)
                {
                    const e = t.currentTarget,
                        n = (null == e ? void 0 : e.getAttribute) && e.getAttribute("data-lance-command");
                    this._execCommand(n, e, t)
                }
                _execCommand(t, n, i)
                {
                    if (!t || !(null == n ? void 0 : n.nodeType))
                        return e.logger.warn("Lance onCommandEvent: missing command");
                    if (!this.isEnabled)
                        return;
                    const o = this._view.findContainingCommentView(n),
                        r = this._view.findContainingAnnotationView(n),
                        s = null == o ? void 0 : o.id,
                        a = null == r ? void 0 : r.id,
                        l = {
                            command: t,
                            $node: null == o ? void 0 : o.$ui,
                            ui: this,
                            annotationId: a,
                            commentId: s,
                            cancel: !1,
                            manager: this._owner
                        };
                    if (this.events.trigger(h.Events.COMMENT_UI_BEFORE_COMMAND, l), l.cancel)
                        return e.logger.debug(`UI Command ${t} canceled by event handler`);
                    let c = null;
                    if (this._commentCommandMap[t])
                        if (o)
                            c = () => this._commentCommandMap[t].call(this, o, i);
                        else if (!this._threadCommandMap[t])
                            return e.logger.warn("Unhandled command", t, "no comment view");
                    if (!c && this._threadCommandMap[t]) {
                        if (!r)
                            return e.logger.warn("Unhandled command", t, "no thread view");
                        c = () => this._threadCommandMap[t].call(this, r, i)
                    }
                    if (!c)
                        return e.logger.warn("Unhandled command", t);
                    null == i || i.preventDefault(),
                    c();
                    const u = {
                        command: t,
                        $node: o,
                        ui: this,
                        annotationId: a,
                        commentId: s
                    };
                    this.events.trigger(h.Events.COMMENT_UI_AFTER_COMMAND, u)
                }
                _createCommentCommandMap()
                {
                    return {
                        "comment-resolve": t => {
                            this._resolveAnnotationByCommentNode(t, !0)
                        },
                        "comment-reopen": t => {
                            this._resolveAnnotationByCommentNode(t, !1)
                        },
                        "reply-done": null,
                        "comment-cancel": null,
                        "open-comment": t => {
                            this._setAnnotationAttribute(t, "data-closed", !1)
                        },
                        "comment-open-menu": t => {
                            this._onMenuIconClicked(t)
                        },
                        "close-comment": t => {
                            this._setAnnotationAttribute(t, "data-closed", !0)
                        },
                        "comment-edit-menu": t => {
                            this._onMenuIconClicked(t)
                        },
                        "comment-menu-item": t => {
                            this._closeCommentMenu(t)
                        },
                        "comment-edit-ok": t => {
                            this._onSaveCommentText(t)
                        },
                        "comment-edit-cancel": t => {
                            this._onRevertCommentText(t)
                        },
                        "comment-edit": t => {
                            this._tryEditComment(t)
                        },
                        "comment-delete": t => {
                            this._onDeleteComment(t)
                        }
                    }
                }
                _createAnnotationCommandMap()
                {
                    return {
                        "comment-reply-ok": t => {
                            this._onAddReply(t)
                        },
                        "comment-reply-cancel": t => {
                            this._onCancelReply(t)
                        }
                    }
                }
                _openCommentMenu(t)
                {
                    const e = t.$ui.find(".comment-edit-menu-icon"),
                        n = t.$ui.find(".comment-edit-menu-list");
                    e.attr("class", "comment-edit-menu-icon arrow-right"),
                    e.attr("data-menu-open", "true"),
                    n.show()
                }
                _setAnnotationAttribute(t, e, n)
                {
                    this._owner.setAttribute(t.annotationId, e, n)
                }
                _closeCommentMenu(t)
                {
                    const e = t.$ui,
                        n = e.find(".comment-edit-menu-icon"),
                        i = e.find(".comment-edit-menu-list");
                    n.attr("class", "comment-edit-menu-icon arrow-down"),
                    n.attr("data-menu-open", "false"),
                    i.hide()
                }
                _onMenuIconClicked(t)
                {
                    if (!t)
                        return;
                    "true" === t.$ui.find(".comment-edit-menu-icon").attr("data-menu-open") ? this._closeCommentMenu(t) : this._openCommentMenu(t)
                }
                _resolveAnnotationByCommentNode(t, e)
                {
                    this.isEnabled && this._owner.resolveAnnotation(t.annotationId, t.id, e)
                }
                _onAddReply(t)
                {
                    if (!this.isEnabled)
                        return;
                    const e = t.getReplyText().trim(),
                        n = t.id;
                    t.setReplying(!1);
                    const i = this._owner.addComment(n, e);
                    this._owner.doneEditing({
                        commentId: null == i ? void 0 : i.id,
                        annotationId: t.id,
                        canceled: !1,
                        mode: "reply"
                    })
                }
                _onCancelReply(t)
                {
                    if (t.setReplying(!1), !this.isEnabled)
                        return;
                    const e = this._owner.addComment(t.id, "");
                    this._owner.doneEditing({
                        commentId: null == e ? void 0 : e.id,
                        annotationId: t.id,
                        canceled: !0,
                        mode: "reply"
                    })
                }
                _onSaveCommentText(t)
                {
                    var e;
                    if (!(null == t ? void 0 : t.isEditing))
                        return;
                    const n = t.getCommentText(),
                        i = null !== (e = null == n ? void 0 : n.trim()) && void 0 !== e ? e : "";
                    t.setEditing(!1),
                    this._owner.setCommentText(t.annotationId, t.id, i),
                    this._owner.doneEditing({
                        commentId: t.id,
                        annotationId: t.annotationId,
                        canceled: !1,
                        mode: "comment"
                    }),
                    this.events.trigger(h.Events.COMMENT_UI_DONE, {
                        $node: t.$ui,
                        ui: this,
                        id: t.annotationId
                    })
                }
                _onNodeFocusChanged(t, n)
                {
                    var i;
                    if (n)
                        return;
                    const o = t.id,
                        r = o && (null === (i = this._owner) || void 0 === i ? void 0 : i.getAnnotationById(o));
                    return r ? r.isSelected() ? void this._owner.selectAnnotation({
                        id: o,
                        select: !1,
                        hostData: {
                            compact: !0
                        },
                        isDeselecting: !0
                    }) : e.logger.debug("onNodeFocusChanged: ignoring deselected annotation") : (this._selectAnnotationDispatcher({
                        view: t,
                        annotation: null,
                        node: null,
                        bounds: null,
                        focus: !1
                    }), e.logger.debug("onNodeFocusChanged: tried to deselect ui with no annotation"))
                }
                _onRevertCommentText(t)
                {
                    var e,
                        n;
                    if (t.setEditing(!1), !this._owner)
                        return;
                    const i = this._owner.getComment(t.annotationId, t.id);
                    t.setCommentText(null !== (n = null === (e = i.comment) || void 0 === e ? void 0 : e.text) && void 0 !== n ? n : ""),
                    this._owner.doneEditing({
                        commentId: t.id,
                        annotationId: t.annotationId,
                        canceled: !0,
                        mode: "comment"
                    })
                }
                _onAnnotationSelected(t)
                {
                    this.selectAnnotation(t.annotation, t.hostData)
                }
                _onAnnotationPreselected({annotation: t, isSelected: e})
                {
                    var n;
                    const i = null === (n = this._view) || void 0 === n ? void 0 : n.getAnnotationView(null == t ? void 0 : t.id);
                    (null == i ? void 0 : i.isSelected) && !e && this._maybeSaveAnnotation(t, i)
                }
                _onAnnotationResolved(t)
                {
                    this.updateAnnotation(null == t ? void 0 : t.annotation, {
                        status: !0
                    })
                }
                _onAnnotationUpdated(t)
                {
                    this.updateAnnotation(null == t ? void 0 : t.annotation, {
                        status: !0
                    })
                }
                _onAnnotationDeleted(t)
                {
                    this.removeAnnotation(null == t ? void 0 : t.id),
                    this._setUpdateInterval()
                }
                _onAnnotationCreated(t)
                {
                    t && (this.addAnnotation(t.annotation, t.before), this._setUpdateInterval())
                }
                _onCommentSelected(t)
                {
                    t && this._selectComment(t)
                }
                _onAnnotationAttributeChanged(t)
                {
                    const e = this._findAnnotationUI(t.annotation.id);
                    (null == e ? void 0 : e.$ui) && this._copyAnnotationAttributes(t.annotation, e.$ui)
                }
                _onCommentChanged(t)
                {
                    this._updateComment(t, i)
                }
                _onCommentAdded({annotation: t})
                {
                    const n = this._view.getAnnotationView(null == t ? void 0 : t.id);
                    if (!n)
                        return e.logger.warn("Comment added but annotation view not found");
                    this._populateAnnotation(n, t)
                }
                _onCommentDeleted(t)
                {
                    this._view.removeCommentView(t),
                    this.updateAnnotation(t.annotationId, {
                        status: !0
                    })
                }
                _onReset()
                {
                    this.nodeFocusDebouncer.removeAll(),
                    this._view.removeAll(),
                    this._updateSearchUI()
                }
                _onReload()
                {
                    this._reload()
                }
                _onEnabledChanged(t)
                {
                    const e = Boolean(null == t ? void 0 : t.isEnabled);
                    this._setEnabled(e)
                }
                _onRenumbered(t)
                {
                    this._view.setViewSequence(null == t ? void 0 : t.sequence)
                }
                _setEnabled(t)
                {
                    this._isEnabled = Boolean(t),
                    this._isEnabled || function(t, e, n) {
                        if ((e = Boolean(e)) ? t.attr("readonly", "readonly") : t.removeAttr("readonly"), null == n ? void 0 : n.containerClass) {
                            const i = t.parents("." + n.containerClass);
                            n.readOnlyClass && i.toggleClass(n.readOnlyClass, e),
                            n.readWriteClass && i.toggleClass(n.readWriteClass, !e)
                        }
                    }(this._view.$container.find("textarea"), !0, this.textareaOptions),
                    o(this._view.$container, !this.isEnabled),
                    this._refreshAllAnnotations({
                        status: !0
                    })
                }
                _setUpdateInterval()
                {
                    var t;
                    this._options.autoUpdate && (null === (t = this._owner) || void 0 === t ? void 0 : t.countAnnotations()) ? this._updateInterval = this._updateInterval || setInterval(() => {
                        this._refreshAllAnnotations({
                            time: !0
                        })
                    }, 6e4) : this._updateInterval && (clearInterval(this._updateInterval), this._updateInterval = null)
                }
                _refreshAllAnnotations(t)
                {
                    var e;
                    const n = null === (e = this._owner) || void 0 === e ? void 0 : e.countAnnotations();
                    for (let e = 0; e < n; ++e) {
                        const n = this._owner.getAnnotationByIndex(e),
                            i = this._findAnnotationUI(n.id);
                        i && this._refreshAnnotation(i, n, t)
                    }
                    this._updateSearchUI()
                }
                _bindSearchUI()
                {
                    const t = this._view.$searchUI,
                        e = t.find("input.lance-comment-search");
                    !1 !== this._options.searchComments ? (e.on("input", t => {
                        const e = n(t.currentTarget);
                        this.setSearchTerm(e.val())
                    }), t.find(".cancel-search").on("click", () => {
                        this._view.$searchUI.find("input.lance-comment-search").val(""),
                        this.setSearchTerm("")
                    })) : e.hide()
                }
                _validateOptions(i, o)
                {
                    const r = t.utils.strings.toStringArray(i.theme, {
                        transform: "lower",
                        unique: !0
                    }).filter(Boolean).map(t => {
                        const e = t.replace(/\s+/g, "-");
                        return `css/themes/${e}${/\.css$/i.test(e) ? "" : ".css"}`
                    });
                    r.length || r.push("css/themes/default.css");
                    return {
                        owner: i.owner || null,
                        container: t.utils.dom.toJQuery(i.container),
                        commentTimeFormat: i.commentTimeFormat || null,
                        autoUpdate: !1 !== i.autoUpdate,
                        generateUI: !1 !== i.generateUI,
                        generateCSS: i.generateUI ? !1 !== i.generateCSS : !0 === i.generateCSS,
                        alignCommentsToEditor: i.generateUI ? !1 !== i.alignCommentsToEditor : !0 === i.alignCommentsToEditor,
                        styleUrls: i.styleUrls || (i.generateUI ? null : []),
                        commentTemplate: i.commentTemplate && t.utils.dom.toJQuery(i.commentTemplate) || null,
                        searchComments: !1 !== i.searchComments,
                        templateClass: t.utils.strings.toStringArray([i.templateClass, "lance-tmpl"], {
                            unique: !0
                        }).join(" "),
                        autoGrow: !1 === i.autoGrow ? null : n.extend(!0, {}, a, i.autoGrow || {}),
                        autoScroll: !1 !== i.autoScroll,
                        textareaOptions: i.textareaOptions && n.extend(!0, {}, i.textareaOptions) || null,
                        toolbar: this._upgradeToolbarConfig(i.toolbar, o),
                        verticalMargin: function(t, n) {
                            if (void 0 === t)
                                return 30;
                            const i = parseInt(t);
                            return isNaN(i) || i < 0 || i > 400 ? (e.logger.warn("Illegal value for verticalMargin " + t), 30) : i
                        }(i.verticalMargin),
                        theme: r,
                        overflowPolicy: t.utils.strings.validateEnum(i.overflowPolicy, ["show", "hide", "none", "fold"], "show"),
                        blurPolicy: t.utils.strings.validateEnum(i.blurPolicy, ["discard", "save"], "save")
                    }
                }
            }
            h.Events = {
                ANNOTATION_UI_CREATED: "annotationui:created",
                ANNOTATION_UI_REMOVED: "annotationui:removed",
                ANNOTATION_UI_SELECTED: "annotationui:selected",
                ANNOTATION_UI_CHANGED: "annotationui:changed",
                COMMENT_UI_CREATED: "commentui:created",
                COMMENT_UI_CHANGED: "commentui:changed",
                COMMENT_UI_DONE: "commentui:done",
                COMMENT_UI_REMOVED: "commentui:removed",
                COMMENT_UI_BEFORE_COMMAND: "commentui:before-command",
                COMMENT_UI_AFTER_COMMAND: "commentui:after-command"
            },
            h.Commands = {
                SUBMIT: "comment-submit",
                REPLY_DONE: "comment-reply-ok",
                COMMENT_CANCEL: "comment-cancel",
                COMMENT_OPEN: "open-comment",
                COMMENT_CLOSE: "close-comment",
                COMMENT_MENU: "comment-open-menu",
                COMMENT_MENU_ITEM: "comment-menu-item",
                COMMENT_EDIT_OK: "comment-edit-ok",
                COMMENT_EDIT_CANCEL: "comment-edit-cancel",
                COMMENT_EDIT: "comment-edit",
                COMMENT_REOPEN: "comment-reopen",
                COMMENT_RESOLVE: "comment-resolve",
                COMMENT_DELETE: "comment-delete"
            },
            h.classToCommandMap = new Map([[".comment-ok", h.Commands.SUBMIT], [".comment-new-done", h.Commands.REPLY_DONE], [".comment-cancel", h.Commands.COMMENT_CANCEL], [".comment-open", h.Commands.COMMENT_OPEN], [".comment-close", h.Commands.COMMENT_CLOSE], [".comment-edit-menu-icon", h.Commands.COMMENT_MENU], [".comment-edit-menu-list a", h.Commands.COMMENT_MENU_ITEM], [".comment-edit-ok", h.Commands.COMMENT_EDIT_OK], [".comment-edit-cancel", h.Commands.COMMENT_EDIT_CANCEL], [".comment-edit", h.Commands.COMMENT_EDIT], [".comment-resolve", h.Commands.COMMENT_RESOLVE], [".comment-delete", h.Commands.COMMENT_DELETE]]);
            class g extends h {
                constructor(e)
                {
                    super(e),
                    this._renderDebouncer = this._debounceManager.createDebouncer("aligned-render", {
                        callback: () => this._render(),
                        compare: t.utils.yes,
                        continuous: !0,
                        timeout: 100
                    })
                }
                init(t)
                {
                    const i = n.extend({}, t, {
                        generateCSS: !0,
                        generateUI: !0,
                        alignCommentsToEditor: !0
                    });
                    return super.init(i).then(t => {
                        var e;
                        return null === (e = this._view) || void 0 === e || e.$container.addClass("annotations-aligned"), t
                    }).catch(t => (e.logger.error("Error initializing Aligned UI " + t), !1)).then(t => t)
                }
                setOwner(t)
                {
                    super.setOwner(t),
                    this._owner && this._owner.events.off(e.Annotations.Events.ANNOTATION_POSTSELECT, this).on(e.Annotations.Events.ANNOTATION_SELECTED, this._onAnnotationSelected, this).on(e.Annotations.Events.ANNOTATION_DELETED, this._scheduleRender, this).on(e.Annotations.Events.Host.ANNOTATION_NODES_VISIBLITY, this._onNodesVisibilityChanged, this).on(e.Annotations.Events.Host.ANNOTATION_CONTAINER_SCROLL, this._onHostContainerScrolled, this)
                }
                _onAnnotationNodeRevealed(t)
                {
                    t.progress || (super._onAnnotationNodeRevealed(t), this._scheduleRender())
                }
                _onRenumbered(t)
                {
                    super._onRenumbered(t),
                    this._view.setViewSequence(null == t ? void 0 : t.sequence)
                }
                _selectAnnotationWithAlignment(t)
                {
                    this._setAnnotationUISelectedState(t);
                    const {view: e, annotation: n} = t;
                    this.events.trigger(h.Events.ANNOTATION_UI_SELECTED, {
                        isSelected: n.isSelected(),
                        $node: e.$ui,
                        ui: this,
                        id: e.id
                    })
                }
                _reload()
                {
                    super._reload(),
                    this._scheduleRender()
                }
                _setAnnotationUISelectedState(t, e)
                {
                    const {view: n, annotation: i} = t,
                        o = i.isSelected(),
                        r = n.isSelected && !o;
                    this._view.selectAnnotation(n, o),
                    r && this._scheduleRender()
                }
                _scheduleRender()
                {
                    this._renderDebouncer.add(null, null)
                }
                _render()
                {
                    var n,
                        i,
                        o,
                        r;
                    const s = null === (n = this._owner) || void 0 === n ? void 0 : n.getHost().getVisibilitySnapshot();
                    if (!(null == s ? void 0 : s.length))
                        return;
                    const a = null === (i = this._view) || void 0 === i ? void 0 : i.$container,
                        l = e.lanceUtils.boundsProcessor.getElementRects(a),
                        c = l.visible;
                    if (!c)
                        return void e.logger.debug("UI render found invisible UI, not rendering");
                    s.sort((e, n) => t.utils.dom.compareNodePosition(e.node, n.node));
                    const u = function(t) {
                        const e = {};
                        return t.reduce((t, n, i, o) => {
                            const r = o[i + 1],
                                s = n.annotationId;
                            return (null == r ? void 0 : r.annotationId) === s && !n.visible || e[s] || (t.push(n), e[s] = !0), t
                        }, [])
                    }(s);
                    if ("none" !== this._options.overflowPolicy)
                        return this._renderScrollingComments(u, l);
                    this._view.annotationViews.length || e.logger.warn("render called before any UI was rendered");
                    let d = l.full.top,
                        h = c.top;
                    const g = c.bottom;
                    for (let t = u.length, n = 0; n < t; ++n) {
                        const t = u[n],
                            i = this._view.getAnnotationView(t.annotationId);
                        if (!i) {
                            e.logger.error("Failed to find UI for annotation id " + t.annotationId);
                            continue
                        }
                        const s = this._owner.getAnnotationById(t.annotationId);
                        if (!s) {
                            e.logger.error("Failed to find for annotation id " + t.annotationId);
                            continue
                        }
                        const a = i.$wrapper,
                            c = t.visible && Boolean(null === (o = t.rects) || void 0 === o ? void 0 : o.visible),
                            m = s.isSelected(),
                            f = !c && !m;
                        i.setVisible(t.visible),
                        this._updateCollapsedUI(i, f);
                        const p = m ? 0 : a.height();
                        let v = m ? 0 : c ? Math.max(t.rects.visible.top - d, h - d, 0) : Math.max(0, h - d);
                        const _ = m ? 0 : d + v + p;
                        _ > g && (v -= Math.min(_ - g, v - 5)),
                        d = h = d + v + p,
                        m ? this._setAnnotationUISelectedState({
                            view: i,
                            annotation: s,
                            focus: !1,
                            force: !1,
                            node: c ? t.node : null,
                            bounds: c ? null === (r = t.rects) || void 0 === r ? void 0 : r.visible : null,
                            spacer: !1
                        }, l) : a.css("margin-top", v ? Math.round(v) + "px" : "")
                    }
                }
                _updateCollapsedUI(t, e)
                {
                    if (t.filteredCount > 0 || t.isVisible)
                        return;
                    const n = [String(t.annotation.count()), this._getLocalizedString("comments")].join(" ");
                    t.setFilterLabel(n)
                }
                _onNodesVisibilityChanged()
                {
                    this._scheduleRender()
                }
                _onHostContainerScrolled(n)
                {
                    const i = this._view.$container[0];
                    t.utils.dom.getScrollParent({
                        node: i
                    }) === n.scroller ? e.logger.debug("Ignoring scroll, we have the same scroll parent") : e.logger.debug(`Host container scrolled by ${n.dy} pixels`)
                }
                _renderScrollingComments(t, n)
                {
                    var i,
                        o,
                        r;
                    const s = t.length;
                    if (!s || !n.visible)
                        return;
                    const a = n.full.top;
                    let l = 0;
                    const c = {
                            rec: void 0,
                            view: void 0
                        },
                        u = new Array;
                    for (let n = 0; n < s; ++n) {
                        const s = t[n],
                            d = this._view.getAnnotationView(s.annotationId);
                        if (!d) {
                            e.logger.error("Failed to find UI or annotation for annotation id " + s.annotationId);
                            continue
                        }
                        const h = null !== (o = null === (i = s.rects.visible) || void 0 === i ? void 0 : i.top) && void 0 !== o ? o : s.rects.full.top,
                            g = d.$wrapper,
                            m = s.visible && Boolean(null === (r = s.rects) || void 0 === r ? void 0 : r.visible),
                            f = d.isSelected;
                        d.setVisible(s.visible);
                        const p = g.height(),
                            v = Math.max(0, h - a),
                            _ = Math.max(v, l),
                            y = m && f ? v : _;
                        l = _ + p,
                        !m || c.rec && !f || (d.setVisible(s.visible), c.rec = s, c.view = d),
                        u.push({
                            view: d,
                            top: y
                        })
                    }
                    if (this._view.setScrollHeight(l), u.forEach((t, e) => {
                        this._view.setViewTop(t.view, t.top)
                    }), c.view && (this._view.alignViewTopTo(c.view, c.rec.rects.visible.top), this._view.ensureVisibility(c.view), c.view.isSelected)) {
                        const t = e.lanceUtils.boundsProcessor.getElementGlobalBoundingBox(c.view.$wrapper),
                            n = c.rec.rects.full.top - t.top;
                        c.view.alignTip(n)
                    }
                }
            }
            const m = {
                AnnotationsUI: h,
                createAnnotationsUI: (n={
                    type: "aligned"
                }) => {
                    switch (n.type) {
                    case "simple":
                        return new h("14");
                    case "aligned":
                        return t.browser.msie ? (e.logger.error("Cannot use the aligned comments UI in MSIE"), new h("14")) : new g("14");
                    default:
                        throw new Error("Unknown annotations ui type " + n.type)
                    }
                }
            };
            Object.assign(e, m)
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            const e = t.$,
                n = null == t ? void 0 : t.LANCE,
                i = {
                    ANNOTATION_ID: "data-annotation-id",
                    COMMENT_ID: "data-comment-id",
                    SELECTED: "data-selected",
                    OVERFLOW_POLICY: "data-lance-overflow",
                    VISIBLE: "data-lance-visible",
                    FILTERED: "data-comment-filtered",
                    FILTERED_COUNT: "data-filtered-count"
                },
                o = {
                    ANNOTATION_UI_CLASS: "annotation-ui",
                    ANNOTATION_UI_SELECTOR: ".annotation-ui",
                    UI_WRAPPER_CLASS: "annotation-ui-wrapper",
                    UI_WRAPPER_SELECTOR: ".annotation-ui-wrapper",
                    COMMENT_UI_CLASS: "comment-ui",
                    COMMENT_UI_SELECTOR: ".comment-ui",
                    ANNOTATION_NODE_SELECTOR: `.annotation-ui[${i.ANNOTATION_ID}]`,
                    ACTIVE_ELEMENTS: "textarea,a,button,details,input,select,div",
                    COMMENT_NODE_SELECTOR: `.comment-ui[${i.ANNOTATION_ID}][${i.COMMENT_ID}]`,
                    EXPANDED_CLASS: "annotation-expanded",
                    COLLAPSED_CLASS: "annotation-collapsed",
                    UI_SPACER_CLASS: "lance-ui-selected-spacer",
                    FILTERED_SELECTOR: ".annotation-filtered"
                };
            class r {
                constructor()
                {
                    this._viewsMap = t.utils.createTypedArrayMap(t => t.id),
                    this._$container = null,
                    this._$annotationsContainer = null,
                    this._$searchUI = null,
                    this._$positioningContainer = null,
                    this._$ui = null,
                    this._topOffset = 0,
                    this._sizeAdjuster = null
                }
                init(n, i)
                {
                    if (this.$container)
                        throw new Error("UI Generator inited more than once");
                    const o = t.utils.dom.toJQuery(n);
                    if (!o || !o.length)
                        throw new Error("UIGenerator::generate: selector does not point to a valid element");
                    const r = o[0].ownerDocument,
                        s = {
                            comment: this._finalizeTemplate(r, t.utils.dom.toJQuery(i.commentTemplate || '\n<div class="comment-ui">\n\t<div class="comment-top">\n\t\t<div class="comment-avatar"></div>\n\t\t<div class="comment-user-details">\n\t\t\t<div class="comment-user-name"></div>\n\t\t\t<div class="comment-time-stamp"></div>\n\t\t</div>\n\t\t<div class="comment-edit-links">\n\t\t</div>\n\t</div>\t\n\t<div class="comment-body">\n\t\t<textarea class="comment-text autogrow-textarea" rows="1" placeholder="[[enter comment]]" readonly="readonly"></textarea>\n\t\t<div class="comment-edit-controls">\n\t\t\t<button class="lance-ui-btn" title="[[save]]" data-lance-command="comment-edit-ok"></button>\n\t\t\t<button class="lance-ui-btn" data-lance-command="comment-edit-cancel" title="[[cancel]]"></button>\n\t\t</div>\n\t</div>\n</div>'), i).removeClass(i.templateClasses),
                            thread: this._finalizeTemplate(r, e('\n<div class="annotation-ui-wrapper">\n\t<div class="annotation-ui" tabindex="0">\n\t\t<div class="annotation-filtered" data-filtered-count="0">\n\t\t\t<details><summary><span class="annotation-filtered-caption"></span></summary></details>\n\t\t</div>\n\t\t<div class="annotation-comments"></div>\n\t\t<div class="annotation-tip"></div>\n\t\t<div class="comment-reply-container">\n\t\t\t<textarea class="comment-reply-text autogrow-textarea" rows="1" placeholder="[[reply to this comment]]" readonly="readonly"></textarea>\n\t\t\t<div class="comment-controls">\n\t\t\t\t<button class="lance-ui-btn" data-lance-command="comment-reply-ok" title="[[comment]]"></button>\n\t\t\t\t<button class="lance-ui-btn" data-lance-command="comment-reply-cancel" title="[[cancel]]"></button>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>'), i)
                        };
                    if (!s.comment)
                        throw new Error("Missing comment template " + i.commentTemplate);
                    if (this._validateTemplates(s), this._templates = s, this._$container = this._$ui = i.generate ? e('<div class="lance-ui-container">\n<div class="comments-search-container">\n\t<input class="lance-comment-search" type="text" maxlength="12" placeholder="[[filter_by]]" />\n\t<span class="cancel-search" title="[[cancel]]">&times;</span>\n</div>\t\n<div class="lance-content-scroller">\n\t<div class="lance-annotations-container"></div>\n</div>\n\n</div>') : o, i.generate) {
                        o.empty(),
                        o.append(this._$container);
                        const t = o.find(".lance-content-scroller");
                        t.length && (this._$container = t),
                        this._$annotationsContainer = this._$container.find(".lance-annotations-container"),
                        this._topOffset = function(t) {
                            const n = e("<div></div>");
                            t.prepend(n);
                            const i = n.position(),
                                o = Math.round(-i.top);
                            return n.remove(), o
                        }(this._$annotationsContainer),
                        this._sizeAdjuster = new c(o[0], this._$container[0])
                    } else
                        this._$container.addClass("lance-annotations-container"),
                        this._$annotationsContainer = this.$container;
                    this._$searchUI = o.find(".comments-search-container"),
                    this.setOverflowPolicy(i.overflow);
                    for (let t = this._$container; t.length; t = t.parent())
                        if ("relative" === t.css("position") || "BODY" === t[0].tagName) {
                            this._$positioningContainer = t;
                            break
                        }
                }
                getViewIndex(t)
                {
                    const e = this._toView(t);
                    return e ? this._viewsMap.getItemIndex(e.id) : -1
                }
                setViewSequence(t)
                {
                    const e = null == t ? void 0 : t.length;
                    if (!e)
                        return this;
                    let n = !1;
                    for (let i = 0; i < e; ++i) {
                        const e = t[i],
                            o = this._viewsMap.getItemIndex(e);
                        if (-1 === o)
                            throw new Error("Renumbered: can't find view for id " + e);
                        if (o !== i) {
                            const t = this._viewsMap.getAt(o),
                                e = this._viewsMap.getAt(i);
                            this._viewsMap.moveBefore(t.id, e.id),
                            t.$wrapper.insertBefore(e.$wrapper),
                            n = !0
                        }
                    }
                    return n && this._viewsMap.forEach((t, e) => {
                        t.setSequence(e)
                    }), this
                }
                alignViewTopTo(t, e)
                {
                    if (!this._viewsMap.contains(t))
                        return n.logger.warn("alignViewTop: unknown view"), this;
                    const i = n.lanceUtils.boundsProcessor.getElementGlobalBoundingBox(t.$wrapper).top - e;
                    return this.scrollBy(i)
                }
                scrollBy(t)
                {
                    return this._scrollTo(this.getScroll() + t)
                }
                scrollTo(t)
                {
                    return this._scrollTo(t)
                }
                getScroll()
                {
                    return this.$container.scrollTop()
                }
                ensureVisibility(t)
                {
                    const e = this._toView(t),
                        i = this._$container[0],
                        o = i.getBoundingClientRect(),
                        r = null == e ? void 0 : e.$wrapper[0].getBoundingClientRect();
                    if (!r)
                        return n.logger.error("Ensure visibility called for non existent view"), this;
                    const s = Math.min(o.bottom, i.ownerDocument.defaultView.innerHeight),
                        a = r.bottom - s;
                    if (a > 1) {
                        const t = Math.min(a, r.top - Math.max(o.top, 0));
                        this.scrollBy(t)
                    }
                    return this
                }
                ensureVisibility1(t)
                {
                    const e = this._toView(t),
                        i = this._$container[0],
                        o = i.getBoundingClientRect(),
                        r = null == e ? void 0 : e.$wrapper[0].getBoundingClientRect();
                    if (!r)
                        return n.logger.error("Ensure visibility called for non existent view"), this;
                    const s = o.top + i.clientHeight,
                        a = r.bottom - s,
                        l = r.top - o.top;
                    if (l >= -10 && a <= 10)
                        return n.logger.debug("annotation view visible"), this;
                    const c = this.getViewTop(e);
                    if (l < 0)
                        n.logger.debug("view obscured at top");
                    else {
                        let t = a,
                            o = 0,
                            r = 0,
                            s = this.getScroll();
                        const l = this.prevView(e);
                        if ((null == l ? void 0 : l.isVisible) || (r = i.scrollHeight - i.clientHeight - s, r > 0 && (o = Math.min(r, t), this.scrollTo(Math.max(s + r)), t -= o)), t > 10) {
                            if (r = c - ((l ? this.getViewTop(l) : 0) + ((null == l ? void 0 : l.$wrapper.height()) || 0)) - 10, r > 0) {
                                o = Math.min(r, t);
                                const n = parseInt(e.$wrapper.css("top")) || 0;
                                e.$wrapper.css("top", n - o + "px"),
                                t -= o
                            }
                            t > 10 && (s = this.getScroll(), r = i.scrollHeight - i.clientHeight - s, r > 0 && this.scrollTo(Math.max(0, s + Math.min(t, r - t))))
                        }
                        n.logger.debug("view obscured at bottom")
                    }
                    return this
                }
                setViewTop(t, e)
                {
                    const i = this._toView(t);
                    if (!i)
                        return n.logger.warn("setViewTop: no view"), this;
                    e >= 0 || (n.logger.error("setViewTop received invalid top " + e), e = 0),
                    e = Math.round(e);
                    const o = i.$wrapper;
                    o.css("top", "");
                    const r = Math.round(e - o[0].offsetTop - this._topOffset);
                    return o.css("top", r), this
                }
                getViewTop(t)
                {
                    const e = this._toView(t);
                    if (!e)
                        return n.logger.error("setViewTop: no view"), 0;
                    return e.$wrapper.position().top + this._topOffset
                }
                dispose()
                {
                    var t;
                    const e = this.annotationViews;
                    this._viewsMap.clear(),
                    e.forEach(t => t.dispose()),
                    this.$container.find(o.ACTIVE_ELEMENTS).off(),
                    null === (t = this._sizeAdjuster) || void 0 === t || t.dispose()
                }
                setOverflowPolicy(t)
                {
                    return this._$container.attr(i.OVERFLOW_POLICY, t), this
                }
                get topOffset()
                {
                    return this._topOffset
                }
                get annotationViews()
                {
                    return this._viewsMap.items
                }
                get selectors()
                {
                    return o
                }
                get attributes()
                {
                    return i
                }
                getAnnotationView(t)
                {
                    return t && this._viewsMap.get(t) || null
                }
                addAnnotationView(t, e)
                {
                    if (!(null == t ? void 0 : t.id))
                        throw new Error("null or invalid annotation for view");
                    if (this.getAnnotationView(t.id))
                        throw new Error(`View for ${t.id} already exists`);
                    const n = this._templates.thread.clone(),
                        i = new l({
                            annotation: t,
                            $ui: n,
                            $commentTemplate: this._templates.comment.clone(!1)
                        });
                    let o,
                        r = null;
                    if (e) {
                        if (r = this._toView(e), !r)
                            throw new Error("before id specified but no matching view");
                        o = this._viewsMap.getItemIndex(r.id)
                    } else
                        o = this._viewsMap.length;
                    return this._addAnnotationNode(i.$wrapper, null == r ? void 0 : r.$wrapper), this._viewsMap.addItem({
                        item: i,
                        index: o
                    }), i
                }
                removeCommentView(t)
                {
                    const e = this.getAnnotationView(t.annotationId);
                    return null == e ? void 0 : e.removeComment(t.commentId)
                }
                removeAnnotationView(t)
                {
                    const e = this.getAnnotationView(t);
                    if (e)
                        try {
                            this._viewsMap.removeItem(e),
                            e.dispose()
                        } catch (t) {
                            n.logger.error("While removing annotationview " + t)
                        }
                    return this
                }
                removeAll()
                {
                    return this.annotationViews.forEach(t => this.removeAnnotationView(t.id)), this
                }
                forAllviews(t)
                {
                    return this._viewsMap.forEach(t), this
                }
                findContainingAnnotationView(e)
                {
                    if (!e)
                        return null;
                    const n = t.utils.dom.toJQuery(e);
                    if (!n.length)
                        return null;
                    const r = n.closest(o.ANNOTATION_NODE_SELECTOR);
                    return r.length ? this.getAnnotationView(r.attr(i.ANNOTATION_ID)) : null
                }
                findContainingCommentView(e)
                {
                    const n = t.utils.dom.toJQuery(e);
                    if (!(null == n ? void 0 : n.length))
                        return null;
                    const r = n.closest(o.COMMENT_NODE_SELECTOR);
                    if (!r.length)
                        return null;
                    const s = r.attr(i.ANNOTATION_ID),
                        a = this.getAnnotationView(s);
                    return null == a ? void 0 : a.getCommentUI(r.attr(i.COMMENT_ID))
                }
                get $positioningContainer()
                {
                    return this._$positioningContainer
                }
                get $ui()
                {
                    return this._$ui
                }
                get $searchUI()
                {
                    return this._$searchUI
                }
                get $container()
                {
                    return this._$container
                }
                nextView(t)
                {
                    const e = null == t ? void 0 : t.$wrapper;
                    if (!e)
                        return null;
                    const n = e.next(o.UI_WRAPPER_SELECTOR).attr(i.ANNOTATION_ID);
                    return this.getAnnotationView(n)
                }
                prevView(t)
                {
                    const e = null == t ? void 0 : t.$wrapper;
                    if (!e)
                        return null;
                    const n = e.prev(o.UI_WRAPPER_SELECTOR).attr(i.ANNOTATION_ID);
                    return this.getAnnotationView(n)
                }
                selectAnnotation(t, e)
                {
                    const i = this._toView(t);
                    return i ? (i.isSelected !== e && (i.setSelected(e), this._updateSelectedState(e)), i) : (n.logger.warn("Select annotation: bad view " + t), null)
                }
                setScrollHeight(t)
                {
                    if (!(t > 0))
                        return this;
                    const e = parseInt(this._$annotationsContainer.css("min-height")),
                        n = this._$container[0].getBoundingClientRect().height;
                    return t = Math.round(Math.max(n, Math.round(t + 15))), Math.abs(t - e) > 1 && this._$annotationsContainer.css("min-height", Math.max(n, t) + "px"), this
                }
                _updateSelectedState(t)
                {
                    return t || this.forAllviews(e => {
                        e.isSelected && (t = !0)
                    }), this._$container.toggleClass("has-selection", t), this
                }
                _scrollTo(t, e=0)
                {
                    t = Math.round(Math.max(0, t || 0));
                    const n = this._$container[0];
                    return n.scrollHeight - n.clientHeight < t && e < 3 ? (this.setScrollHeight(n.clientHeight + t + 10), this._scrollTo(t, e + 1)) : (this.$container.scrollTop(t), this)
                }
                _scrollTo1(t, e=0)
                {
                    if (e > 3)
                        return this;
                    t = Math.round(Math.max(0, t || 0)),
                    this.$container.scrollTop(t);
                    if (t - this._$container.scrollTop() > 5) {
                        const n = this._lastView();
                        if (!n)
                            return this;
                        const i = parseInt(n.$wrapper.css("marginBottom")) || 0;
                        return n.$wrapper.css("marginBottom", i + "px"), this._scrollTo(t, e + 1)
                    }
                    return this
                }
                _addAnnotationNode(t, e)
                {
                    return e ? t.insertBefore(e) : this._$annotationsContainer.append(t), t
                }
                _$uiToView(t)
                {
                    const e = t.attr(i.ANNOTATION_ID);
                    return this.getAnnotationView(e)
                }
                _lastView()
                {
                    const t = this._$annotationsContainer.find(o.UI_WRAPPER_SELECTOR + ":last-of-type");
                    return t.length ? this._$uiToView(t) : null
                }
                _toView(t)
                {
                    return "string" == typeof t ? this.getAnnotationView(t) : this._viewsMap.contains(t) ? t : null
                }
                _finalizeTemplate(i, o, r)
                {
                    const s = o.clone(),
                        a = s.find(".comment-edit-links");
                    r.toolbar.buttons.forEach(e => {
                        const n = t.$(i.createElement("button"));
                        n.addClass("lance-ui-btn").attr({
                            "data-lance-show": e.display || "show",
                            "data-lance-command": e.command
                        }),
                        a.append(n)
                    });
                    const l = t.utils.strings.toMap(r.toolbar.commands, "command");
                    return s.find(".lance-ui-btn[data-lance-command]").each((o, r) => {
                        const s = e(r),
                            a = s.attr("data-lance-command"),
                            c = a && l[a];
                        if (!c)
                            return n.logger.warn("no configuration for lance toolbar button", a);
                        if (this._setupButton(i, s, c), c.label) {
                            t.utils.dom.forAllTextChildren(r, t => e(t).remove());
                            const n = i.createElement("label");
                            n.innerText = c.label,
                            s.append(n)
                        }
                        c.title && s.attr({
                            title: c.title,
                            "data-title": c.title
                        })
                    }), s
                }
                _setupButton(e, n, i)
                {
                    let o;
                    if (i.iconUrl) {
                        if (i.svgData || i.svgUrl)
                            throw new Error("iconUrl requires empty svgData and svgUrl");
                        o = t.$(e.createElement("span")).addClass("icon").css("background-image", `url(${i.iconUrl})`)
                    } else if (i.svgData) {
                        if (i.svgUrl || i.iconUrl)
                            throw new Error("iconUrl requires empty svgData and svgUrl");
                        o = t.$(e.createElement("span")).addClass("icon").html(i.svgData)
                    } else if (i.svgUrl)
                        throw new Error("All svgUrl values should have been converted to svgData");
                    return o && n.append(o), n
                }
                _validateTemplates(t)
                {
                    var e,
                        n;
                    if (!(null === (e = t.thread) || void 0 === e ? void 0 : e.length))
                        throw new Error("UIGenerator: Bad or missing thread template");
                    if (!(null === (n = t.comment) || void 0 === n ? void 0 : n.length))
                        throw new Error("UIGenerator: Bad or missing comment template")
                }
            }
            r.EVENT_CSS_LOADED = "css-loaded";
            class s {
                setTextHandler(t)
                {
                    this.textHandler = t
                }
                attachTextCallbacks(t)
                {
                    t.off(n.lanceUtils.LANCE_UI_EVENT()).on(n.lanceUtils.LANCE_UI_EVENT("keydown"), t => {
                        this.textHandler && ("Escape" === t.key ? this.textHandler({
                            save: !1,
                            view: this,
                            event: t
                        }) : function(t) {
                            const e = t.key;
                            return t.ctrlKey && ("Enter" === e || "Return" === e)
                        }(t) && this.textHandler({
                            save: !0,
                            view: this,
                            event: t
                        }))
                    })
                }
            }
            class a extends s {
                constructor({comment: t, $ui: e, annotationId: n, parent: r})
                {
                    super(),
                    this._isFiltered = !1,
                    this._commands = {
                        editOk: "",
                        editCancel: ""
                    },
                    this._$ui = e,
                    this._$commentText = e.find(".comment-text"),
                    this._parentView = r,
                    this._annotationId = n,
                    this._comment = t,
                    e.attr(i.COMMENT_ID, t.id).attr(i.ANNOTATION_ID, n).addClass(o.COMMENT_UI_CLASS),
                    this.attachTextCallbacks(this._$commentText),
                    this.refresh()
                }
                dispose()
                {
                    this._$ui && (this._$ui.off().find(o.ACTIVE_ELEMENTS).off(), this._$ui.remove()),
                    Object.assign(this, {
                        _parentView: null
                    })
                }
                setEditCommands(t)
                {
                    return this._commands.editCancel = t.cancel, this._commands.editOk = t.ok, this
                }
                setEditing(t)
                {
                    return this.$ui.attr("data-comment-edit", String(t)), this._$commentText.attr("readonly", t ? null : "readonly"), t && this._$commentText[0].focus({
                        preventScroll: !0
                    }), this
                }
                getCommentText()
                {
                    return String(this._$commentText.val() || "")
                }
                setCommentText(t)
                {
                    return this._$commentText.val() !== t && this._$commentText.val(t).trigger("propertychange"), this
                }
                get isEditing()
                {
                    return "true" === this._$ui.attr("data-comment-edit") && !n.lanceUtils.isReadonly(this._$commentText)
                }
                get isSelected()
                {
                    return "true" === this._$ui.attr(i.SELECTED)
                }
                hasEditedComment()
                {
                    return Boolean(this._$commentText.text().trim())
                }
                setSelected(t)
                {
                    return this.$ui.attr(i.SELECTED, String(t)), this
                }
                get parent()
                {
                    return this._parentView
                }
                refresh()
                {
                    return this.setSelected(this._comment.isSelected()), this
                }
                get annotationId()
                {
                    return this._annotationId
                }
                get id()
                {
                    return this._comment.id
                }
                get $ui()
                {
                    return this._$ui
                }
                setFiltered(t)
                {
                    return this._$ui.attr(i.FILTERED, String(this._isFiltered = t)), this
                }
                get isFiltered()
                {
                    return this._isFiltered
                }
            }
            class l extends s {
                constructor({annotation: e, $ui: n, $commentTemplate: r})
                {
                    super(),
                    this._isVisible = !0,
                    this._$wrapper = n.closest(o.UI_WRAPPER_SELECTOR),
                    this._comments = t.utils.createTypedArrayMap(t => null == t ? void 0 : t.id),
                    this._$ui = this.$wrapper.find(o.ANNOTATION_UI_SELECTOR),
                    this._annotation = e,
                    this.$reply = this._$ui.find(".comment-reply-text"),
                    this._$tip = this._$ui.find(".annotation-tip"),
                    this._$commentTemplate = r,
                    this._$ui.attr(i.ANNOTATION_ID, e.id),
                    this._$wrapper.attr(i.ANNOTATION_ID, e.id),
                    this._$filter = this._$ui.find(o.FILTERED_SELECTOR),
                    this.attachTextCallbacks(this.$reply),
                    this.refresh()
                }
                dispose()
                {
                    try {
                        this.clear(),
                        this.setSpacer(!1),
                        this._$wrapper.off().find(o.ACTIVE_ELEMENTS).off(),
                        this._$wrapper.remove()
                    } catch (t) {
                        n.logger.error("While disposing annotation ui " + t)
                    }
                }
                get isSelected()
                {
                    return "true" === this._$wrapper.attr(i.SELECTED)
                }
                get isVisible()
                {
                    return this._isVisible
                }
                height()
                {
                    return this._$wrapper.height()
                }
                setSequence(t)
                {
                    return this._$ui.attr(n.lancePluginUtils.pluginAttributes.annotationSequence, t), this._$wrapper.attr(n.lancePluginUtils.pluginAttributes.annotationSequence, t), this
                }
                setSelected(t)
                {
                    return String(t) !== this._$ui.attr(i.SELECTED) && (this._$ui.attr(i.SELECTED, String(t)), this._$wrapper.attr(i.SELECTED, String(t)), t || (this._comments.forEach(t => {
                        t.setSelected(!1)
                    }), this.setExpanded(!1))), this
                }
                setCommentFiltered(t, e)
                {
                    return this.getCommentUI(t).setFiltered(e), this._updateFilteredState(), this
                }
                clear()
                {
                    const t = this.commentViews;
                    this._comments.clear();
                    try {
                        t.forEach(t => t.dispose())
                    } catch (t) {
                        n.logger.error("While clearning annotation view " + t)
                    }
                    return this
                }
                countViews()
                {
                    return this._comments.length
                }
                get id()
                {
                    return this._annotation.id
                }
                get $ui()
                {
                    return this._$ui
                }
                get annotation()
                {
                    return this._annotation
                }
                get commentViews()
                {
                    return this._comments.items
                }
                get $wrapper()
                {
                    return this._$wrapper
                }
                get isReplying()
                {
                    return "true" === this.$ui.attr("data-comment-insert") && "string" != typeof this.$reply.attr("readonly")
                }
                getReplyText()
                {
                    return String(this.$reply.val() || "")
                }
                setReplyText(t)
                {
                    return this.$reply.val() !== t && this.$reply.val(t).trigger("propertychange"), this
                }
                setPlaceholder(t)
                {
                    return this.$reply.attr("placeholder", t), this
                }
                getEditedComment()
                {
                    return this._comments.first(t => t.isEditing)
                }
                setReplying(t)
                {
                    return this.$ui.attr("data-comment-insert", String(t)), this.$reply.attr("readonly", t ? null : "readonly"), t ? setTimeout(() => this.$reply[0].focus({
                        preventScroll: !0
                    }), 50) : this.$reply.val("").trigger("propertychange"), this
                }
                setExpandedCallback(t)
                {
                    const n = this._$filter.find("details");
                    return n.off(".anv"), t && n.on("toggle.anv", n => {
                        const i = e(n.currentTarget).attr("open");
                        t(null != i)
                    }), this
                }
                refresh()
                {
                    return this.setSelected(this.annotation.isSelected()), this.setResolved(this.annotation.isResolved()), this.commentViews.forEach(t => t.refresh()), this
                }
                get isExpanded()
                {
                    return this._$ui.hasClass(o.EXPANDED_CLASS)
                }
                get isCollapsed()
                {
                    return this._$ui.hasClass(o.COLLAPSED_CLASS)
                }
                setFilterLabel(t)
                {
                    return this._$filter.find(".annotation-filtered-caption").text(t || ""), this
                }
                setExpanded(t)
                {
                    this._$ui.toggleClass(o.EXPANDED_CLASS, t);
                    const e = this._$filter.find("details");
                    return "string" == typeof e.attr("open") !== t && e.attr("open", t ? "open" : null), this
                }
                setCollapsed(t)
                {
                    return this._$ui.toggleClass(o.COLLAPSED_CLASS, t), t || 0 !== this.filteredCount || this.setExpanded(!1), this
                }
                setVisible(t)
                {
                    return this._$ui.attr(i.VISIBLE, String(this._isVisible = Boolean(t))), t || 0 !== this.filteredCount || this.setExpanded(!1), this
                }
                setResolved(t)
                {
                    return this._$ui.attr("data-annotation-resolved", this.annotation.isResolved() ? "true" : null), this
                }
                addComment(t)
                {
                    if (!t || this.getCommentUI(t.id))
                        throw new Error("Comment null or already in view");
                    const e = this._$commentTemplate.clone(!1).removeClass("lance-tmpl"),
                        n = new a({
                            comment: t,
                            $ui: e,
                            annotationId: this.id,
                            parent: this
                        });
                    return this._comments.pushItem(n), this._$ui.find(".annotation-comments").append(n.$ui), n
                }
                removeComment(t)
                {
                    const e = this.getCommentUI(t);
                    return e && (this._comments.removeById(t), null == e || e.dispose()), this
                }
                getCommentUI(t)
                {
                    return this._comments.get(t)
                }
                setSpacer(t)
                {
                    const n = this._$wrapper,
                        i = n.next("div." + o.UI_SPACER_CLASS);
                    if (t !== Boolean(i.length))
                        if (t) {
                            const t = n[0].ownerDocument.createElement("div");
                            e(t).css({
                                height: n.height() + "px",
                                backgroundColor: "transparent"
                            }).addClass(o.UI_SPACER_CLASS),
                            n.after(t)
                        } else
                            i.remove();
                    return this
                }
                get filteredCount()
                {
                    return this._comments.count(t => !t.isFiltered)
                }
                alignTip(t)
                {
                    const e = this._$tip;
                    if (!e.length)
                        return;
                    const n = this._$ui.height(),
                        i = e.height() || parseInt(e.css("height")),
                        o = this._comments.length ? 50 : 15,
                        r = Math.max(n - i - 3, 0),
                        s = Math.min(r, o),
                        a = Math.max(s, Math.min(r, t));
                    e.css("top", a + "px")
                }
                _updateFilteredState()
                {
                    const t = this.filteredCount;
                    this._$filter.attr(i.FILTERED_COUNT, String(t)),
                    t || this.isCollapsed || this.setExpanded(!1)
                }
            }
            class c {
                constructor(t, e)
                {
                    this.target = e,
                    this._firstObserve = !0,
                    this._observer = new ResizeObserver(t => {
                        if (this._firstObserve)
                            this._firstObserve = !1;
                        else {
                            const e = t[t.length - 1];
                            this._adjust(e.contentRect),
                            n.logger.debug("Size of container changed")
                        }
                    }),
                    this._adjust(t.getBoundingClientRect()),
                    this._observer.observe(t)
                }
                dispose()
                {
                    var t;
                    null === (t = this._observer) || void 0 === t || t.disconnect(),
                    delete this._observer
                }
                _adjust(t)
                {
                    this.target.style.maxHeight = t.height - this.target.offsetTop - 1 + "px"
                }
            }
            const u = {
                createUIGenerator: () => new r
            };
            Object.assign(n, u)
        }(window.LOOPINDEX),
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        function(t) {
            const e = null == t ? void 0 : t.LANCE,
                n = null == t ? void 0 : t.$;
            if (!e || !n)
                throw new Error("Cannot initialize tinymce plugin without Lance globals");
            const i = t.utils.createCISet("mceFocus"),
                o = 10 * parseInt(tinymce.majorVersion) + .1 * parseInt(tinymce.minorVersion);
            tinymce.PluginManager.add("lance", (function(e, n) {
                !function(t) {
                    if (o < 60)
                        return;
                    t.options.register("lance", {
                        processor: t => null == t || "object" == typeof t && !Array.isArray(t),
                        default: {}
                    })
                }(e);
                const i = new r(e, n);
                return i.initPlugin(e, t.tinymce.getEditorSetting(e, "lance")), i
            }));
            class r {
                constructor(e, n)
                {
                    this._editor = e,
                    this.path = n,
                    this.nodeSynchronizer = null,
                    this._isInited = !1,
                    this._isEditorLoaded = !1,
                    this._useXML = Boolean("xhtml" === t.tinymce.getEditorSetting(e, "element_format"))
                }
                initPlugin(n, i)
                {
                    this._editor = n,
                    i = i || {},
                    e.lancePluginUtils.initLancePlugin({
                        plugin: this,
                        config: i,
                        locale: tinymce.util.I18n.getCode()
                    }),
                    this._setPluginFeatures(n, this.customAttributes),
                    this._onDragCancel = this._onDragCancel.bind(this),
                    this._nodesManager = e.lancePluginUtils.createNodeManager(new l(this), new a(this)),
                    this._nodesManager.enableHandlers(this.config("useTextSelection")),
                    function(e, n) {
                        n.forEach(n => {
                            const i = new RegExp(n + "$", "i"),
                                o = (t.tinymce.getEditorSetting(e, "extended_valid_elements") || "").split(",").map(t => t.trim());
                            o.includes(n) || o.push(n + "[*]"),
                            t.tinymce.setEditorSetting(e, "extended_valid_elements", o.join(","));
                            const r = (t.tinymce.getEditorSetting(e, "custom_elements") || "").split(",").map(t => t && t.trim()).filter(t => t && !i.test(t));
                            r.push("~" + n),
                            t.tinymce.setEditorSetting(e, "custom_elements", r.join(","))
                        })
                    }(n, [this._nodesManager.getTagName()]),
                    n.once("init", e => {
                        o >= 50 && t.utils.pluginUtils.loadPluginPageStyles(this);
                        const n = tinymce.util.I18n.getCode();
                        this.setLanguage(n).then(t => {
                            this._isEditorLoaded = !0,
                            this._maybeFireInit()
                        })
                    }),
                    this._bindToOwner(this._manager, !0)
                }
                fireEditorEvent(t, n)
                {
                    var i;
                    try {
                        if (/^change$/i.test(t))
                            return this._editor.undoManager.add(), !0;
                        {
                            const e = null === (i = this._editor) || void 0 === i ? void 0 : i[o >= 60 ? "dispatch" : "fire"];
                            if ("function" == typeof e)
                                return e.call(this._editor, t, n), !0
                        }
                    } catch (n) {
                        e.logger.error(`Error dispatching editor event ${t}: ${n}`)
                    }
                    return !1
                }
                getEditorUIContainer()
                {
                    return t.tinymce.getEditorUIContainer(this._editor)
                }
                setCommandsState(t, e, n)
                {
                    this._buttonsHandler.setCommandsState(t, {
                        enabled: e,
                        active: n
                    })
                }
                _finalizeConfiguration(t)
                {
                    return t.pageUrls.push("css/editor-tmce.css"), o >= 60 && (t.tagName && "annotation" !== t.tagName || (t.tagName = "lance-annotation")), t
                }
                init(i, r)
                {
                    e.lancePluginUtils.validateApiKey() && (this._buttonsHandler = t.tinymce.createButtonHandler(i, o), this._initUI(i), this._addEventBinding("BeforeSetContent", this._onBeforeDomLoaded)._addEventBinding("SetContent", this._onDomLoaded)._addEventBinding("mouseup", this._onDocumentClick)._addEventBinding("GetContent", this._onGetContent)._addEventBinding("SwitchMode", this._onSwitchMode)._addEventBinding("ExecCommand", this._onAfterCommand)._addEventBinding("BeforeExecCommand", this._onBeforeCommand)),
                    i.on("remove", () => {
                        var t;
                        n(this.getBody()).off(".lance"),
                        null === (t = this._buttonsHandler) || void 0 === t || t.dispose(),
                        this.dispose()
                    }),
                    this._isInited = !0,
                    this._maybeFireInit()
                }
                _uninit()
                {
                    this.dispose(),
                    this._bindToOwner(this._manager, !1)
                }
                logEditorCommands(t)
                {
                    this._config.logCommands = !0
                }
                logEditorEvents(e)
                {
                    t.utils.pluginUtils.logEditorEvents({
                        plugin: this,
                        editor: this._editor,
                        exclude: ["key", "focus", "blur", "scroll", "mouse", "resolve", "SelectionRange", "NodeChange", "VisualAid", ".*execcommand", "dirty"],
                        method: o >= 60 ? "dispatch" : "fire",
                        log: e
                    })
                }
                get nodeManager()
                {
                    return this._nodesManager
                }
                get customAttributes()
                {
                    return this._config.customAttributes.slice()
                }
                get tagName()
                {
                    return this._config.tagName
                }
                get editor()
                {
                    return this._editor
                }
                getDocument()
                {
                    var t,
                        e;
                    return null !== (e = null === (t = this._editor) || void 0 === t ? void 0 : t.getDoc()) && void 0 !== e ? e : null
                }
                get nodeVisibilityObserver()
                {
                    return this._visibilityObserver
                }
                isInline()
                {
                    return Boolean(this._editor && this._editor.inline)
                }
                setUserId(t)
                {
                    return this._manager ? this._manager.setUserId(t) : null
                }
                getUserId()
                {
                    return this._manager && this._manager.getUserId() || null
                }
                getBody()
                {
                    var t,
                        e;
                    return null !== (e = null === (t = this._editor) || void 0 === t ? void 0 : t.getBody()) && void 0 !== e ? e : null
                }
                getInsertPosition()
                {
                    return e.lancePluginUtils.getAnnotationNodePosition(this._getAnnotationNodes(), this._getSelectedNode())
                }
                isDummyElement(t)
                {
                    var e;
                    return (null === (e = null == t ? void 0 : t.className) || void 0 === e ? void 0 : e.indexOf("mce-offscreen-selection")) >= 0
                }
                transactUndo(t)
                {
                    this._editor.undoManager.transact(t)
                }
                _onSelectionChanged()
                {
                    if (this._isSelecting() || !t.utils.pluginUtils.isSelectionInDocument(this))
                        return;
                    this.refreshCommands(e.Commands.ANNOTATE);
                    const n = this.nodeManager.getCommandState(),
                        i = n.inAnnotation ? n.annotationNodes[0] : null;
                    this._maybeSelectAnnotationNode(i)
                }
                onLocaleChanged() {}
                get isActive()
                {
                    return Boolean(this._editor && !this._editor.readonly)
                }
                saveSelection()
                {
                    const t = this.nodeSynchronizer,
                        e = t.stop(),
                        n = this._editor,
                        i = n.selection.getBookmark();
                    return e(), function(e) {
                        e && n.focus(!1);
                        const o = t.stop();
                        n.selection.moveToBookmark(i),
                        o()
                    }
                }
                getSelectedRange()
                {
                    return t.tinymce.getSelectedRange(this._editor)
                }
                setSelectedRange(e)
                {
                    const n = this.eventManager.deactivateNativeBinding("selectionchange"),
                        i = t.tinymce.setSelectedRange(this._editor, e);
                    return n(0), i
                }
                _initUI(n)
                {
                    const i = new Map([[e.Commands.ANNOTATE, {
                            callback: this._onAnnotate
                        }], [e.Commands.RESOLVE_ALL, {
                            callback: () => e.lancePluginUtils.resolveAll(this)
                        }]]),
                        r = this.config("commands").map(t => {
                            var e,
                                n;
                            return Object.assign(Object.assign({}, t), {
                                callback: null === (n = null === (e = i.get(t.command)) || void 0 === e ? void 0 : e.callback) || void 0 === n ? void 0 : n.bind(this),
                                iconName: t.command,
                                name: t.command,
                                iconUrl: t.iconUrl && this.resolvePath(t.iconUrl),
                                title: this.getLocalizedString(t.title)
                            })
                        }).filter(t => t.callback);
                    t.tinymce.applyToolbarConfiguration(n, "lance", r),
                    r.forEach(e => t.tinymce.addCommandAndButton({
                        editor: n,
                        handler: this._buttonsHandler,
                        command: e,
                        editorVersion: o
                    })),
                    t.tinymce.loadToolbarIcons({
                        commands: r,
                        handler: this._buttonsHandler,
                        editor: n,
                        editorVersion: o
                    })
                }
                _maybeFireInit()
                {
                    this._isInited && this._isEditorLoaded && (this._isEditorLoaded = !1, this._editor.fire("lance::init", {
                        lance: this
                    }, !1))
                }
                _onBeforeDomLoaded(t)
                {
                    var n;
                    if (!t)
                        return;
                    const i = t,
                        o = "string" == typeof t.content ? t.content : "";
                    if (t.selection || i.paste) {
                        if (o) {
                            const n = e.lancePluginUtils.cleanupPasteContent(this, o);
                            n && (t.content = n)
                        }
                        return
                    }
                    const r = this._editor,
                        s = r.getDoc();
                    try {
                        this._loadCSS(s)
                    } catch (t) {
                        e.logger.error(t)
                    }
                    if (this._setPluginFeatures(r, this.customAttributes), null === (n = this.nodeSynchronizer) || void 0 === n || n.stop(), o) {
                        const e = this.nodeManager.processDOM(o);
                        e && (t.content = e)
                    }
                }
                _onDomLoaded(t)
                {
                    var i;
                    if (t && (t.selection || t.paste))
                        return;
                    const o = this._editor.getBody();
                    n(o).off(".lance").on("drop.lance", this._onDrop.bind(this)).on("keyup.lance", t => {
                        this.onKeyUp(t)
                    }).on("mouseup.lance", () => {
                        this.onSelectionChanged()
                    }),
                    null === (i = this.nodeSynchronizer) || void 0 === i || i.stop(),
                    this.nodeSynchronizer = e.lancePluginUtils.attachMutationObserver(this, this._nodesManager.getSelector({
                        withTagName: !0
                    })),
                    this._visibilityObserver = e.lancePluginUtils.attachNodeVisibilityObserver(this),
                    e.lancePluginUtils.validateKey(),
                    e.lancePluginUtils.loadAnnotationsFromDOM(this, !0),
                    this.nodeSynchronizer.start()
                }
                _bindToOwner(t, n)
                {
                    t && (t.events.off(this), n && t.events.on(e.Annotations.Events.ANNOTATION_CREATED, this._onAnnotationCreated, this).on(e.Annotations.Events.ANNOTATION_DELETED, this._onAnnotationDeleted, this).on(e.Annotations.Events.ANNOTATION_SELECTED, this._onAnnotationSelected, this).on(e.Annotations.Events.ANNOTATION_UPDATED, this._onAnnotationChanged, this).on(e.Annotations.Events.ATTRIBUTE_CHANGED, this._onAnnotationAttributeChanged, this).on(e.Annotations.Events.COMMENT_DELETED, this._onCommentDeleted, this).on(e.Annotations.Events.COMMENT_CHANGED, this._onCommentChanged, this).on(e.Annotations.Events.COMMENT_ADDED, this._onCommentAdded, this).on(e.Annotations.Events.ENABLED_CHANGED, this._onAnnotationsEnabledChanged, this).on(e.Annotations.Events.DONE_EDITING, this._onCommentEditingDone, this).on(e.Annotations.Events.ANNOTATIONS_RENUMBERED, this._onAnnotationsRenumbered, this).on(e.Annotations.Events.ANNOTATION_RESOLVED, this.onAnnotationResolved, this))
                }
                _onAnnotationCreated(t)
                {
                    const n = t.annotation;
                    if (!n || !this._editor)
                        return void e.logger.error("Annotation created with no editor or annotation");
                    if (this.getAnnotationNodeForId(n.id))
                        return;
                    const i = this.nodeManager.getHandlerForRange();
                    if (!i)
                        return void e.logger.warn("annotation created: no suitable handler");
                    const o = this._pushSelecting(!0);
                    try {
                        const r = i.insertAnnotationNodes();
                        if (!r || !r.length)
                            return e.logger.error("Lance: Failed to create annotation nodes");
                        r.forEach((t, i) => {
                            e.lancePluginUtils.populateAnnotationNode({
                                plugin: this,
                                node: t,
                                annotation: n,
                                saveFullContent: 0 === i
                            })
                        }),
                        !i.usesCommentMarkers && e.lancePluginUtils.isInteractiveAnnotation(t.context) && this._monitorCommentEditing(n.id)
                    } catch (t) {
                        e.logger.error("onAnnotationCreated:", t)
                    } finally {
                        o()
                    }
                }
                _monitorCommentEditing1(n)
                {
                    const i = o => {
                        var r;
                        if (o.annotationId === n) {
                            const s = t.utils.dom.saveScrollPosition(this.getBody());
                            this.editor.focus(!1),
                            s(),
                            this._manager.events.off(e.Annotations.Events.DONE_EDITING, i);
                            const a = o.canceled ? null : this.getAllAnnotationNodesForId(n);
                            if (null == a ? void 0 : a.length) {
                                const t = a[a.length - 1];
                                null === (r = this.nodeManager.getHandlerForNode(t)) || void 0 === r || r.collapseAfterNode(t)
                            }
                        }
                    };
                    this._manager.events.on(e.Annotations.Events.DONE_EDITING, i, this)
                }
                _onAnnotationDeleted(t)
                {
                    const e = t && t.id,
                        n = this._editor.selection.getBookmark();
                    this.nodeManager.uncommentAnnotation(e),
                    this.nodeVisibilityObserver.reload(this.nodeManager.findAnnotationNodes()),
                    n && this._editor.selection.moveToBookmark(n),
                    this.fireEditorEvent("change", null)
                }
                _onAnnotationChanged(t, n)
                {
                    e.lancePluginUtils.processAnnotationChanged({
                        plugin: this,
                        event: t,
                        type: n
                    })
                }
                _onAnnotationAttributeChanged(t)
                {
                    return this._onAnnotationChanged(t, "modify")
                }
                _onCommentDeleted(t)
                {
                    const e = this._manager.getAnnotationById(t.annotationId);
                    this._onAnnotationChanged({
                        annotation: e
                    }, (null == e ? void 0 : e.count()) ? "modify" : "delete")
                }
                _onCommentChanged(t)
                {
                    this._onAnnotationChanged(t, "modify")
                }
                _onCommentAdded(t)
                {
                    var e;
                    this._onAnnotationChanged(t, 1 === (null === (e = t.annotation) || void 0 === e ? void 0 : e.count()) ? "create" : "modify")
                }
                _onCommentEditingDone(t)
                {
                    if (t.canceled || "reply" === t.mode) {
                        const t = this._pushSelecting(!0);
                        setTimeout(t, 10),
                        this._editor.focus(!1)
                    }
                }
                _onAnnotationsEnabledChanged()
                {
                    this.refreshCommands()
                }
                _onAnnotate()
                {
                    e.lancePluginUtils.annotate(this)
                }
                _onSwitchMode(t)
                {
                    this.setEnabled("design" === t.mode)
                }
                _onAfterCommand() {}
                _makeEventRegistration(t, e, n, i=!1)
                {
                    return {
                        event: t,
                        set: () => this._editor.on(t, e, !0 === i),
                        unset: n => n.off(t, e),
                        scope: n
                    }
                }
                _onBeforeAnnotate()
                {
                    const n = "annotate";
                    let i = () => {
                        this.eventManager.removePluginBinding("BeforeAddUndo", n),
                        this.eventManager.removePluginBinding("ExecCommand", n),
                        i = t.utils.yes
                    };
                    this.eventManager.addPluginBinding(this._makeEventRegistration("BeforeAddUndo", t => {
                        null == t || t.preventDefault(),
                        null == t || t.stopImmediatePropagation()
                    }, n, !0)),
                    this.eventManager.addPluginBinding(this._makeEventRegistration("ExecCommand", t => {
                        t.command === e.Commands.ANNOTATE && i()
                    }, n)),
                    this._timeoutClient.setTimer(() => i(), 10)
                }
                _onBeforeCommand(t)
                {
                    if (!this.isEnabled)
                        return;
                    const n = null == t ? void 0 : t.command;
                    i.has(n) || n === e.Commands.ANNOTATE && this._onBeforeAnnotate()
                }
                _onDocumentClick(e)
                {
                    var n;
                    if (!(null === (n = this._manager) || void 0 === n ? void 0 : n.isEnabled()))
                        return;
                    const i = e.target,
                        o = this.getBody();
                    t.utils.dom.isDescendantOf(i, o) || this.onSelectionChanged()
                }
                _onGetContent(n)
                {
                    const i = null == n ? void 0 : n.content;
                    if ("string" == typeof i)
                        try {
                            const e = this.nodeManager.prepareToSave(i, this.getDocument());
                            e && (n.content = t.utils.dom.elementToHtml({
                                el: e,
                                xml: this._useXML,
                                withRoot: !1,
                                encode: t.tinymce.getHTMLStringEncoder(this._editor)
                            }))
                        } catch (t) {
                            e.logger.error("processing get content: " + t)
                        }
                }
                _onDragCancel(t)
                {
                    const n = t.data;
                    let i;
                    if (!n)
                        return;
                    if (i = n.dataTransfer ? n.dataTransfer.$ : n.$ && n.$.dataTransfer, !(null == i ? void 0 : i.getData))
                        return;
                    const o = i.getData("text/html");
                    return o && o.indexOf(e.lancePluginUtils.pluginAttributes.annotationId) > 0 && o.indexOf(e.lancePluginUtils.pluginAttributes.annotationData) > 0 ? (t.cancel(), n.preventDefault && n.preventDefault(), !1) : void 0
                }
                _onDrop(e)
                {
                    var i;
                    if (!e)
                        return;
                    const o = null === (i = null == (e = e.originalEvent || e) ? void 0 : e.dataTransfer) || void 0 === i ? void 0 : i.items;
                    if (null == o ? void 0 : o.length)
                        for (let i = o.length - 1; i >= 0; --i) {
                            const r = o[i];
                            if (!r || "text/html" !== r.type)
                                continue;
                            const s = e.target.ownerDocument;
                            r.getAsString(e => {
                                const i = n(e),
                                    o = i && i[0];
                                if (t.utils.dom.matchesSelector(o, this.nodeManager.getSelector())) {
                                    const e = o.id;
                                    setTimeout((function() {
                                        const n = s.getElementById(e);
                                        t.utils.dom.clearNodeBackgroundImage(n)
                                    }), 10)
                                }
                            });
                            break
                        }
                }
                _getSelectedNode()
                {
                    const t = this.getSelectedRange();
                    if (!(null == t ? void 0 : t.endContainer))
                        return null;
                    const e = t.endContainer;
                    if (3 === e.nodeType || 0 === t.endOffset)
                        return e;
                    return e.childNodes && e.childNodes[t.endOffset - 1] || e
                }
                _getAnnotationNodes()
                {
                    return this.nodeManager.findAnnotationNodes()
                }
                _setPluginFeatures(t, n)
                {
                    if (o >= 60) {
                        const i = t;
                        if (!i.schema)
                            return;
                        const o = Object.keys(e.lancePluginUtils.pluginAttributes).map(t => e.lancePluginUtils.pluginAttributes[t]).concat(n || []).filter(Boolean).join("|"),
                            r = `${this.tagName}[class|id|title|${o}]`;
                        i.schema.addValidElements(r)
                    }
                }
                _addEventBinding(t, e, n=!0, i)
                {
                    const o = n ? e.bind(this) : e;
                    return this.eventManager.addPluginBinding(this._makeEventRegistration(t, o, "plugin", i)), this
                }
            }
            class s {
                constructor(t, e)
                {
                    this._plugin = t,
                    this.name = e,
                    this.tagName = t.tagName
                }
                get plugin()
                {
                    return this._plugin
                }
                get document()
                {
                    const t = this.documentBody;
                    return t && t.ownerDocument
                }
                get documentBody()
                {
                    return this._plugin.getBody()
                }
                getSelectedRange()
                {
                    var t;
                    const e = this._plugin.editor.selection;
                    return null === (t = null == e ? void 0 : e.getRng) || void 0 === t ? void 0 : t.call(e, !0)
                }
                getNativeSelection()
                {
                    const t = this._plugin.editor.selection,
                        e = t && t.getSel();
                    if (e)
                        return e;
                    const n = document,
                        i = n && n.defaultView;
                    return i && i.getSelection && i.getSelection() || n && n.selection
                }
                selectRange(t)
                {
                    const e = this._plugin.editor.selection,
                        n = this._plugin.getDocument().createRange();
                    n.setStart(t.startContainer, t.startOffset),
                    n.setEnd(t.endContainer, t.endOffset),
                    e.setRng(n)
                }
            }
            class a extends s {
                constructor(t)
                {
                    super(t, "pin")
                }
                uncomment(t)
                {
                    n(t).remove()
                }
            }
            class l extends s {
                constructor(t)
                {
                    super(t, "text")
                }
            }
        }(window.LOOPINDEX)
    }()
}]);
